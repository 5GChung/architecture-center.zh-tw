---
title: 記錄和監視微服務
description: 記錄和監視微服務
author: MikeWasson
ms.date: 10/23/2018
ms.topic: guide
ms.service: architecture-center
ms.subservice: reference-architecture
ms.custom: microservices
ms.openlocfilehash: d8263306db4f4c93157ac1d120094338570b4b86
ms.sourcegitcommit: 1b50810208354577b00e89e5c031b774b02736e2
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/23/2019
ms.locfileid: "54482199"
---
# <a name="designing-microservices-logging-and-monitoring"></a><span data-ttu-id="a95d8-103">設計微服務：記錄和監視</span><span class="sxs-lookup"><span data-stu-id="a95d8-103">Designing microservices: Logging and monitoring</span></span>

<span data-ttu-id="a95d8-104">在任何複雜的應用程式中，總會有某個項目在某個時間點發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="a95d8-104">In any complex application, at some point something will go wrong.</span></span> <span data-ttu-id="a95d8-105">在微服務應用程式中，您需要追蹤數十項或甚至數百項服務的狀況。</span><span class="sxs-lookup"><span data-stu-id="a95d8-105">In a microservices application, you need to track what's happening across dozens or even hundreds of services.</span></span> <span data-ttu-id="a95d8-106">記錄和監視都非常重要，可提供您系統的整體觀點。</span><span class="sxs-lookup"><span data-stu-id="a95d8-106">Logging and monitoring are critically important to give you a holistic view of the system.</span></span>

![微服務架構中的監視圖](./images/monitoring.png)

<span data-ttu-id="a95d8-108">在微服務架構中，要指出確切的錯誤原因或效能瓶頸特別具有挑戰性。</span><span class="sxs-lookup"><span data-stu-id="a95d8-108">In a microservices architecture, it can be especially challenging to pinpoint the exact cause of errors or performance bottlenecks.</span></span> <span data-ttu-id="a95d8-109">單一使用者作業可能橫跨多項服務。</span><span class="sxs-lookup"><span data-stu-id="a95d8-109">A single user operation might span multiple services.</span></span> <span data-ttu-id="a95d8-110">服務可能會達到叢集內的網路 I/O 限制。</span><span class="sxs-lookup"><span data-stu-id="a95d8-110">Services may hit network I/O limits inside the cluster.</span></span> <span data-ttu-id="a95d8-111">跨越服務的一連串呼叫可能會在系統中造成背壓，進而導致高延遲或連鎖性失敗。</span><span class="sxs-lookup"><span data-stu-id="a95d8-111">A chain of calls across services may cause backpressure in the system, resulting in high latency or cascading failures.</span></span> <span data-ttu-id="a95d8-112">此外，您通常不知道特定容器會在哪個節點中執行。</span><span class="sxs-lookup"><span data-stu-id="a95d8-112">Moreover, you generally don't know which node a particular container will run in.</span></span> <span data-ttu-id="a95d8-113">位於相同節點的容器可能會競爭有限的 CPU 或記憶體。</span><span class="sxs-lookup"><span data-stu-id="a95d8-113">Containers placed on the same node may be competing for limited CPU or memory.</span></span>

<span data-ttu-id="a95d8-114">為了清楚了解發生什麼情況，您必須收集應用程式的遙測資料。</span><span class="sxs-lookup"><span data-stu-id="a95d8-114">To make sense of what's happening, you must collect telemetry from the application.</span></span>  <span data-ttu-id="a95d8-115">遙測資料可分為「記錄」和「計量」。</span><span class="sxs-lookup"><span data-stu-id="a95d8-115">Telemetry can be divided into *logs* and *metrics*.</span></span> <span data-ttu-id="a95d8-116">[Azure 監視器](/azure/monitoring-and-diagnostics/monitoring-overview)會在 Azure 平台收集記錄和計量。</span><span class="sxs-lookup"><span data-stu-id="a95d8-116">[Azure Monitor](/azure/monitoring-and-diagnostics/monitoring-overview) collects both logs and metrics across the Azure platform.</span></span>

<span data-ttu-id="a95d8-117">**記錄**是在執行應用程式時發生的事件文字型記錄。</span><span class="sxs-lookup"><span data-stu-id="a95d8-117">**Logs** are text-based records of events that occur while the application is running.</span></span> <span data-ttu-id="a95d8-118">其中包括應用程式記錄 (追蹤陳述式) 或 Web 伺服器記錄之類的記錄。</span><span class="sxs-lookup"><span data-stu-id="a95d8-118">They include things like application logs (trace statements) or web server logs.</span></span> <span data-ttu-id="a95d8-119">記錄主要適合用於鑑證和根本原因分析。</span><span class="sxs-lookup"><span data-stu-id="a95d8-119">Logs are primarily useful for forensics and root cause analysis.</span></span>

<span data-ttu-id="a95d8-120">「計量」是可以分析的數值。</span><span class="sxs-lookup"><span data-stu-id="a95d8-120">**Metrics** are numerical values that can be analyzed.</span></span> <span data-ttu-id="a95d8-121">您可以使用計量來即時 (或幾近即時) 觀察系統，或分析一段時間的效能趨勢。</span><span class="sxs-lookup"><span data-stu-id="a95d8-121">You can use them to observe the system in real time (or close to real time), or to analyze performance trends over time.</span></span> <span data-ttu-id="a95d8-122">計量可以進一步分類如下：</span><span class="sxs-lookup"><span data-stu-id="a95d8-122">Metrics can be further subcategorized as follows:</span></span>

- <span data-ttu-id="a95d8-123">**節點層級**計量，包括 CPU、記憶體、網路、磁碟和檔案系統使用狀況。</span><span class="sxs-lookup"><span data-stu-id="a95d8-123">**Node-level** metrics, including CPU, memory, network, disk, and file system usage.</span></span> <span data-ttu-id="a95d8-124">系統計量會協助您了解叢集中每個節點的資源配置，並針對極端值進行疑難排解。</span><span class="sxs-lookup"><span data-stu-id="a95d8-124">System metrics help you to understand resource allocation for each node in the cluster, and troubleshoot outliers.</span></span>

- <span data-ttu-id="a95d8-125">**容器**計量。</span><span class="sxs-lookup"><span data-stu-id="a95d8-125">**Container** metrics.</span></span> <span data-ttu-id="a95d8-126">如果服務是在容器內執行，您需要在容器層級收集計量，而不只是在虛擬機器層級上收集。</span><span class="sxs-lookup"><span data-stu-id="a95d8-126">If services are run inside containers, you need to collect metrics at the container level, not just at the VM level.</span></span> <span data-ttu-id="a95d8-127">您可以設定 Azure 監視器來監視 Azure Kubernetes Service (AKS) 中的容器工作負載。</span><span class="sxs-lookup"><span data-stu-id="a95d8-127">You can set up Azure Monitor to monitor container workloads in Azure Kubernetes Service (AKS).</span></span> <span data-ttu-id="a95d8-128">如需詳細資訊，請參閱[適用於容器的 Azure 監視器概觀](/azure/monitoring/monitoring-container-insights-overview)。</span><span class="sxs-lookup"><span data-stu-id="a95d8-128">For more information, see [Azure Monitor for containers overview](/azure/monitoring/monitoring-container-insights-overview).</span></span> <span data-ttu-id="a95d8-129">對於其他容器協調器，請使用 [Log Analytics 中的容器監視解決方案](/azure/log-analytics/log-analytics-containers)。</span><span class="sxs-lookup"><span data-stu-id="a95d8-129">For other container orchestrators, use the [Container Monitoring solution in Log Analytics](/azure/log-analytics/log-analytics-containers).</span></span>

- <span data-ttu-id="a95d8-130">**應用程式**計量。</span><span class="sxs-lookup"><span data-stu-id="a95d8-130">**Application** metrics.</span></span> <span data-ttu-id="a95d8-131">其中包括可了解服務行為的任何相關計量。</span><span class="sxs-lookup"><span data-stu-id="a95d8-131">This includes any metrics that are relevant to understanding the behavior of a service.</span></span> <span data-ttu-id="a95d8-132">範例包括已排入佇列的輸入 HTTP 要求數目、要求延遲或訊息佇列長度。</span><span class="sxs-lookup"><span data-stu-id="a95d8-132">Examples include the number of queued inbound HTTP requests, request latency, or message queue length.</span></span> <span data-ttu-id="a95d8-133">應用程式也可以建立專屬於網域的自訂計量，例如每分鐘處理的商務交易數目。</span><span class="sxs-lookup"><span data-stu-id="a95d8-133">Applications can also create custom metrics that are specific to the domain, such as the number of business transactions processed per minute.</span></span> <span data-ttu-id="a95d8-134">使用 [Application Insights](/azure/application-insights/app-insights-overview) 啟用應用程式計量。</span><span class="sxs-lookup"><span data-stu-id="a95d8-134">Use [Application Insights](/azure/application-insights/app-insights-overview) to enable application metrics.</span></span>

- <span data-ttu-id="a95d8-135">**相依服務**計量。</span><span class="sxs-lookup"><span data-stu-id="a95d8-135">**Dependent service** metrics.</span></span> <span data-ttu-id="a95d8-136">服務可能會呼叫外部服務或端點，例如受控的 PaaS 服務或 SaaS 服務。</span><span class="sxs-lookup"><span data-stu-id="a95d8-136">Services may call external services or endpoints, such as managed PaaS services or SaaS services.</span></span> <span data-ttu-id="a95d8-137">第三方服務可能會 (也可能不會) 提供任何計量。</span><span class="sxs-lookup"><span data-stu-id="a95d8-137">Third-party services may or may not provide any metrics.</span></span> <span data-ttu-id="a95d8-138">若未提供，您必須憑藉自己的應用程式計量，來追蹤延遲和錯誤率的統計資料。</span><span class="sxs-lookup"><span data-stu-id="a95d8-138">If not, you'll have to rely on your own application metrics to track statistics for latency and error rate.</span></span>

## <a name="considerations"></a><span data-ttu-id="a95d8-139">考量</span><span class="sxs-lookup"><span data-stu-id="a95d8-139">Considerations</span></span>

<span data-ttu-id="a95d8-140">[監視和診斷](../best-practices/monitoring.md)一文會說明監視應用程式的一般最佳做法。</span><span class="sxs-lookup"><span data-stu-id="a95d8-140">The article [Monitoring and diagnostics](../best-practices/monitoring.md) describes general best practices for monitoring an application.</span></span> <span data-ttu-id="a95d8-141">以下是微服務架構內容中需要思考的一些特定事項。</span><span class="sxs-lookup"><span data-stu-id="a95d8-141">Here are some particular things to think about in the context of a microservices architecture.</span></span>

<span data-ttu-id="a95d8-142">**設定和管理**。</span><span class="sxs-lookup"><span data-stu-id="a95d8-142">**Configuration and management**.</span></span> <span data-ttu-id="a95d8-143">您將使用受控服務進行記錄和監視，或將記錄與監視元件部署為叢集內的容器嗎？</span><span class="sxs-lookup"><span data-stu-id="a95d8-143">Will you use a managed service for logging and monitoring, or deploy logging and monitoring components as containers inside the cluster?</span></span> <span data-ttu-id="a95d8-144">如需這些選項的詳細討論，請參閱下面的[技術選項](#technology-options)一節。</span><span class="sxs-lookup"><span data-stu-id="a95d8-144">For more discussion of these options, see the section [Technology Options](#technology-options) below.</span></span>

<span data-ttu-id="a95d8-145">**擷取率**。</span><span class="sxs-lookup"><span data-stu-id="a95d8-145">**Ingestion rate**.</span></span> <span data-ttu-id="a95d8-146">輸送量是多少時，系統可以內嵌遙測事件？</span><span class="sxs-lookup"><span data-stu-id="a95d8-146">What is the throughput at which the system can ingest telemetry events?</span></span> <span data-ttu-id="a95d8-147">如果超出該比率會怎樣？</span><span class="sxs-lookup"><span data-stu-id="a95d8-147">What happens if that rate is exceeded?</span></span> <span data-ttu-id="a95d8-148">例如，系統可能會使用戶端節流，在此情況下遙測資料會遺失，也可能縮小資料取樣。</span><span class="sxs-lookup"><span data-stu-id="a95d8-148">For example, the system may throttle clients, in which case telemetry data is lost, or it may downsample the data.</span></span> <span data-ttu-id="a95d8-149">有時候，您可藉由減少您所收集的資料量來減輕這個問題：</span><span class="sxs-lookup"><span data-stu-id="a95d8-149">Sometimes you can mitigate this problem by reducing the amount of data that you collect:</span></span>

- <span data-ttu-id="a95d8-150">藉由計算統計資料 (例如平均值和標準差) 來彙總計量，並將該統計資料傳送到監視系統。</span><span class="sxs-lookup"><span data-stu-id="a95d8-150">Aggregate metrics by calculating statistics, such as average and standard deviation, and send that statistical data to the monitoring system.</span></span>
- <span data-ttu-id="a95d8-151">縮小資料取樣 &mdash; 也就是只處理某個百分比的事件。</span><span class="sxs-lookup"><span data-stu-id="a95d8-151">Downsample the data &mdash; that is, process only a percentage of the events.</span></span>
- <span data-ttu-id="a95d8-152">將資料分批，以減少監視服務的網路呼叫次數。</span><span class="sxs-lookup"><span data-stu-id="a95d8-152">Batch the data to reduce the number of network calls to the monitoring service.</span></span>

<span data-ttu-id="a95d8-153">**成本**。</span><span class="sxs-lookup"><span data-stu-id="a95d8-153">**Cost**.</span></span> <span data-ttu-id="a95d8-154">內嵌和儲存遙測資料的成本很高，尤其需要大量磁碟區。</span><span class="sxs-lookup"><span data-stu-id="a95d8-154">The cost of ingesting and storing telemetry data may be high, especially at high volumes.</span></span> <span data-ttu-id="a95d8-155">在某些情況下，甚至會超過執行應用程式的成本。</span><span class="sxs-lookup"><span data-stu-id="a95d8-155">In some cases it could even exceed the cost of running the application.</span></span> <span data-ttu-id="a95d8-156">在此情況下，您可能需要藉由彙總、縮小資料取樣或將資料分批 (如上所述) 來減少遙測量。</span><span class="sxs-lookup"><span data-stu-id="a95d8-156">In that case, you may need to reduce the volume of telemetry by aggregating, downsampling, or batching the data, as described above.</span></span>

<span data-ttu-id="a95d8-157">**資料精確度**。</span><span class="sxs-lookup"><span data-stu-id="a95d8-157">**Data fidelity**.</span></span> <span data-ttu-id="a95d8-158">計量的精確度為何？</span><span class="sxs-lookup"><span data-stu-id="a95d8-158">How accurate are the metrics?</span></span> <span data-ttu-id="a95d8-159">使用平均值可避開極端值 (尤其是大規模資料)。</span><span class="sxs-lookup"><span data-stu-id="a95d8-159">Averages can hide outliers, especially at scale.</span></span> <span data-ttu-id="a95d8-160">此外，如果取樣率太低，平均值可以讓資料中的波動變平滑。</span><span class="sxs-lookup"><span data-stu-id="a95d8-160">Also, if the sampling rate is too low, it can smooth out fluctuations in the data.</span></span> <span data-ttu-id="a95d8-161">看起來所有要求都有大約相同的端對端延遲，但實際上大部分的要求所費時間更長。</span><span class="sxs-lookup"><span data-stu-id="a95d8-161">It may appear that all requests have about the same end-to-end latency, when in fact a significant fraction of requests are taking much longer.</span></span>

<span data-ttu-id="a95d8-162">**延遲**。</span><span class="sxs-lookup"><span data-stu-id="a95d8-162">**Latency**.</span></span> <span data-ttu-id="a95d8-163">若要啟用即時監視和警示，應該要能快速取得遙測資料。</span><span class="sxs-lookup"><span data-stu-id="a95d8-163">To enable real-time monitoring and alerts, telemetry data should be available quickly.</span></span> <span data-ttu-id="a95d8-164">資料出現在監視儀表板上要有多「即時」？</span><span class="sxs-lookup"><span data-stu-id="a95d8-164">How "real-time" is the data that appears on the monitoring dashboard?</span></span> <span data-ttu-id="a95d8-165">經過幾秒鐘？</span><span class="sxs-lookup"><span data-stu-id="a95d8-165">A few seconds old?</span></span> <span data-ttu-id="a95d8-166">超過一分鐘？</span><span class="sxs-lookup"><span data-stu-id="a95d8-166">More than a minute?</span></span>

<span data-ttu-id="a95d8-167">**儲存體。**</span><span class="sxs-lookup"><span data-stu-id="a95d8-167">**Storage.**</span></span> <span data-ttu-id="a95d8-168">對記錄而言，最有效的做法是將記錄事件寫入叢集中的暫時儲存體，並且設定代理程式以將記錄檔送到更永續的儲存體。</span><span class="sxs-lookup"><span data-stu-id="a95d8-168">For logs, it may be most efficient to write the log events to ephemeral storage in the cluster, and configure an agent to ship the log files to more persistent storage.</span></span>  <span data-ttu-id="a95d8-169">資料最終應會移至長期儲存體，以便用於回溯分析。</span><span class="sxs-lookup"><span data-stu-id="a95d8-169">Data should eventually be moved to long-term storage so that it's available for retrospective analysis.</span></span> <span data-ttu-id="a95d8-170">微服務架構可產生大量的遙測資料，因此儲存該資料的成本是一大考量。</span><span class="sxs-lookup"><span data-stu-id="a95d8-170">A microservices architecture can generate a large volume of telemetry data, so the cost of storing that data is an important consideration.</span></span> <span data-ttu-id="a95d8-171">此外，也要考慮您查詢資料的方式。</span><span class="sxs-lookup"><span data-stu-id="a95d8-171">Also consider how you will query the data.</span></span>

<span data-ttu-id="a95d8-172">**儀表板和視覺效果。**</span><span class="sxs-lookup"><span data-stu-id="a95d8-172">**Dashboard and visualization.**</span></span> <span data-ttu-id="a95d8-173">您是否可以全面檢視系統 (涵蓋叢集內部和外部服務的所有服務)？</span><span class="sxs-lookup"><span data-stu-id="a95d8-173">Do you get a holistic view of the system, across all of the services, both within the cluster and external services?</span></span> <span data-ttu-id="a95d8-174">如果您將遙測資料和記錄寫入到一個以上的位置，儀表板可以顯示所有位置且相互關聯嗎？</span><span class="sxs-lookup"><span data-stu-id="a95d8-174">If you are writing telemetry data and logs to more than one location, can the dashboard show all of them and correlate?</span></span> <span data-ttu-id="a95d8-175">監視儀表板至少應顯示下列資訊：</span><span class="sxs-lookup"><span data-stu-id="a95d8-175">The monitoring dashboard should show at least the following information:</span></span>

- <span data-ttu-id="a95d8-176">容量和擴增的整體資源配置。</span><span class="sxs-lookup"><span data-stu-id="a95d8-176">Overall resource allocation for capacity and growth.</span></span> <span data-ttu-id="a95d8-177">這包括容器數目、檔案系統計量、網路及核心配置。</span><span class="sxs-lookup"><span data-stu-id="a95d8-177">This includes the number of containers, file system metrics, network, and core allocation.</span></span>
- <span data-ttu-id="a95d8-178">服務層級上相互關聯的容器計量。</span><span class="sxs-lookup"><span data-stu-id="a95d8-178">Container metrics correlated at the service level.</span></span>
- <span data-ttu-id="a95d8-179">與容器相互關聯的系統計量。</span><span class="sxs-lookup"><span data-stu-id="a95d8-179">System metrics correlated with containers.</span></span>
- <span data-ttu-id="a95d8-180">服務錯誤和極端值。</span><span class="sxs-lookup"><span data-stu-id="a95d8-180">Service errors and outliers.</span></span>

## <a name="distributed-tracing"></a><span data-ttu-id="a95d8-181">分散式追蹤</span><span class="sxs-lookup"><span data-stu-id="a95d8-181">Distributed tracing</span></span>

<span data-ttu-id="a95d8-182">如先前所述，微服務的其中一項挑戰是了解跨服務的事件流程。</span><span class="sxs-lookup"><span data-stu-id="a95d8-182">As mentioned, one challenge in microservices is understanding the flow of events across services.</span></span> <span data-ttu-id="a95d8-183">單一作業或交易可能牽涉到對多項服務的呼叫。</span><span class="sxs-lookup"><span data-stu-id="a95d8-183">A single operation or transaction may involve calls to multiple services.</span></span> <span data-ttu-id="a95d8-184">若要重新建構一連串完整的步驟，每項服務應該傳播「相互關聯識別碼」，以作為該作業的唯一識別碼。</span><span class="sxs-lookup"><span data-stu-id="a95d8-184">To reconstruct the entire sequence of steps, each service should propagate a *correlation ID* that acts as a unique identifier for that operation.</span></span> <span data-ttu-id="a95d8-185">相互關聯識別碼能進行跨服務的[分散式追蹤](https://microservices.io/patterns/observability/distributed-tracing.html)。</span><span class="sxs-lookup"><span data-stu-id="a95d8-185">The correlation ID enables [distributed tracing](https://microservices.io/patterns/observability/distributed-tracing.html) across services.</span></span>

<span data-ttu-id="a95d8-186">接收用戶端要求的第一項服務應產生相互關聯識別碼。</span><span class="sxs-lookup"><span data-stu-id="a95d8-186">The first service that receives a client request should generate the correlation ID.</span></span> <span data-ttu-id="a95d8-187">如果服務對另一項服務進行 HTTP 呼叫，它會將相互關聯識別碼放在要求標頭中。</span><span class="sxs-lookup"><span data-stu-id="a95d8-187">If the service makes an HTTP call to another service, it puts the correlation ID in a request header.</span></span> <span data-ttu-id="a95d8-188">同樣地，如果服務傳送非同步訊息，它會將相互關聯識別碼放在訊息中。</span><span class="sxs-lookup"><span data-stu-id="a95d8-188">Similarly, if the service sends an asynchronous message, it puts the correlation ID into the message.</span></span> <span data-ttu-id="a95d8-189">下游服務會繼續傳播相互關聯識別碼，使其流經整個系統。</span><span class="sxs-lookup"><span data-stu-id="a95d8-189">Downstream services continue to propagate the correlation ID, so that it flows through the entire system.</span></span> <span data-ttu-id="a95d8-190">此外，所有寫入應用程式計量或記錄事件的程式碼都應該包含相互關聯識別碼。</span><span class="sxs-lookup"><span data-stu-id="a95d8-190">In addition, all code that writes application metrics or log events should include the correlation ID.</span></span>

<span data-ttu-id="a95d8-191">當服務呼叫相互關聯時，您可以計算作業計量，例如完整交易的端對端延遲、每秒中成功的交易數目，以及失敗交易的百分比。</span><span class="sxs-lookup"><span data-stu-id="a95d8-191">When service calls are correlated, you can calculate operational metrics such as the end-to-end latency for a complete transaction, the number of successful transactions per second, and the percentage of failed transactions.</span></span> <span data-ttu-id="a95d8-192">在應用程式記錄中包含相互關聯識別碼，即可執行根本原因分析。</span><span class="sxs-lookup"><span data-stu-id="a95d8-192">Including correlation IDs in application logs makes it possible to perform root cause analysis.</span></span> <span data-ttu-id="a95d8-193">如果作業失敗，您可以找到相同作業下的所有服務呼叫記錄陳述式。</span><span class="sxs-lookup"><span data-stu-id="a95d8-193">If an operation fails, you can find the log statements for all of the service calls that were part of the same operation.</span></span>

<span data-ttu-id="a95d8-194">以下是實作分散式追蹤時的一些考量：</span><span class="sxs-lookup"><span data-stu-id="a95d8-194">Here are some considerations when implementing distributed tracing:</span></span>

- <span data-ttu-id="a95d8-195">相互關聯識別碼目前沒有標準 HTTP 標頭。</span><span class="sxs-lookup"><span data-stu-id="a95d8-195">There is currently no standard HTTP header for correlation IDs.</span></span> <span data-ttu-id="a95d8-196">您的小組應將自訂標頭值標準化。</span><span class="sxs-lookup"><span data-stu-id="a95d8-196">Your team should standardize on a custom header value.</span></span> <span data-ttu-id="a95d8-197">您的記錄/監視架構或所選的服務網格可決定選項內容。</span><span class="sxs-lookup"><span data-stu-id="a95d8-197">The choice may be decided by your logging/monitoring framework or choice of service mesh.</span></span>

- <span data-ttu-id="a95d8-198">對於非同步的訊息，如果傳訊基礎結構支援將中繼資料新增到訊息，您應將相互關聯識別碼納入為中繼資料。</span><span class="sxs-lookup"><span data-stu-id="a95d8-198">For asynchronous messages, if your messaging infrastructure supports adding metadata to messages, you should include the correlation ID as metadata.</span></span> <span data-ttu-id="a95d8-199">否則，將它納入為訊息結構描述的一部分。</span><span class="sxs-lookup"><span data-stu-id="a95d8-199">Otherwise, include it as part of the message schema.</span></span>

- <span data-ttu-id="a95d8-200">您可能會傳送包含更豐富資訊的「相互關聯內容」 (例如呼叫端與被呼叫端的關聯性)，而不是單一不透明的識別碼。</span><span class="sxs-lookup"><span data-stu-id="a95d8-200">Rather than a single opaque identifier, you might send a *correlation context* that includes richer information, such as caller-callee relationships.</span></span>

- <span data-ttu-id="a95d8-201">Azure Application Insights SDK 會自動將相互關聯內容插入至 HTTP 標頭中，並在 Application Insights 記錄中包含相互關聯識別碼。</span><span class="sxs-lookup"><span data-stu-id="a95d8-201">The Azure Application Insights SDK automatically injects correlation context into HTTP headers, and includes the correlation ID in Application Insights logs.</span></span> <span data-ttu-id="a95d8-202">如果您決定使用 Application Insights 內建的相互關聯功能，某些服務可能仍然需要明確地傳播相互關聯標頭 (視所使用的程式庫而定)。</span><span class="sxs-lookup"><span data-stu-id="a95d8-202">If you decide to use the correlation features built into Application Insights, some services may still need to explicitly propagate the correlation headers, depending on the libraries being used.</span></span> <span data-ttu-id="a95d8-203">如需詳細資訊，請參閱 [Application Insights 中的遙測相互關聯](/azure/application-insights/application-insights-correlation)。</span><span class="sxs-lookup"><span data-stu-id="a95d8-203">For more information, see [Telemetry correlation in Application Insights](/azure/application-insights/application-insights-correlation).</span></span>

- <span data-ttu-id="a95d8-204">如果您使用 Istio 或 linkerd 作為服務網格，這些技術會在透過服務網格 Proxy 路由傳送 HTTP 呼叫時自動產生相互關聯標頭。</span><span class="sxs-lookup"><span data-stu-id="a95d8-204">If you are using Istio or linkerd as a service mesh, these technologies automatically generate correlation headers when HTTP calls are routed through the service mesh proxies.</span></span> <span data-ttu-id="a95d8-205">服務應轉送相關的標頭。</span><span class="sxs-lookup"><span data-stu-id="a95d8-205">Services should forward the relevant headers.</span></span>

  - <span data-ttu-id="a95d8-206">Istio：[分散式要求追蹤](https://istio-releases.github.io/v0.1/docs/tasks/zipkin-tracing.html)</span><span class="sxs-lookup"><span data-stu-id="a95d8-206">Istio: [Distributed Request Tracing](https://istio-releases.github.io/v0.1/docs/tasks/zipkin-tracing.html)</span></span>
  - <span data-ttu-id="a95d8-207">linkerd：[內容標頭](https://linkerd.io/config/1.3.0/linkerd/index.html#http-headers)</span><span class="sxs-lookup"><span data-stu-id="a95d8-207">linkerd: [Context Headers](https://linkerd.io/config/1.3.0/linkerd/index.html#http-headers)</span></span>

- <span data-ttu-id="a95d8-208">請考慮您彙總記錄的方式。</span><span class="sxs-lookup"><span data-stu-id="a95d8-208">Consider how you will aggregate logs.</span></span> <span data-ttu-id="a95d8-209">您可以將各小組在記錄中包含相互關聯識別碼的方式標準化。</span><span class="sxs-lookup"><span data-stu-id="a95d8-209">You may want to standardize across teams on how to include correlation IDs in logs.</span></span> <span data-ttu-id="a95d8-210">使用結構化或半結構化格式 (例如 JSON)，並定義通用欄位以保留相互關聯識別碼。</span><span class="sxs-lookup"><span data-stu-id="a95d8-210">Use a structured or semi-structured format, such as JSON, and define a common field to hold the correlation ID.</span></span>

## <a name="technology-options"></a><span data-ttu-id="a95d8-211">技術選項</span><span class="sxs-lookup"><span data-stu-id="a95d8-211">Technology options</span></span>

<span data-ttu-id="a95d8-212">**Application Insights** 是 Azure 中的受控服務，可內嵌和儲存遙測資料，並提供工具來分析及搜尋資料。</span><span class="sxs-lookup"><span data-stu-id="a95d8-212">**Application Insights** is a managed service in Azure that ingests and stores telemetry data, and provides tools for analyzing and searching the data.</span></span> <span data-ttu-id="a95d8-213">若要使用 Application Insights，請在您的應用程式中安裝檢測套件。</span><span class="sxs-lookup"><span data-stu-id="a95d8-213">To use Application Insights, you install an instrumentation package in your application.</span></span> <span data-ttu-id="a95d8-214">此套件會監視應用程式，並將遙測資料傳送至 Application Insights 服務。</span><span class="sxs-lookup"><span data-stu-id="a95d8-214">This package monitors the app and sends telemetry data to the Application Insights service.</span></span> <span data-ttu-id="a95d8-215">它也可以從主機環境提取遙測資料。</span><span class="sxs-lookup"><span data-stu-id="a95d8-215">It can also pull telemetry data from the host environment.</span></span> <span data-ttu-id="a95d8-216">Application Insights 會提供內建的相互關聯和相依性追蹤。</span><span class="sxs-lookup"><span data-stu-id="a95d8-216">Application Insights provides built-in correlation and dependency tracking.</span></span> <span data-ttu-id="a95d8-217">可讓您在同一個地方追蹤系統計量、應用程式計量及 Azure 服務計量。</span><span class="sxs-lookup"><span data-stu-id="a95d8-217">It lets you track system metrics, application metrics, and Azure service metrics, all in one place.</span></span>

<span data-ttu-id="a95d8-218">如果資料速率超過最大限制，請留意 Application Insights 節流處理；如需詳細資訊，請參閱 [Application Insights 限制](/azure/azure-subscription-service-limits#application-insights-limits)。</span><span class="sxs-lookup"><span data-stu-id="a95d8-218">Be aware that Application Insights throttles if the data rate exceeds a maximum limit; for details, see [Application Insights limits](/azure/azure-subscription-service-limits#application-insights-limits).</span></span> <span data-ttu-id="a95d8-219">單一作業可以產生多個遙測事件，所以如果應用程式遇到大量流量，就可能進行節流。</span><span class="sxs-lookup"><span data-stu-id="a95d8-219">A single operation may generate several telemetry events, so if the application experiences a high volume of traffic, it is likely to get throttled.</span></span> <span data-ttu-id="a95d8-220">若要減輕這個問題，您可以執行取樣以減少遙測流量。</span><span class="sxs-lookup"><span data-stu-id="a95d8-220">To mitigate this problem, you can perform sampling to reduce the telemetry traffic.</span></span> <span data-ttu-id="a95d8-221">缺點是您的計量會比較不精確。</span><span class="sxs-lookup"><span data-stu-id="a95d8-221">The tradeoff is that your metrics will be less precise.</span></span> <span data-ttu-id="a95d8-222">如需詳細資訊，請參閱[在 Application Insights 中取樣](/azure/application-insights/app-insights-sampling)。</span><span class="sxs-lookup"><span data-stu-id="a95d8-222">For more information, see [Sampling in Application Insights](/azure/application-insights/app-insights-sampling).</span></span> <span data-ttu-id="a95d8-223">您也可以預先彙總計量來減少資料量 &mdash; 也就是，計算統計資料值 (例如平均值和標準差)，以及傳送這些值 (而不是原始遙測資料)。</span><span class="sxs-lookup"><span data-stu-id="a95d8-223">You can also reduce the data volume by pre-aggregating metrics &mdash; that is, calculating statistical values such as average and standard deviation, and sending those values instead of the raw telemetry.</span></span> <span data-ttu-id="a95d8-224">下列部落格文章說明大規模使用 Application Insights 的方法：[大規模使用 Azure 監視與分析](https://blogs.msdn.microsoft.com/azurecat/2017/05/11/azure-monitoring-and-analytics-at-scale/)/(英文)/。</span><span class="sxs-lookup"><span data-stu-id="a95d8-224">The following blog post describes an approach to using Application Insights at scale: [Azure Monitoring and Analytics at Scale](https://blogs.msdn.microsoft.com/azurecat/2017/05/11/azure-monitoring-and-analytics-at-scale/).</span></span>

<span data-ttu-id="a95d8-225">此外，請確定您了解 Application Insights 的計價模型，因為您是根據資料量付費。</span><span class="sxs-lookup"><span data-stu-id="a95d8-225">In addition, make sure that you understand the pricing model for Application Insights, because you are charged based on data volume.</span></span> <span data-ttu-id="a95d8-226">如需詳細資訊，請參閱[管理 Application Insights 中的價格和資料磁碟區](/azure/application-insights/app-insights-pricing)。</span><span class="sxs-lookup"><span data-stu-id="a95d8-226">For more information, see [Manage pricing and data volume in Application Insights](/azure/application-insights/app-insights-pricing).</span></span> <span data-ttu-id="a95d8-227">如果您的應用程式產生大量遙測，而您不想執行資料取樣或彙總，則 Application Insights 可能不是適當的選擇。</span><span class="sxs-lookup"><span data-stu-id="a95d8-227">If your application generates a large volume of telemetry, and you don't wish to perform sampling or aggregation of the data, then Application Insights may not be the appropriate choice.</span></span>

<span data-ttu-id="a95d8-228">如果 Application Insights 不符合您的需求，以下是一些使用熱門開放原始碼技術的建議方法。</span><span class="sxs-lookup"><span data-stu-id="a95d8-228">If Application Insights doesn't meet your requirements, here are some suggested approaches that use popular open-source technologies.</span></span>

<span data-ttu-id="a95d8-229">對於系統和容器計量，請考慮將計量匯出至時間序列資料庫，例如在叢集中執行的 **Prometheus** 或 **InfluxDB**。</span><span class="sxs-lookup"><span data-stu-id="a95d8-229">For system and container metrics, consider exporting metrics to a time-series database such as **Prometheus** or **InfluxDB** running in the cluster.</span></span>

- <span data-ttu-id="a95d8-230">InfluxDB 是以推送為基礎的系統。</span><span class="sxs-lookup"><span data-stu-id="a95d8-230">InfluxDB is a push-based system.</span></span> <span data-ttu-id="a95d8-231">代理程式需要推送計量。</span><span class="sxs-lookup"><span data-stu-id="a95d8-231">An agent needs to push the metrics.</span></span> <span data-ttu-id="a95d8-232">您可以使用 [Heapster][heapster]，這項服務會從 kubelet 收集整個叢集的計量、彙總此資料，並將它推送至 InfluxDB 或其他時間序列儲存體解決方案。</span><span class="sxs-lookup"><span data-stu-id="a95d8-232">You can use [Heapster][heapster], which is a service that collects cluster-wide metrics from kubelet, aggregates the data, and pushes it to InfluxDB or other time-series storage solution.</span></span> <span data-ttu-id="a95d8-233">Azure Container Service 會將 Heapster 部署為叢集設定的一部份。</span><span class="sxs-lookup"><span data-stu-id="a95d8-233">Azure Container Service deploys Heapster as part of the cluster setup.</span></span> <span data-ttu-id="a95d8-234">另一個選項是 [Telegraf](https://www.influxdata.com/time-series-platform/telegraf/)，這是用來收集和報告計量的代理程式。</span><span class="sxs-lookup"><span data-stu-id="a95d8-234">Another option is [Telegraf](https://www.influxdata.com/time-series-platform/telegraf/), which is an agent for collecting and reporting metrics.</span></span>

- <span data-ttu-id="a95d8-235">Prometheus 是以提取為基礎的系統。</span><span class="sxs-lookup"><span data-stu-id="a95d8-235">Prometheus is a pull-based system.</span></span> <span data-ttu-id="a95d8-236">它會定期從設定的位置抓取計量。</span><span class="sxs-lookup"><span data-stu-id="a95d8-236">It periodically scrapes metrics from configured locations.</span></span> <span data-ttu-id="a95d8-237">Prometheus 可以抓取 cAdvisor 或 kube-state-metrics 所產生的計量。</span><span class="sxs-lookup"><span data-stu-id="a95d8-237">Prometheus can scrape metrics generated by cAdvisor or kube-state-metrics.</span></span> <span data-ttu-id="a95d8-238">[kube-state-metrics][kube-state-metrics] 是一項服務，可從 Kubernetes API 伺服器收集計量並提供給 Prometheus (或與 Prometheus 用戶端端點相容的抓取工具) 使用。</span><span class="sxs-lookup"><span data-stu-id="a95d8-238">[kube-state-metrics][kube-state-metrics] is a service that collects metrics from the Kubernetes API server and makes them available to Prometheus (or a scraper that is compatible with a Prometheus client endpoint).</span></span> <span data-ttu-id="a95d8-239">有鑑於 Heapster 會彙總 Kubernetes 產生的計量並將它們轉送到接收，kube-state-metrics 會產生自己的計量並透過端點提供這些計量以便抓取。</span><span class="sxs-lookup"><span data-stu-id="a95d8-239">Whereas Heapster aggregates metrics that Kubernetes generates and forwards them to a sink, kube-state-metrics generates its own metrics and makes them available through an endpoint for scraping.</span></span> <span data-ttu-id="a95d8-240">對於系統計量，可使用[節點匯出工具](https://github.com/prometheus/node_exporter)，這是系統計量的 Prometheus 匯出工具。</span><span class="sxs-lookup"><span data-stu-id="a95d8-240">For system metrics, use [Node exporter](https://github.com/prometheus/node_exporter), which is a Prometheus exporter for system metrics.</span></span> <span data-ttu-id="a95d8-241">Prometheus 支援浮點資料，但不支援字串資料，因此適用於系統計量，但不適用於記錄。</span><span class="sxs-lookup"><span data-stu-id="a95d8-241">Prometheus supports floating point data, but not string data, so it is appropriate for system metrics but not logs.</span></span>

- <span data-ttu-id="a95d8-242">使用儀表板工具 (例如 **Kibana** 或 **Grafana**) 來視覺化和監視資料。</span><span class="sxs-lookup"><span data-stu-id="a95d8-242">Use a dashboard tool such as **Kibana** or **Grafana** to visualize and monitor the data.</span></span> <span data-ttu-id="a95d8-243">此儀表板服務也可以在叢集中的容器內執行。</span><span class="sxs-lookup"><span data-stu-id="a95d8-243">The dashboard service can also run inside a container in the cluster.</span></span>

<span data-ttu-id="a95d8-244">對於應用程式記錄，請考慮使用 **Fluentd** 和 **Elasticsearch**。</span><span class="sxs-lookup"><span data-stu-id="a95d8-244">For application logs, consider using **Fluentd** and **Elasticsearch**.</span></span> <span data-ttu-id="a95d8-245">Fluentd 是開放原始碼資料收集器，而 Elasticsearch 是為了作為搜尋引擎而最佳化的文件資料庫。</span><span class="sxs-lookup"><span data-stu-id="a95d8-245">Fluentd is an open source data collector, and Elasticsearch is a document database that is optimized to act as a search engine.</span></span> <span data-ttu-id="a95d8-246">使用這個方法，每項服務都會將記錄傳送至 `stdout` 和 `stderr`，而 Kubernetes 會將這些串流寫入本機檔案系統。</span><span class="sxs-lookup"><span data-stu-id="a95d8-246">Using this approach, each service sends logs to `stdout` and `stderr`, and Kubernetes writes these streams to the local file system.</span></span> <span data-ttu-id="a95d8-247">Fluentd 可收集記錄，選擇性地以來自 Kubernetes 的其他中繼資料來豐富記錄，並將記錄傳送至 Elasticsearch。</span><span class="sxs-lookup"><span data-stu-id="a95d8-247">Fluentd collects the logs, optionally enriches them with additional metadata from Kubernetes, and sends the logs to Elasticsearch.</span></span> <span data-ttu-id="a95d8-248">使用 Kibana、Grafana 或類似工具來建立 Elasticsearch 的儀表板。</span><span class="sxs-lookup"><span data-stu-id="a95d8-248">Use Kibana, Grafana, or a similar tool to create a dashboard for Elasticsearch.</span></span> <span data-ttu-id="a95d8-249">Fluentd 會在叢集中以 daemonset 的形式執行，這可確保每個節點都會被指派一個 Fluentd pod。</span><span class="sxs-lookup"><span data-stu-id="a95d8-249">Fluentd runs as a daemonset in the cluster, which ensures that one Fluentd pod is assigned to each node.</span></span> <span data-ttu-id="a95d8-250">您可以將 Fluentd 設定為收集 kubelet 記錄和容器記錄。</span><span class="sxs-lookup"><span data-stu-id="a95d8-250">You can configure Fluentd to collect kubelet logs as well as container logs.</span></span> <span data-ttu-id="a95d8-251">若有大量記錄，將記錄寫入本機檔案系統可能形成效能瓶頸，特別是在相同節點上有多項服務正在執行時。</span><span class="sxs-lookup"><span data-stu-id="a95d8-251">At high volumes, writing logs to the local file system could become a performance bottleneck, especially when multiple services are running on the same node.</span></span> <span data-ttu-id="a95d8-252">請在生產環境中監視磁碟延遲和檔案系統使用率。</span><span class="sxs-lookup"><span data-stu-id="a95d8-252">Monitor disk latency and file system utilization in production.</span></span>

<span data-ttu-id="a95d8-253">使用 Fluentd 搭配 Elasticsearch 處理記錄的優點之一就是服務不需要任何額外的程式庫相依性。</span><span class="sxs-lookup"><span data-stu-id="a95d8-253">One advantage of using Fluentd with Elasticsearch for logs is that services do not require any additional library dependencies.</span></span> <span data-ttu-id="a95d8-254">每項服務只會寫入至 `stdout` 和 `stderr`，而 Fluentd 會執行將記錄匯出至 Elasticsearch 的程序。</span><span class="sxs-lookup"><span data-stu-id="a95d8-254">Each service just writes to `stdout` and `stderr`, and Fluentd handles exporting the logs into Elasticsearch.</span></span> <span data-ttu-id="a95d8-255">此外，撰寫服務的小組不需要了解如何設定記錄基礎結構。</span><span class="sxs-lookup"><span data-stu-id="a95d8-255">Also, the teams writing services don't need to understand how to configure the logging infrastructure.</span></span> <span data-ttu-id="a95d8-256">其中一項挑戰是針對生產部署設定 Elasticsearch 叢集，使其進行調整以處理您的流量。</span><span class="sxs-lookup"><span data-stu-id="a95d8-256">One challenge is to configure the Elasticsearch cluster for a production deployment, so that it scales to handle your traffic.</span></span>

<span data-ttu-id="a95d8-257">另一個選項是將記錄傳送至 Operations Management Suite (OMS) Log Analytics。</span><span class="sxs-lookup"><span data-stu-id="a95d8-257">Another option is to send logs to Operations Management Suite (OMS) Log Analytics.</span></span> <span data-ttu-id="a95d8-258">[Log Analytics][log-analytics] 服務會將資料收集到中央存放庫中，也可將您應用程式使用的其他 Azure 服務資料合併在一起。</span><span class="sxs-lookup"><span data-stu-id="a95d8-258">The [Log Analytics][log-analytics] service collects log data into a central repository, and can also consolidate data from other Azure services that your application uses.</span></span> <span data-ttu-id="a95d8-259">如需詳細資訊，請參閱[使用 Microsoft Operations Management Suite (OMS) 監視 Azure Container Service 叢集][k8s-to-oms]。</span><span class="sxs-lookup"><span data-stu-id="a95d8-259">For more information, see [Monitor an Azure Container Service cluster with Microsoft Operations Management Suite (OMS)][k8s-to-oms].</span></span>

## <a name="example-logging-with-correlation-ids"></a><span data-ttu-id="a95d8-260">範例：記錄相互關聯識別碼</span><span class="sxs-lookup"><span data-stu-id="a95d8-260">Example: Logging with correlation IDs</span></span>

<span data-ttu-id="a95d8-261">為了說明本章所討論的某些要點，以下是套件服務如何實作記錄功能的延伸範例。</span><span class="sxs-lookup"><span data-stu-id="a95d8-261">To illustrate some of the points discussed in this chapter, here is an extended example of how the Package service implements logging.</span></span> <span data-ttu-id="a95d8-262">套件服務是以 TypeScript 撰寫並使用 Node.js 適用的 [Koa](https://koajs.com/) Web 架構。</span><span class="sxs-lookup"><span data-stu-id="a95d8-262">The Package service was written in TypeScript and uses the [Koa](https://koajs.com/) web framework for Node.js.</span></span> <span data-ttu-id="a95d8-263">有幾個 Node.js 記錄程式庫可供選擇。</span><span class="sxs-lookup"><span data-stu-id="a95d8-263">There are several Node.js logging libraries to choose from.</span></span> <span data-ttu-id="a95d8-264">我們挑選了 [Winston](https://github.com/winstonjs/winston)，這是一個常見的記錄程式庫，經由測試，它可符合我們的效能需求。</span><span class="sxs-lookup"><span data-stu-id="a95d8-264">We picked [Winston](https://github.com/winstonjs/winston), a popular logging library that met our performance requirements when we tested it.</span></span>

<span data-ttu-id="a95d8-265">為了封裝實作詳細資料，我們定義了抽象 `ILogger` 介面：</span><span class="sxs-lookup"><span data-stu-id="a95d8-265">To encapsulate the implementation details, we defined an abstract  `ILogger` interface:</span></span>

```ts
export interface ILogger {
    log(level: string, msg: string, meta?: any)
    debug(msg: string, meta?: any)
    info(msg: string, meta?: any)
    warn(msg: string, meta?: any)
    error(msg: string, meta?: any)
}
```

<span data-ttu-id="a95d8-266">以下是可包裝 Winston 程式庫的 `ILogger` 實作。</span><span class="sxs-lookup"><span data-stu-id="a95d8-266">Here is an `ILogger` implementation that wraps the Winston library.</span></span> <span data-ttu-id="a95d8-267">其採用相互關聯識別碼作為建構函式參數，並將該識別碼插入至每則記錄訊息中。</span><span class="sxs-lookup"><span data-stu-id="a95d8-267">It takes the correlation ID as a constructor parameter, and injects the ID into every log message.</span></span>

```ts
class WinstonLogger implements ILogger {
    constructor(private correlationId: string) {}
    log(level: string, msg: string, payload?: any) {
        var meta : any = {};
        if (payload) { meta.payload = payload };
        if (this.correlationId) { meta.correlationId = this.correlationId }
        winston.log(level, msg, meta)
    }
  
    info(msg: string, payload?: any) {
        this.log('info', msg, payload);
    }
    debug(msg: string, payload?: any) {
        this.log('debug', msg, payload);
    }
    warn(msg: string, payload?: any) {
        this.log('warn', msg, payload);
    }
    error(msg: string, payload?: any) {
        this.log('error', msg, payload);
    }
}
```

<span data-ttu-id="a95d8-268">封裝服務需要從 HTTP 要求擷取相互關聯識別碼。</span><span class="sxs-lookup"><span data-stu-id="a95d8-268">The Package service needs to extract the correlation ID from the HTTP request.</span></span> <span data-ttu-id="a95d8-269">例如，如果您使用 linkerd，則相互關聯識別碼會位於 `l5d-ctx-trace` 標頭。</span><span class="sxs-lookup"><span data-stu-id="a95d8-269">For example, if you're using linkerd, the correlation ID is found in the `l5d-ctx-trace` header.</span></span> <span data-ttu-id="a95d8-270">在 Koa 中，HTTP 要求會儲存在內容物件中，以便通過要求處理管線。</span><span class="sxs-lookup"><span data-stu-id="a95d8-270">In Koa, the HTTP request is stored in a Context object that gets passed through the request processing pipeline.</span></span> <span data-ttu-id="a95d8-271">我們可以定義中介軟體函式，以從內容取得相互關聯識別碼並初始化記錄器。</span><span class="sxs-lookup"><span data-stu-id="a95d8-271">We can define a middleware function to get the correlation ID from the Context and initialize the logger.</span></span> <span data-ttu-id="a95d8-272">(Koa 中的中介軟體函式只是可針對每個要求執行的函式。)</span><span class="sxs-lookup"><span data-stu-id="a95d8-272">(A middleware function in Koa is simply a function that gets executed for each request.)</span></span>

```ts
export type CorrelationIdFn = (ctx: Context) => string;

export function logger(level: string, getCorrelationId: CorrelationIdFn) {
    winston.configure({
        level: level,
        transports: [new (winston.transports.Console)()]
        });
    return async function(ctx: any, next: any) {
        ctx.state.logger = new WinstonLogger(getCorrelationId(ctx));
        await next();
    }
}
```

<span data-ttu-id="a95d8-273">此中介軟體會叫用呼叫端定義的函式 `getCorrelationId`，以取得相互關聯識別碼。</span><span class="sxs-lookup"><span data-stu-id="a95d8-273">This middleware invokes a caller-defined function, `getCorrelationId`, to get the correlation ID.</span></span> <span data-ttu-id="a95d8-274">然後它會建立記錄器的執行個體及將它存放在 `ctx.state` 內，這是 Koa 中使用的索引鍵值字典，可透過管線傳遞資訊。</span><span class="sxs-lookup"><span data-stu-id="a95d8-274">Then it creates an instance of the logger and stashes it inside `ctx.state`, which is a key-value dictionary used in Koa to pass information through the pipeline.</span></span>

<span data-ttu-id="a95d8-275">記錄器中介軟體會在啟動時新增至管線：</span><span class="sxs-lookup"><span data-stu-id="a95d8-275">The logger middleware is added to the pipeline on startup:</span></span>

```ts
app.use(logger(Settings.logLevel(), function (ctx) {
    return ctx.headers[Settings.correlationHeader()];  
}));
```

<span data-ttu-id="a95d8-276">一切設定好之後，就可以輕鬆地將記錄陳述式新增至程式碼。</span><span class="sxs-lookup"><span data-stu-id="a95d8-276">Once everything is configured, it's easy to add logging statements to the code.</span></span> <span data-ttu-id="a95d8-277">例如，以下是查閱套件的方法。</span><span class="sxs-lookup"><span data-stu-id="a95d8-277">For example, here is the method that looks up a package.</span></span> <span data-ttu-id="a95d8-278">其會呼叫 `ILogger.info` 方法兩次。</span><span class="sxs-lookup"><span data-stu-id="a95d8-278">It makes two calls to the `ILogger.info` method.</span></span>

```ts
async getById(ctx: any, next: any) {
  var logger : ILogger = ctx.state.logger;
  var packageId = ctx.params.packageId;
  logger.info('Entering getById, packageId = %s', packageId);

  await next();

  let pkg = await this.repository.findPackage(ctx.params.packageId)

  if (pkg == null) {
    logger.info(`getById: %s not found`, packageId);
    ctx.response.status= 404;
    return;
  }

  ctx.response.status = 200;
  ctx.response.body = this.mapPackageDbToApi(pkg);
}
```

<span data-ttu-id="a95d8-279">我們不需要在記錄陳述式中包含相互關聯識別碼，因為這是由中介軟體函式自動完成。</span><span class="sxs-lookup"><span data-stu-id="a95d8-279">We don't need to include the correlation ID in the logging statements, because that's done automatically by the middleware function.</span></span> <span data-ttu-id="a95d8-280">這會使記錄程式碼變得更整潔，並減少開發人員忘記包含相互關聯識別碼的機會。</span><span class="sxs-lookup"><span data-stu-id="a95d8-280">This makes the logging code cleaner, and reduces the chance that a developer will forget to include the correlation ID.</span></span> <span data-ttu-id="a95d8-281">而因為所有記錄陳述式都會使用抽象 `ILogger` 介面，所以之後可輕易取代記錄器實作。</span><span class="sxs-lookup"><span data-stu-id="a95d8-281">And because all of the logging statements use the abstract `ILogger` interface, it would be easy to replace the logger implementation later.</span></span>

> [!div class="nextstepaction"]
> [<span data-ttu-id="a95d8-282">持續整合和傳遞</span><span class="sxs-lookup"><span data-stu-id="a95d8-282">Continuous integration and delivery</span></span>](./ci-cd.md)

<!-- links -->

[app-insights]: /azure/application-insights/app-insights-overview
[heapster]: https://github.com/kubernetes/heapster
[kube-state-metrics]: https://github.com/kubernetes/kube-state-metrics
[k8s-to-oms]: /azure/container-service/kubernetes/container-service-kubernetes-oms
[log-analytics]: /azure/log-analytics/
