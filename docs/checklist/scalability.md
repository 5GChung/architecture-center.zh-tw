---
title: "延展性檢查清單"
description: "為 Azure 自動調整設計考量的延展性檢查清單指引。"
author: dragon119
ms.date: 01/10/2018
ms.custom: checklist
ms.openlocfilehash: c3eaf41a038dbdd963f54d6c7cff8a8a772f8c48
ms.sourcegitcommit: 3d6dba524cc7661740bdbaf43870de7728d60a01
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/11/2018
---
# <a name="scalability-checklist"></a><span data-ttu-id="ed91a-103">延展性檢查清單</span><span class="sxs-lookup"><span data-stu-id="ed91a-103">Scalability checklist</span></span>

<span data-ttu-id="ed91a-104">延展性是指系統能處理已增加負載的能力，且是[軟體品質要素](../guide/pillars.md)的其中一項。</span><span class="sxs-lookup"><span data-stu-id="ed91a-104">Scalability is the ability of a system to handle increased load, and is one of the [pillars of software quality](../guide/pillars.md).</span></span> <span data-ttu-id="ed91a-105">請使用此檢查清單，從延展性的觀點來檢閱您的應用程式架構。</span><span class="sxs-lookup"><span data-stu-id="ed91a-105">Use this checklist to review your application architecture from a scalability standpoint.</span></span> 

## <a name="application-design"></a><span data-ttu-id="ed91a-106">應用程式設計</span><span class="sxs-lookup"><span data-stu-id="ed91a-106">Application design</span></span>

<span data-ttu-id="ed91a-107">**分割工作負載**。</span><span class="sxs-lookup"><span data-stu-id="ed91a-107">**Partition the workload**.</span></span> <span data-ttu-id="ed91a-108">將程序的組件設計為離散與可分解狀態。</span><span class="sxs-lookup"><span data-stu-id="ed91a-108">Design parts of the process to be discrete and decomposable.</span></span> <span data-ttu-id="ed91a-109">在遵循分離需求功能的一般規則與單一責任原則的情況下，將各個組件的大小減至最小。</span><span class="sxs-lookup"><span data-stu-id="ed91a-109">Minimize the size of each part, while following the usual rules for separation of concerns and the single responsibility principle.</span></span> <span data-ttu-id="ed91a-110">如此一來，散佈元件組件時，即可充分運用每個計算單位 (例如角色或資料庫伺服器)。</span><span class="sxs-lookup"><span data-stu-id="ed91a-110">This allows the component parts to be distributed in a way that maximizes use of each compute unit (such as a role or database server).</span></span> <span data-ttu-id="ed91a-111">它也能藉由新增特定資源的執行個體，更輕鬆地調整應用程式。</span><span class="sxs-lookup"><span data-stu-id="ed91a-111">It also makes it easier to scale the application by adding instances of specific resources.</span></span> <span data-ttu-id="ed91a-112">針對複雜的網域，請考慮採用[微服務架構](..//guide/architecture-styles/microservices.md)。</span><span class="sxs-lookup"><span data-stu-id="ed91a-112">For complex domains, consider adopting a [microservices architecture](..//guide/architecture-styles/microservices.md).</span></span>

<span data-ttu-id="ed91a-113">**調整設計**。</span><span class="sxs-lookup"><span data-stu-id="ed91a-113">**Design for scaling**.</span></span> <span data-ttu-id="ed91a-114">應用程式可藉由調整功能增加與減少角色、佇列和其他所使用之服務的執行個體數目，因應多變的負載。</span><span class="sxs-lookup"><span data-stu-id="ed91a-114">Scaling allows applications to react to variable load by increasing and decreasing the number of instances of roles, queues, and other services they use.</span></span> <span data-ttu-id="ed91a-115">不過，設計應用程式時也必須考量到這一點。</span><span class="sxs-lookup"><span data-stu-id="ed91a-115">However, the application must be designed with this in mind.</span></span> <span data-ttu-id="ed91a-116">例如，該應用程式及其使用的服務必須處於無狀態，才能將要求路由傳送到任何執行個體。</span><span class="sxs-lookup"><span data-stu-id="ed91a-116">For example, the application and the services it uses must be stateless, to allow requests to be routed to any instance.</span></span> <span data-ttu-id="ed91a-117">這可避免在新增或移除特定執行個體時，對目前的使用者造成不良的影響。</span><span class="sxs-lookup"><span data-stu-id="ed91a-117">This also prevents the addition or removal of specific instances from adversely impacting current users.</span></span> <span data-ttu-id="ed91a-118">在新增和移除執行個體時，您也必須實作它們的組態或自動偵測，如此一來，應用程式中的程式碼才能執行必要的路由。</span><span class="sxs-lookup"><span data-stu-id="ed91a-118">You should also implement configuration or auto-detection of instances as they are added and removed, so that code in the application can perform the necessary routing.</span></span> <span data-ttu-id="ed91a-119">例如， Web 應用程式可能會以循環配置資源的方式使用一組佇列，將要求路由至以背景工作角色執行的背景服務。</span><span class="sxs-lookup"><span data-stu-id="ed91a-119">For example, a web application might use a set of queues in a round-robin approach to route requests to background services running in worker roles.</span></span> <span data-ttu-id="ed91a-120">Web 應用程式必須能夠偵測佇列數目的變化，才能成功地路由傳送要求並平衡應用程式上的負載。</span><span class="sxs-lookup"><span data-stu-id="ed91a-120">The web application must be able to detect changes in the number of queues, to successfully route requests and balance the load on the application.</span></span>

<span data-ttu-id="ed91a-121">**以單位進行調整**。</span><span class="sxs-lookup"><span data-stu-id="ed91a-121">**Scale as a unit**.</span></span> <span data-ttu-id="ed91a-122">規劃其他資源，以因應成長。</span><span class="sxs-lookup"><span data-stu-id="ed91a-122">Plan for additional resources to accommodate growth.</span></span> <span data-ttu-id="ed91a-123">了解每個資源的調整上限，並利用分區化或分解方式來突破這些限制。</span><span class="sxs-lookup"><span data-stu-id="ed91a-123">For each resource, know the upper scaling limits, and use sharding or decomposition to go beyond these limits.</span></span> <span data-ttu-id="ed91a-124">根據定義完善的資源組決定系統縮放單位。</span><span class="sxs-lookup"><span data-stu-id="ed91a-124">Determine the scale units for the system in terms of well-defined sets of resources.</span></span> <span data-ttu-id="ed91a-125">在整個系統的某部分缺乏資源所加諸的限制下，這樣能夠更輕鬆地套用相應放大作業，並對應用程式產生較少的負面影響。</span><span class="sxs-lookup"><span data-stu-id="ed91a-125">This makes applying scale-out operations easier, and less prone to negative impact on the application through limitations imposed by lack of resources in some part of the overall system.</span></span> <span data-ttu-id="ed91a-126">例如，新增 x 個 Web 和背景工作角色可能需要 y 個額外佇列和 z 個儲存體帳戶，以處理這些角色所產生的額外工作負載。</span><span class="sxs-lookup"><span data-stu-id="ed91a-126">For example, adding x number of web and worker roles might require y number of additional queues and z number of storage accounts to handle the additional workload generated by the roles.</span></span> <span data-ttu-id="ed91a-127">因此，一個縮放單位可能包含 x 個 Web 和背景工作角色、y 個佇列和 z 個儲存體帳戶。</span><span class="sxs-lookup"><span data-stu-id="ed91a-127">So a scale unit could consist of x web and worker roles, *y* queues, and *z* storage accounts.</span></span> <span data-ttu-id="ed91a-128">應用程式應設計為能藉由新增一或多個縮放單位來輕鬆調整。</span><span class="sxs-lookup"><span data-stu-id="ed91a-128">Design the application so that it's easily scaled by adding one or more scale units.</span></span>

<span data-ttu-id="ed91a-129">**避免用戶端親和性**。</span><span class="sxs-lookup"><span data-stu-id="ed91a-129">**Avoid client affinity**.</span></span> <span data-ttu-id="ed91a-130">可能的話，請確認應用程式不需親和性。</span><span class="sxs-lookup"><span data-stu-id="ed91a-130">Where possible, ensure that the application does not require affinity.</span></span> <span data-ttu-id="ed91a-131">因而可將要求路由傳送至任一個執行個體，而執行個體的數量並不重要。</span><span class="sxs-lookup"><span data-stu-id="ed91a-131">Requests can thus be routed to any instance, and the number of instances is irrelevant.</span></span> <span data-ttu-id="ed91a-132">這也可避免進行儲存、擷取與維護每位使用者狀態資訊所產生的額外負荷。</span><span class="sxs-lookup"><span data-stu-id="ed91a-132">This also avoids the overhead of storing, retrieving, and maintaining state information for each user.</span></span>

<span data-ttu-id="ed91a-133">**利用平台自動調整功能**。</span><span class="sxs-lookup"><span data-stu-id="ed91a-133">**Take advantage of platform autoscaling features**.</span></span> <span data-ttu-id="ed91a-134">通常會優先使用裝載平台支援的自動調整功能 (如 Azure 自動調整)，只有在內建機制無法滿足需求的情況下才會使用自訂或第三方機制 。</span><span class="sxs-lookup"><span data-stu-id="ed91a-134">Where the hosting platform supports an autoscaling capability, such as Azure Autoscale, prefer it to custom or third-party mechanisms unless the built-in mechanism can't fulfill your requirements.</span></span> <span data-ttu-id="ed91a-135">請儘可能使用排程的調整規則，確保資源可正常使用而不會造成啟動延遲，但適度地將重新啟動自動調整新增至規則中，以在必要時因應非預期的變更。</span><span class="sxs-lookup"><span data-stu-id="ed91a-135">Use scheduled scaling rules where possible to ensure resources are available without a start-up delay, but add reactive autoscaling to the rules where appropriate to cope with unexpected changes in demand.</span></span> <span data-ttu-id="ed91a-136">您可以使用服務管理 API 中的自動調整作業來調整自動調整功能，並將自訂計數器新增至規則中 。</span><span class="sxs-lookup"><span data-stu-id="ed91a-136">You can use the autoscaling operations in the Service Management API to adjust autoscaling, and to add custom counters to rules.</span></span> <span data-ttu-id="ed91a-137">如需詳細資訊，請參閱 [自動調整指引](../best-practices/auto-scaling.md)。</span><span class="sxs-lookup"><span data-stu-id="ed91a-137">For more information, see [Auto-scaling guidance](../best-practices/auto-scaling.md).</span></span>

<span data-ttu-id="ed91a-138">**卸載密集 CPU/IO 工作作為背景工作**。</span><span class="sxs-lookup"><span data-stu-id="ed91a-138">**Offload intensive CPU/IO tasks as background tasks**.</span></span> <span data-ttu-id="ed91a-139">若預期對服務的要求需要較長的時間來執行或吸收大量資源，請卸載此要求的處理並轉為個別工作。</span><span class="sxs-lookup"><span data-stu-id="ed91a-139">If a request to a service is expected to take a long time to run or absorb considerable resources, offload the processing for this request to a separate task.</span></span> <span data-ttu-id="ed91a-140">利用背景工作角色或背景工作 (依裝載平台而定) 來執行這些工作。</span><span class="sxs-lookup"><span data-stu-id="ed91a-140">Use worker roles or background jobs (depending on the hosting platform) to execute these tasks.</span></span> <span data-ttu-id="ed91a-141">這項策略可讓服務繼續接收更多要求，並能保持正常回應。</span><span class="sxs-lookup"><span data-stu-id="ed91a-141">This strategy enables the service to continue receiving further requests and remain responsive.</span></span>  <span data-ttu-id="ed91a-142">如需詳細資訊，請參閱「 [背景工作指引](../best-practices/background-jobs.md)」(英文)。</span><span class="sxs-lookup"><span data-stu-id="ed91a-142">For more information, see [Background jobs guidance](../best-practices/background-jobs.md).</span></span>

<span data-ttu-id="ed91a-143">**分散背景工作的工作負載**。</span><span class="sxs-lookup"><span data-stu-id="ed91a-143">**Distribute the workload for background tasks**.</span></span> <span data-ttu-id="ed91a-144">當背景工作很多，或工作需要大量時間或資源，請將工作分散到多個計算單位 (例如背景工作角色或背景工作)。</span><span class="sxs-lookup"><span data-stu-id="ed91a-144">Where there are many background tasks, or the tasks require considerable time or resources, spread the work across multiple compute units (such as worker roles or background jobs).</span></span> <span data-ttu-id="ed91a-145">[Competing Consumers Pattern (競爭取用者模式)](https://msdn.microsoft.com/library/dn568101.aspx)提供了一個可能的解決方案。</span><span class="sxs-lookup"><span data-stu-id="ed91a-145">For one possible solution, see the [Competing Consumers Pattern](https://msdn.microsoft.com/library/dn568101.aspx).</span></span>

<span data-ttu-id="ed91a-146">考慮採用「無共用」架構。</span><span class="sxs-lookup"><span data-stu-id="ed91a-146">**Consider moving towards a *shared-nothing* architecture**.</span></span> <span data-ttu-id="ed91a-147">無共用架構使用獨立且自給自足的節點，完全不會出現爭用情況 (例如，共用服務或儲存體)。</span><span class="sxs-lookup"><span data-stu-id="ed91a-147">A shared-nothing architecture uses independent, self-sufficient nodes that have no single point of contention (such as shared services or storage).</span></span> <span data-ttu-id="ed91a-148">理論上，這類系統幾乎可以無限期地調整。</span><span class="sxs-lookup"><span data-stu-id="ed91a-148">In theory, such a system can scale almost indefinitely.</span></span> <span data-ttu-id="ed91a-149">雖然一般而言，完全無共用架構的方法對大部分的應用程式來說並不實用，卻可能因此有機會設計更好的延展性。</span><span class="sxs-lookup"><span data-stu-id="ed91a-149">While a fully shared-nothing approach is generally not practical for most applications, it may provide opportunities to design for better scalability.</span></span> <span data-ttu-id="ed91a-150">例如，避免使用伺服器端工作階段狀態、用戶端親和性與資料分割，都是採用無共用架構的絕佳範例。</span><span class="sxs-lookup"><span data-stu-id="ed91a-150">For example, avoiding the use of server-side session state, client affinity, and data partitioning are good examples of moving towards a shared-nothing architecture.</span></span>

## <a name="data-management"></a><span data-ttu-id="ed91a-151">資料管理</span><span class="sxs-lookup"><span data-stu-id="ed91a-151">Data management</span></span>

<span data-ttu-id="ed91a-152">**使用資料分割**。</span><span class="sxs-lookup"><span data-stu-id="ed91a-152">**Use data partitioning**.</span></span> <span data-ttu-id="ed91a-153">將資料分割至多個資料庫和資料庫伺服器，或將應用程式設計為使用提供明確分割功能的資料儲存體服務 (範例包括 Azure SQL Database 彈性資料庫和 Azure 表格儲存體)。</span><span class="sxs-lookup"><span data-stu-id="ed91a-153">Divide the data across multiple databases and database servers, or design the application to use data storage services that can provide this partitioning transparently (examples include Azure SQL Database Elastic Database, and Azure Table storage).</span></span> <span data-ttu-id="ed91a-154">此方法有助於達到最佳效能，使調整更加輕鬆自如。</span><span class="sxs-lookup"><span data-stu-id="ed91a-154">This approach can help to maximize performance and allow easier scaling.</span></span> <span data-ttu-id="ed91a-155">資料分割技術有許多種，例如水平資料分割、垂直資料分割與功能資料分割。</span><span class="sxs-lookup"><span data-stu-id="ed91a-155">There are different partitioning techniques, such as horizontal, vertical, and functional.</span></span> <span data-ttu-id="ed91a-156">您可以合併使用以達到最佳效能，上至提升的查詢效能、較簡單的延展性、更佳的管理靈活度、更高的可用性，下至比對存放區類型與其保存的資料。</span><span class="sxs-lookup"><span data-stu-id="ed91a-156">You can use a combination of these to achieve maximum benefit from increased query performance, simpler scalability, more flexible management, better availability, and to match the type of store to the data it will hold.</span></span> <span data-ttu-id="ed91a-157">此外，請考慮針對不同類型的資料使用不同類型的資料存放區，並根據針對特定資料類型最佳化的程度，來決定使用的類型。</span><span class="sxs-lookup"><span data-stu-id="ed91a-157">Also, consider using different types of data store for different types of data, choosing the types based on how well they are optimized for the specific type of data.</span></span> <span data-ttu-id="ed91a-158">這可能包括使用表格儲存體、文件資料庫，或改用資料欄系列資料存放區，以及關聯式資料庫。</span><span class="sxs-lookup"><span data-stu-id="ed91a-158">This may include using table storage, a document database, or a column-family data store, instead of, or as well as, a relational database.</span></span> <span data-ttu-id="ed91a-159">如需詳細資訊，請參閱「 [資料分割指引](../best-practices/data-partitioning.md)」。</span><span class="sxs-lookup"><span data-stu-id="ed91a-159">For more information, see [Data partitioning guidance](../best-practices/data-partitioning.md).</span></span>

<span data-ttu-id="ed91a-160">**最終一致性的設計**。</span><span class="sxs-lookup"><span data-stu-id="ed91a-160">**Design for eventual consistency**.</span></span> <span data-ttu-id="ed91a-161">藉由減少或移除同步處理分割至多個存放區之相關資料的時間，最終一致性得以改善延展性。</span><span class="sxs-lookup"><span data-stu-id="ed91a-161">Eventual consistency improves scalability by reducing or removing the time needed to synchronize related data partitioned across multiple stores.</span></span> <span data-ttu-id="ed91a-162">代價是讀取該資料時，有時會出現不一致的現象，而有些寫入作業也可能會導致衝突。</span><span class="sxs-lookup"><span data-stu-id="ed91a-162">The cost is that data is not always consistent when it is read, and some write operations may cause conflicts.</span></span> <span data-ttu-id="ed91a-163">最終一致性最適用於同筆資料讀取頻率高但寫入頻率低的情況。</span><span class="sxs-lookup"><span data-stu-id="ed91a-163">Eventual consistency is ideal for situations where the same data is read frequently but written infrequently.</span></span> <span data-ttu-id="ed91a-164">如需詳細資訊，請參閱 [Data Consistency Primer (資料一致性入門)](https://msdn.microsoft.com/library/dn589800.aspx)。</span><span class="sxs-lookup"><span data-stu-id="ed91a-164">For more information, see the [Data Consistency Primer](https://msdn.microsoft.com/library/dn589800.aspx).</span></span>

<span data-ttu-id="ed91a-165">**減少元件與服務之間的多對話互動**。</span><span class="sxs-lookup"><span data-stu-id="ed91a-165">**Reduce chatty interactions between components and services**.</span></span> <span data-ttu-id="ed91a-166">避免設計下列互動：要求應用程式必須對服務發出多次呼叫 (每次傳回少量資料)，而不是發出單一呼叫，一次傳回所有資料。</span><span class="sxs-lookup"><span data-stu-id="ed91a-166">Avoid designing interactions in which an application is required to make multiple calls to a service (each of which returns a small amount of data), rather than a single call that can return all of the data.</span></span> <span data-ttu-id="ed91a-167">可能的話，當發出呼叫的對象服務或元件有明顯延遲現象時，將數個相關作業結合成單一要求 。</span><span class="sxs-lookup"><span data-stu-id="ed91a-167">Where possible, combine several related operations into a single request when the call is to a service or component that has noticeable latency.</span></span> <span data-ttu-id="ed91a-168">這樣就能更輕鬆地監視效能和最佳化複雜作業。</span><span class="sxs-lookup"><span data-stu-id="ed91a-168">This makes it easier to monitor performance and optimize complex operations.</span></span> <span data-ttu-id="ed91a-169">例如，使用資料庫中的預存程序來封裝複雜的邏輯，並減少來回傳送與資源鎖定的次數。</span><span class="sxs-lookup"><span data-stu-id="ed91a-169">For example, use stored procedures in databases to encapsulate complex logic, and reduce the number of round trips and resource locking.</span></span>

<span data-ttu-id="ed91a-170">**使用佇列來調節高速資料寫入負載**。</span><span class="sxs-lookup"><span data-stu-id="ed91a-170">**Use queues to level the load for high velocity data writes**.</span></span> <span data-ttu-id="ed91a-171">服務需求激增會使服務超過負荷，且導致提升失敗。</span><span class="sxs-lookup"><span data-stu-id="ed91a-171">Surges in demand for a service can overwhelm that service and cause escalating failures.</span></span> <span data-ttu-id="ed91a-172">若要避免這個問題，請考慮實作「 [佇列型負載調節模式](https://msdn.microsoft.com/library/dn589783.aspx)」。</span><span class="sxs-lookup"><span data-stu-id="ed91a-172">To prevent this, consider implementing the [Queue-Based Load Leveling Pattern](https://msdn.microsoft.com/library/dn589783.aspx).</span></span> <span data-ttu-id="ed91a-173">使用做為所叫用之工作與服務之間緩衝區的佇列。</span><span class="sxs-lookup"><span data-stu-id="ed91a-173">Use a queue that acts as a buffer between a task and a service that it invokes.</span></span> <span data-ttu-id="ed91a-174">這可讓間歇性大量負載更加順暢，否則可能導致服務失敗或工作逾時。</span><span class="sxs-lookup"><span data-stu-id="ed91a-174">This can smooth intermittent heavy loads that may otherwise cause the service to fail or the task to time out.</span></span>

<span data-ttu-id="ed91a-175">**最小化資料存放區的負載**。</span><span class="sxs-lookup"><span data-stu-id="ed91a-175">**Minimize the load on the data store**.</span></span> <span data-ttu-id="ed91a-176">資料存放區通常是個處理瓶頸、昂貴資源，且不易相應放大。可能的話，移除資料存放區的邏輯 (例如，處理 XML 文件或 JSON 物件)，並於應用程式內執行處理。</span><span class="sxs-lookup"><span data-stu-id="ed91a-176">The data store is commonly a processing bottleneck, a costly resource, and often not easy to scale out. Where possible, remove logic (such as processing XML documents or JSON objects) from the data store, and perform processing within the application.</span></span> <span data-ttu-id="ed91a-177">例如，不要將 XML 傳送至資料庫 (除了做為儲存體的不透明字串)，而是在應用程式層將該 XML 序列化或還原序列化，並以資料存放區原生形式傳送。</span><span class="sxs-lookup"><span data-stu-id="ed91a-177">For example, instead of passing XML to the database (other than as an opaque string for storage), serialize or deserialize the XML within the application layer and pass it in a form that is native to the data store.</span></span> <span data-ttu-id="ed91a-178">一般而言，應用程式會比資料存放區更容易相應放大，因此您應嘗試在應用程式內儘可能執行大量運算處理。</span><span class="sxs-lookup"><span data-stu-id="ed91a-178">It's typically much easier to scale out the application than the data store, so you should attempt to do as much of the compute-intensive processing as possible within the application.</span></span>

<span data-ttu-id="ed91a-179">**最小化資料擷取量**。</span><span class="sxs-lookup"><span data-stu-id="ed91a-179">**Minimize the volume of data retrieved**.</span></span> <span data-ttu-id="ed91a-180">指定資料行並使用準則來選取資料列，只擷取您所要求的資料。</span><span class="sxs-lookup"><span data-stu-id="ed91a-180">Retrieve only the data you require by specifying columns and using criteria to select rows.</span></span> <span data-ttu-id="ed91a-181">請使用資料表值參數和適當的隔離層級。</span><span class="sxs-lookup"><span data-stu-id="ed91a-181">Make use of table value parameters and the appropriate isolation level.</span></span> <span data-ttu-id="ed91a-182">使用實體標記等機制來避免擷取不必要的資料。</span><span class="sxs-lookup"><span data-stu-id="ed91a-182">Use mechanisms like entity tags to avoid retrieving data unnecessarily.</span></span>

<span data-ttu-id="ed91a-183">**積極使用快取**。</span><span class="sxs-lookup"><span data-stu-id="ed91a-183">**Aggressively use caching**.</span></span> <span data-ttu-id="ed91a-184">儘可能使用快取，為產生或傳遞資料的資源和服務減少負載。</span><span class="sxs-lookup"><span data-stu-id="ed91a-184">Use caching wherever possible to reduce the load on resources and services that generate or deliver data.</span></span> <span data-ttu-id="ed91a-185">快取通常適用於相對靜態的資料，或需要大量處理才能取得的資料。</span><span class="sxs-lookup"><span data-stu-id="ed91a-185">Caching is typically suited to data that is relatively static, or that requires considerable processing to obtain.</span></span> <span data-ttu-id="ed91a-186">快取應在應用程式各層的所有適當等級中進行，包括資料存取與使用者介面的生成。</span><span class="sxs-lookup"><span data-stu-id="ed91a-186">Caching should occur at all levels where appropriate in each layer of the application, including data access and user interface generation.</span></span> <span data-ttu-id="ed91a-187">如需詳細資訊，請參閱「 [快取指引](../best-practices/caching.md)」。</span><span class="sxs-lookup"><span data-stu-id="ed91a-187">For more information, see the [Caching Guidance](../best-practices/caching.md).</span></span>

<span data-ttu-id="ed91a-188">**處理資料成長與保留**。</span><span class="sxs-lookup"><span data-stu-id="ed91a-188">**Handle data growth and retention**.</span></span> <span data-ttu-id="ed91a-189">應用程式所儲存的資料量會隨著時間成長。</span><span class="sxs-lookup"><span data-stu-id="ed91a-189">The amount of data stored by an application grows over time.</span></span> <span data-ttu-id="ed91a-190">這樣的成長會增加儲存體成本，並增加存取資料時的延遲，這會影響應用程式輸送量和效能。</span><span class="sxs-lookup"><span data-stu-id="ed91a-190">This growth increases storage costs, and increases latency when accessing the data — which affects application throughput and performance.</span></span> <span data-ttu-id="ed91a-191">您可定期封存一些不再存取的舊資料，或將很少存取的資料移至長期儲存體，即使存取延遲因而增加，長期儲存體仍較為經濟實惠。</span><span class="sxs-lookup"><span data-stu-id="ed91a-191">It may be possible to periodically archive some of the old data that is no longer accessed, or move data that is rarely accessed into long-term storage that is more cost efficient, even if the access latency is higher.</span></span>

<span data-ttu-id="ed91a-192">**使用高效二進位格式最佳化資料傳輸物件 (DTO)**。</span><span class="sxs-lookup"><span data-stu-id="ed91a-192">**Optimize Data Transfer Objects (DTOs) using an efficient binary format**.</span></span> <span data-ttu-id="ed91a-193">DTO 會在應用程式各層之間來回傳送多次。</span><span class="sxs-lookup"><span data-stu-id="ed91a-193">DTOs are passed between the layers of an application many times.</span></span> <span data-ttu-id="ed91a-194">將大小降至最低，可減少資源與網路上的負載。</span><span class="sxs-lookup"><span data-stu-id="ed91a-194">Minimizing the size reduces the load on resources and the network.</span></span> <span data-ttu-id="ed91a-195">不過，請在縮減大小以及將資料轉換為使用資料所在位置之所需格式的額外負荷間取得平衡。</span><span class="sxs-lookup"><span data-stu-id="ed91a-195">However, balance the savings with the overhead of converting the data to the required format in each location where it is used.</span></span> <span data-ttu-id="ed91a-196">採用具有最大互通性的格式，以便輕鬆重複使用元件。</span><span class="sxs-lookup"><span data-stu-id="ed91a-196">Adopt a format that has the maximum interoperability to enable easy reuse of a component.</span></span>

<span data-ttu-id="ed91a-197">**設定快取控制**。</span><span class="sxs-lookup"><span data-stu-id="ed91a-197">**Set cache control**.</span></span> <span data-ttu-id="ed91a-198">將應用程式設計和設定為使用輸出快取或片段快取，儘可能將處理負載最小化。</span><span class="sxs-lookup"><span data-stu-id="ed91a-198">Design and configure the application to use output caching or fragment caching where possible, to minimize processing load.</span></span>

<span data-ttu-id="ed91a-199">**啟用用戶端快取**。</span><span class="sxs-lookup"><span data-stu-id="ed91a-199">**Enable client side caching**.</span></span> <span data-ttu-id="ed91a-200">Web 應用程式應於可快取的內容上啟用快取設定。</span><span class="sxs-lookup"><span data-stu-id="ed91a-200">Web applications should enable cache settings on the content that can be cached.</span></span> <span data-ttu-id="ed91a-201">這部分通常預設為停用。</span><span class="sxs-lookup"><span data-stu-id="ed91a-201">This is commonly disabled by default.</span></span> <span data-ttu-id="ed91a-202">設定伺服器來傳遞適當的快取設定標頭，以啟用 Proxy 伺服器與用戶端內容的快取。</span><span class="sxs-lookup"><span data-stu-id="ed91a-202">Configure the server to deliver the appropriate cache control headers to enable caching of content on proxy servers and clients.</span></span>

<span data-ttu-id="ed91a-203">**使用 Azure Blob 儲存體與 Azure 內容傳遞網路來減少應用程式的負載**。</span><span class="sxs-lookup"><span data-stu-id="ed91a-203">**Use Azure blob storage and the Azure Content Delivery Network to reduce the load on the application**.</span></span> <span data-ttu-id="ed91a-204">考慮將靜態或相對靜態的公用內容 (例如影像、資源、指令碼和樣式表) 儲存在 Blob 儲存體中。</span><span class="sxs-lookup"><span data-stu-id="ed91a-204">Consider storing static or relatively static public content, such as images, resources, scripts, and style sheets, in blob storage.</span></span> <span data-ttu-id="ed91a-205">這種方法能減輕應用程式內，因每個要求動態產生內容所導致的負載。</span><span class="sxs-lookup"><span data-stu-id="ed91a-205">This approach relieves the application of the load caused by dynamically generating this content for each request.</span></span> <span data-ttu-id="ed91a-206">此外，請考慮使用內容傳遞網路來快取此內容，並傳遞給用戶端。</span><span class="sxs-lookup"><span data-stu-id="ed91a-206">Additionally, consider using the Content Delivery Network to cache this content and deliver it to clients.</span></span> <span data-ttu-id="ed91a-207">使用內容傳遞網路可改善用戶端效能，因為內容是經由地理位置最近且包含內容傳遞網路快取的資料中心所傳遞。</span><span class="sxs-lookup"><span data-stu-id="ed91a-207">Using the Content Delivery Network can improve performance at the client because the content is delivered from the geographically closest datacenter that contains a Content Delivery Network cache.</span></span> <span data-ttu-id="ed91a-208">如需詳細資訊，請參閱 [內容傳遞網路指引](../best-practices/cdn.md)。</span><span class="sxs-lookup"><span data-stu-id="ed91a-208">For more information, see the [Content Delivery Network Guidance](../best-practices/cdn.md).</span></span>

<span data-ttu-id="ed91a-209">**最佳化與微調 SQL 查詢和索引**。</span><span class="sxs-lookup"><span data-stu-id="ed91a-209">**Optimize and tune SQL queries and indexes**.</span></span> <span data-ttu-id="ed91a-210">某些 T-SQL 陳述式或建構可能會影響效能，可藉由最佳化預存程序中的程式碼來降低影響。</span><span class="sxs-lookup"><span data-stu-id="ed91a-210">Some T-SQL statements or constructs may have an impact on performance that can be reduced by optimizing the code in a stored procedure.</span></span> <span data-ttu-id="ed91a-211">例如，應避免在與 **datetime** 常值比較之前，將 **datetime** 類型轉換成 **varchar**。</span><span class="sxs-lookup"><span data-stu-id="ed91a-211">For example, avoid converting **datetime** types to a **varchar** before comparing with a **datetime** literal value.</span></span> <span data-ttu-id="ed91a-212">請改用日期/時間比較功能。</span><span class="sxs-lookup"><span data-stu-id="ed91a-212">Use date/time comparison functions instead.</span></span> <span data-ttu-id="ed91a-213">缺少適當的索引也可能會減慢查詢執行速度。</span><span class="sxs-lookup"><span data-stu-id="ed91a-213">Lack of appropriate indexes can also slow query execution.</span></span> <span data-ttu-id="ed91a-214">若您使用物件/關聯式對應架構，請了解其運作方式，以及對於資料存取層效能的影響。</span><span class="sxs-lookup"><span data-stu-id="ed91a-214">If you use an object/relational mapping framework, understand how it works and how it may affect performance of the data access layer.</span></span> <span data-ttu-id="ed91a-215">如需詳細資訊，請參閱「 [查詢微調](https://technet.microsoft.com/library/ms176005.aspx)」。</span><span class="sxs-lookup"><span data-stu-id="ed91a-215">For more information, see [Query Tuning](https://technet.microsoft.com/library/ms176005.aspx).</span></span>

<span data-ttu-id="ed91a-216">**考慮去正規化資料**。</span><span class="sxs-lookup"><span data-stu-id="ed91a-216">**Consider de-normalizing data**.</span></span> <span data-ttu-id="ed91a-217">資料正規化有助於避免重複和不一致。</span><span class="sxs-lookup"><span data-stu-id="ed91a-217">Data normalization helps to avoid duplication and inconsistency.</span></span> <span data-ttu-id="ed91a-218">不過，維護多個索引、檢查參考完整性、多重存取小塊資料以及聯結資料表來重組資料，皆會造成額外負荷並影響效能。</span><span class="sxs-lookup"><span data-stu-id="ed91a-218">However, maintaining multiple indexes, checking for referential integrity, performing multiple accesses to small chunks of data, and joining tables to reassemble the data imposes an overhead that can affect performance.</span></span> <span data-ttu-id="ed91a-219">請考慮是否接受一些額外儲存體磁碟區和重複，以減少資料存放區的負載。</span><span class="sxs-lookup"><span data-stu-id="ed91a-219">Consider if some additional storage volume and duplication is acceptable in order to reduce the load on the data store.</span></span> <span data-ttu-id="ed91a-220">此外，請考慮是否依賴應用程式本身 (通常較易於調整) 來取代工作，例如管理參考完整性，以減少資料存放區的負載。</span><span class="sxs-lookup"><span data-stu-id="ed91a-220">Also, consider if the application itself (which is typically easier to scale) can be relied upon to take over tasks such as managing referential integrity in order to reduce the load on the data store.</span></span> <span data-ttu-id="ed91a-221">如需詳細資訊，請參閱「 [資料分割指引](../best-practices/data-partitioning.md)」。</span><span class="sxs-lookup"><span data-stu-id="ed91a-221">For more information, see [Data partitioning guidance](../best-practices/data-partitioning.md).</span></span>

## <a name="implementation"></a><span data-ttu-id="ed91a-222">實作</span><span class="sxs-lookup"><span data-stu-id="ed91a-222">Implementation</span></span>

<span data-ttu-id="ed91a-223">**檢閱效能反模式**。</span><span class="sxs-lookup"><span data-stu-id="ed91a-223">**Review the performance antipatterns**.</span></span> <span data-ttu-id="ed91a-224">如需在應用程式處於壓力下時，可能會造成延展性問題的常見做法，請參閱[效能反模式](../antipatterns/index.md)。</span><span class="sxs-lookup"><span data-stu-id="ed91a-224">See [Performance antipatterns for cloud applications](../antipatterns/index.md) for common practices that are likely to cause scalability problems when an application is under pressure.</span></span>

<span data-ttu-id="ed91a-225">**使用非同步呼叫**。</span><span class="sxs-lookup"><span data-stu-id="ed91a-225">**Use asynchronous calls**.</span></span> <span data-ttu-id="ed91a-226">儘可能使用非同步程式碼來存取受限於 I/O 或網路頻寬，或有明顯延遲的資源或服務，以避免鎖定呼叫執行緒。</span><span class="sxs-lookup"><span data-stu-id="ed91a-226">Use asynchronous code wherever possible when accessing resources or services that may be limited by I/O or network bandwidth, or that have a noticeable latency, in order to avoid locking the calling thread.</span></span> 

<span data-ttu-id="ed91a-227">**避免鎖定資源，並改用開放式方法**。</span><span class="sxs-lookup"><span data-stu-id="ed91a-227">**Avoid locking resources, and use an optimistic approach instead**.</span></span> <span data-ttu-id="ed91a-228">永不鎖定存取資源，例如儲存體或其他有明顯延遲的服務，因為這正是導致效能不佳的主要原因。</span><span class="sxs-lookup"><span data-stu-id="ed91a-228">Never lock access to resources such as storage or other services that have noticeable latency, because this is a primary cause of poor performance.</span></span> <span data-ttu-id="ed91a-229">請務必使用開放式方法來管理並行作業，例如寫入儲存體。</span><span class="sxs-lookup"><span data-stu-id="ed91a-229">Always use optimistic approaches to managing concurrent operations, such as writing to storage.</span></span> <span data-ttu-id="ed91a-230">使用儲存體層級的功能來管理衝突。</span><span class="sxs-lookup"><span data-stu-id="ed91a-230">Use features of the storage layer to manage conflicts.</span></span> <span data-ttu-id="ed91a-231">在分散式應用程式中，資料可能到最後才能保持一致。</span><span class="sxs-lookup"><span data-stu-id="ed91a-231">In distributed applications, data may be only eventually consistent.</span></span>

<span data-ttu-id="ed91a-232">**壓縮高度可壓縮資料來通過高延遲、低頻寬的網路**。</span><span class="sxs-lookup"><span data-stu-id="ed91a-232">**Compress highly compressible data over high latency, low bandwidth networks**.</span></span> <span data-ttu-id="ed91a-233">以 Web 應用程式來說，應用程式所產生並透過網路所傳遞最大量的資料，大部分都是傳送給客戶端要求的 HTTP 回應。</span><span class="sxs-lookup"><span data-stu-id="ed91a-233">In the majority of cases in a web application, the largest volume of data generated by the application and passed over the network is HTTP responses to client requests.</span></span> <span data-ttu-id="ed91a-234">尤其對於靜態內容而言，HTTP 壓縮可大幅度減少資料量。</span><span class="sxs-lookup"><span data-stu-id="ed91a-234">HTTP compression can reduce this considerably, especially for static content.</span></span> <span data-ttu-id="ed91a-235">這樣可以降低成本，也能減少網路負載，不過壓縮動態內容也會對伺服器造成稍高的負載。</span><span class="sxs-lookup"><span data-stu-id="ed91a-235">This can reduce cost as well as reducing the load on the network, though compressing dynamic content does apply a fractionally higher load on the server.</span></span> <span data-ttu-id="ed91a-236">在其他更一般化的環境中，資料壓縮可減少資料傳輸量，並將傳輸時間與成本降到最低，但壓縮或解壓縮過程會增加額外負荷。</span><span class="sxs-lookup"><span data-stu-id="ed91a-236">In other, more generalized environments, data compression can reduce the volume of data transmitted and minimize transfer time and costs, but the compression and decompression processes incur overhead.</span></span> <span data-ttu-id="ed91a-237">因此，壓縮應只在對效能有明顯實質效益的情況使用。</span><span class="sxs-lookup"><span data-stu-id="ed91a-237">As such, compression should only be used when there is a demonstrable gain in performance.</span></span> <span data-ttu-id="ed91a-238">其他序列化方法 (例如 JSON 或二進位編碼) 可在減少承載大小的同時對效能產生較低的影響，而 XML 則是會加重影響。</span><span class="sxs-lookup"><span data-stu-id="ed91a-238">Other serialization methods, such as JSON or binary encodings, may reduce the payload size while having less impact on performance, whereas XML is likely to increase it.</span></span>

<span data-ttu-id="ed91a-239">**最小化連線與資源使用的時間**。</span><span class="sxs-lookup"><span data-stu-id="ed91a-239">**Minimize the time that connections and resources are in use**.</span></span> <span data-ttu-id="ed91a-240">僅在需要連線和資源時維護使用。</span><span class="sxs-lookup"><span data-stu-id="ed91a-240">Maintain connections and resources only for as long as you need to use them.</span></span> <span data-ttu-id="ed91a-241">例如，連線越慢開啟越好，並允許它們儘快返回連線集區。</span><span class="sxs-lookup"><span data-stu-id="ed91a-241">For example, open connections as late as possible, and allow them to be returned to the connection pool as soon as possible.</span></span> <span data-ttu-id="ed91a-242">資源越慢取得越好，處置速度越快越好。</span><span class="sxs-lookup"><span data-stu-id="ed91a-242">Acquire resources as late as possible, and dispose of them as soon as possible.</span></span>

<span data-ttu-id="ed91a-243">**最小化所需的連線數目**。</span><span class="sxs-lookup"><span data-stu-id="ed91a-243">**Minimize the number of connections required**.</span></span> <span data-ttu-id="ed91a-244">服務連線會吸收資源。</span><span class="sxs-lookup"><span data-stu-id="ed91a-244">Service connections absorb resources.</span></span> <span data-ttu-id="ed91a-245">限制所需數目，並確保能儘量重複使用現有連線。</span><span class="sxs-lookup"><span data-stu-id="ed91a-245">Limit the number that are required and ensure that existing connections are reused whenever possible.</span></span> <span data-ttu-id="ed91a-246">例如，在執行驗證之後，適當使用模擬來執行做為特定身分識別的程式碼。</span><span class="sxs-lookup"><span data-stu-id="ed91a-246">For example, after performing authentication, use impersonation where appropriate to run code as a specific identity.</span></span> <span data-ttu-id="ed91a-247">這樣有助於重複使用連線來充分運用連線集區。</span><span class="sxs-lookup"><span data-stu-id="ed91a-247">This can help to make best use of the connection pool by reusing connections.</span></span>
  
> [!NOTE]
> <span data-ttu-id="ed91a-248">只要遵循服務特定的方針，某些服務的 API 就會自動重複使用連線。</span><span class="sxs-lookup"><span data-stu-id="ed91a-248">APIs for some services automatically reuse connections, provided service-specific guidelines are followed.</span></span> <span data-ttu-id="ed91a-249">請務必了解，針對應用程式所使用之每個服務重複使用連線的條件。</span><span class="sxs-lookup"><span data-stu-id="ed91a-249">It's important that you understand the conditions that enable connection reuse for each service that your application uses.</span></span>
> 
> 

<span data-ttu-id="ed91a-250">**以批次方式傳送要求來最佳化網路使用**。</span><span class="sxs-lookup"><span data-stu-id="ed91a-250">**Send requests in batches to optimize network use**.</span></span> <span data-ttu-id="ed91a-251">例如，在存取佇列時以批次方式傳送和讀取訊息，並在存取儲存體或快取時，以批次方式執行多重讀取或寫入。</span><span class="sxs-lookup"><span data-stu-id="ed91a-251">For example, send and read messages in batches when accessing a queue, and perform multiple reads or writes as a batch when accessing storage or a cache.</span></span> <span data-ttu-id="ed91a-252">藉由減少網路呼叫次數，有助於最大化服務與資料存放區的效率。</span><span class="sxs-lookup"><span data-stu-id="ed91a-252">This can help to maximize efficiency of the services and data stores by reducing the number of calls across the network.</span></span>

<span data-ttu-id="ed91a-253">**避免要求儲存伺服器端工作階段狀態** 。</span><span class="sxs-lookup"><span data-stu-id="ed91a-253">**Avoid a requirement to store server-side session state** where possible.</span></span> <span data-ttu-id="ed91a-254">伺服器端工作階段狀態管理通常需要用戶端親和性 (也就是，將每個要求路由傳送至相同的伺服器執行個體)，這會影響系統的調整能力。</span><span class="sxs-lookup"><span data-stu-id="ed91a-254">Server-side session state management typically requires client affinity (that is, routing each request to the same server instance), which affects the ability of the system to scale.</span></span> <span data-ttu-id="ed91a-255">在理想的情況下，您應該將用戶端使用的伺服器設計成無狀態。</span><span class="sxs-lookup"><span data-stu-id="ed91a-255">Ideally, you should design clients to be stateless with respect to the servers that they use.</span></span> <span data-ttu-id="ed91a-256">不過，若應用程式必須維持工作階段狀態，請將敏感資料或大量客戶端資料，儲存在所有執行個體皆可存取的分散式伺服器端快取中。</span><span class="sxs-lookup"><span data-stu-id="ed91a-256">However, if the application must maintain session state, store sensitive data or large volumes of per-client data in a distributed server-side cache that all instances of the application can access.</span></span>

<span data-ttu-id="ed91a-257">**最佳化資料表儲存體結構描述**。</span><span class="sxs-lookup"><span data-stu-id="ed91a-257">**Optimize table storage schemas**.</span></span> <span data-ttu-id="ed91a-258">使用需要每個查詢傳送與處理之表格與資料行名稱的表格儲存體 (例如 Azure 表格儲存體)，請考慮使用較短名稱以減少額外負荷。</span><span class="sxs-lookup"><span data-stu-id="ed91a-258">When using table stores that require the table and column names to be passed and processed with every query, such as Azure table storage, consider using shorter names to reduce this overhead.</span></span> <span data-ttu-id="ed91a-259">不過，使用過度精簡的名稱時，也別犧牲可讀性或可管理性。</span><span class="sxs-lookup"><span data-stu-id="ed91a-259">However, do not sacrifice readability or manageability by using overly compact names.</span></span>

<span data-ttu-id="ed91a-260">在部署期間或在應用程式啟動時建立資源相依性。</span><span class="sxs-lookup"><span data-stu-id="ed91a-260">**Create resource dependencies during deployment or at application startup**.</span></span> <span data-ttu-id="ed91a-261">避免重複呼叫測試資源存在與否的方法，若資源不存在，請建立資源</span><span class="sxs-lookup"><span data-stu-id="ed91a-261">Avoid repeated calls to methods that test the existence of a resource and then create the resource if it does not exist.</span></span> <span data-ttu-id="ed91a-262">Azure 儲存體用戶端程式庫中像是 *CloudTable.CreateIfNotExists* 和 *CloudQueue.CreateIfNotExists* 的方法就會遵循這個模式。</span><span class="sxs-lookup"><span data-stu-id="ed91a-262">Methods such as *CloudTable.CreateIfNotExists* and *CloudQueue.CreateIfNotExists* in the Azure Storage Client Library follow this pattern.</span></span> <span data-ttu-id="ed91a-263">若在每次存取儲存體資料表或儲存體佇列前叫用這些方法，會造成大量的額外負荷 。</span><span class="sxs-lookup"><span data-stu-id="ed91a-263">These methods can impose considerable overhead if they are invoked before each access to a storage table or storage queue.</span></span> <span data-ttu-id="ed91a-264">因此：</span><span class="sxs-lookup"><span data-stu-id="ed91a-264">Instead:</span></span>

* <span data-ttu-id="ed91a-265">請於應用程式進行部署或第一次啟動時建立所需資源 (可在 Web 或背景工作角色的啟動程式碼中，對每個資源 CreateIfNotExists 發出單一呼叫)。</span><span class="sxs-lookup"><span data-stu-id="ed91a-265">Create the required resources when the application is deployed, or when it first starts (a single call to *CreateIfNotExists* for each resource in the startup code for a web or worker role is acceptable).</span></span> <span data-ttu-id="ed91a-266">不過，若您的程式碼嘗試存取不存在的資源，請務必處理可能發生的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="ed91a-266">However, be sure to handle exceptions that may arise if your code attempts to access a resource that doesn't exist.</span></span> <span data-ttu-id="ed91a-267">如果出現這些情況，您應記錄例外狀況，並儘可能警示操作員提醒資源遺漏。</span><span class="sxs-lookup"><span data-stu-id="ed91a-267">In these situations, you should log the exception, and possibly alert an operator that a resource is missing.</span></span>
* <span data-ttu-id="ed91a-268">在某些情況下，建立遺漏資源，使其成為例外狀況處理程式碼的一部分可能較為恰當。</span><span class="sxs-lookup"><span data-stu-id="ed91a-268">Under some circumstances, it may be appropriate to create the missing resource as part of the exception handling code.</span></span> <span data-ttu-id="ed91a-269">但您應謹慎採用此方法，因為缺少資源可能表示程式設計錯誤 (例如資源名稱拼寫錯誤)，或其他基礎結構層級的問題。</span><span class="sxs-lookup"><span data-stu-id="ed91a-269">But you should adopt this approach with caution as the non-existence of the resource might be indicative of a programming error (a misspelled resource name for example), or some other infrastructure-level issue.</span></span>

<span data-ttu-id="ed91a-270">**使用輕量型架構**。</span><span class="sxs-lookup"><span data-stu-id="ed91a-270">**Use lightweight frameworks**.</span></span> <span data-ttu-id="ed91a-271">謹慎選擇 API 與您使用的架構，以最小化應用程式的資源使用情況、執行時間以及整體負載。</span><span class="sxs-lookup"><span data-stu-id="ed91a-271">Carefully choose the APIs and frameworks you use to minimize resource usage, execution time, and overall load on the application.</span></span> <span data-ttu-id="ed91a-272">例如，使用 Web API 來處理服務要求，可減少應用程式使用量且加快執行速度，但這個方法可能比較不適合需要 Windows Communication Foundation 額外功能的進階案例。</span><span class="sxs-lookup"><span data-stu-id="ed91a-272">For example, using Web API to handle service requests can reduce the application footprint and increase execution speed, but it may not be suitable for advanced scenarios where the additional capabilities of Windows Communication Foundation are required.</span></span>

<span data-ttu-id="ed91a-273">**考慮最小化服務帳戶數目**。</span><span class="sxs-lookup"><span data-stu-id="ed91a-273">**Consider minimizing the number of service accounts**.</span></span> <span data-ttu-id="ed91a-274">例如，使用特定帳戶存取會造成連線限制，或在連線較少情況下表現較佳的資源或服務。</span><span class="sxs-lookup"><span data-stu-id="ed91a-274">For example, use a specific account to access resources or services that impose a limit on connections, or perform better where fewer connections are maintained.</span></span> <span data-ttu-id="ed91a-275">這個方法很常用在如資料庫的服務上，但由於原始使用者模擬的關係，會影響到正確稽核作業的能力。</span><span class="sxs-lookup"><span data-stu-id="ed91a-275">This approach is common for services such as databases, but it can affect the ability to accurately audit operations due to the impersonation of the original user.</span></span>

<span data-ttu-id="ed91a-276">**執行效能分析與負載測試** ，視為測試常式的一部分，並在確定發行之前，確認應用程式可視需要執行或調整。</span><span class="sxs-lookup"><span data-stu-id="ed91a-276">**Carry out performance profiling and load testing** during development, as part of test routines, and before final release to ensure the application performs and scales as required.</span></span> <span data-ttu-id="ed91a-277">這個測試應在與生產平台相同的硬體類型上執行，並使用相同的資料類型、數量和使用者負載，因為在生產過程中也會遇到相同情況。</span><span class="sxs-lookup"><span data-stu-id="ed91a-277">This testing should occur on the same type of hardware as the production platform, and with the same types and quantities of data and user load as it will encounter in production.</span></span> <span data-ttu-id="ed91a-278">如需詳細資訊，請參閱 [測試雲端服務的效能](/azure/vs-azure-tools-performance-profiling-cloud-services/)。</span><span class="sxs-lookup"><span data-stu-id="ed91a-278">For more information, see [Testing the performance of a cloud service](/azure/vs-azure-tools-performance-profiling-cloud-services/).</span></span>

