---
title: 微服務中的服務間通訊
description: 微服務中的服務間通訊
author: MikeWasson
ms.date: 10/23/2018
ms.openlocfilehash: 4760cd54c494fb8fded4b396ac772d2c9c82cafa
ms.sourcegitcommit: 1f4cdb08fe73b1956e164ad692f792f9f635b409
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/08/2019
ms.locfileid: "54113484"
---
# <a name="designing-microservices-interservice-communication"></a><span data-ttu-id="41eb4-103">設計微服務：服務間通訊</span><span class="sxs-lookup"><span data-stu-id="41eb4-103">Designing microservices: Interservice communication</span></span>

<span data-ttu-id="41eb4-104">微服務之間的通訊必須要有效率且強固。</span><span class="sxs-lookup"><span data-stu-id="41eb4-104">Communication between microservices must be efficient and robust.</span></span> <span data-ttu-id="41eb4-105">因為會有許多小型服務進行互動以完成單一交易，這可能會是個挑戰。</span><span class="sxs-lookup"><span data-stu-id="41eb4-105">With lots of small services interacting to complete a single transaction, this can be a challenge.</span></span> <span data-ttu-id="41eb4-106">在本章中，我們會關注非同步傳訊與同步 API 之間的取捨。</span><span class="sxs-lookup"><span data-stu-id="41eb4-106">In this chapter, we look at the tradeoffs between asynchronous messaging versus synchronous APIs.</span></span> <span data-ttu-id="41eb4-107">接著我們會關注在設計具有復原能力的服務間通訊時，會碰到的部分挑戰，以及服務網格所扮演的角色。</span><span class="sxs-lookup"><span data-stu-id="41eb4-107">Then we look at some of the challenges in designing resilient interservice communication, and the role that a service mesh can play.</span></span>

![服務間通訊圖](./images/interservice-communication.png)

## <a name="challenges"></a><span data-ttu-id="41eb4-109">挑戰</span><span class="sxs-lookup"><span data-stu-id="41eb4-109">Challenges</span></span>

<span data-ttu-id="41eb4-110">以下是一些服務對服務通訊時會面臨的主要挑戰。</span><span class="sxs-lookup"><span data-stu-id="41eb4-110">Here are some of the main challenges arising from service-to-service communication.</span></span> <span data-ttu-id="41eb4-111">本章中稍後說明的服務網格旨在處理當中的許多挑戰。</span><span class="sxs-lookup"><span data-stu-id="41eb4-111">Service meshes, described later in this chapter, are designed to handle many of these challenges.</span></span>

<span data-ttu-id="41eb4-112">**復原功能**。</span><span class="sxs-lookup"><span data-stu-id="41eb4-112">**Resiliency**.</span></span> <span data-ttu-id="41eb4-113">在任何一個微服務中，都有十幾個、甚至上百個執行個體。</span><span class="sxs-lookup"><span data-stu-id="41eb4-113">There may be dozens or even hundreds of instances of any given microservice.</span></span> <span data-ttu-id="41eb4-114">會導致執行個體失敗的原因眾多。</span><span class="sxs-lookup"><span data-stu-id="41eb4-114">An instance can fail for any number of reasons.</span></span> <span data-ttu-id="41eb4-115">有可能是節點層級失敗，例如硬體失敗或虛擬機器重新啟動。</span><span class="sxs-lookup"><span data-stu-id="41eb4-115">There can be a node-level failure, such as a hardware failure or a VM reboot.</span></span> <span data-ttu-id="41eb4-116">執行個體可能會損毀，或因要求爆滿而無法處理任何新的要求。</span><span class="sxs-lookup"><span data-stu-id="41eb4-116">An instance might crash, or be overwhelmed with requests and unable to process any new requests.</span></span> <span data-ttu-id="41eb4-117">其中任何一個事件都有可能導致網路呼叫失敗。</span><span class="sxs-lookup"><span data-stu-id="41eb4-117">Any of these events can cause a network call to fail.</span></span> <span data-ttu-id="41eb4-118">有兩種設計模式可協助讓服務對服務網路呼叫更具復原能力：</span><span class="sxs-lookup"><span data-stu-id="41eb4-118">There are two design patterns that can help make service-to-service network calls more resilient:</span></span>

- <span data-ttu-id="41eb4-119">**[重試](../patterns/retry.md)**。</span><span class="sxs-lookup"><span data-stu-id="41eb4-119">**[Retry](../patterns/retry.md)**.</span></span> <span data-ttu-id="41eb4-120">網路呼叫可能會因為暫時性錯誤而失敗，而後者會自行解決。</span><span class="sxs-lookup"><span data-stu-id="41eb4-120">A network call may fail because of a transient fault that goes away by itself.</span></span> <span data-ttu-id="41eb4-121">通常呼叫者不會當場失敗，而會重試作業一定的次數，或是直到超過設定的逾時期間為止。</span><span class="sxs-lookup"><span data-stu-id="41eb4-121">Rather than fail outright, the caller should typically retry the operation a certain number of times, or until a configured time-out period elapses.</span></span> <span data-ttu-id="41eb4-122">不過，若作業不具有等冪性，重試可能會導致非預期的副作用。</span><span class="sxs-lookup"><span data-stu-id="41eb4-122">However, if an operation is not idempotent, retries can cause unintended side effects.</span></span> <span data-ttu-id="41eb4-123">原始的呼叫可能已成功，但呼叫者卻未得到回應。</span><span class="sxs-lookup"><span data-stu-id="41eb4-123">The original call might succeed, but the caller never gets a response.</span></span> <span data-ttu-id="41eb4-124">若呼叫者重試，則可能會叫用該作業兩次。</span><span class="sxs-lookup"><span data-stu-id="41eb4-124">If the caller retries, the operation may be invoked twice.</span></span> <span data-ttu-id="41eb4-125">一般而言，重試 POST 或 PATCH 方法並不安全，因為這些方法不保證是等冪的。</span><span class="sxs-lookup"><span data-stu-id="41eb4-125">Generally, it's not safe to retry POST or PATCH methods, because these are not guaranteed to be idempotent.</span></span>

- <span data-ttu-id="41eb4-126">**[斷路器](../patterns/circuit-breaker.md)**。</span><span class="sxs-lookup"><span data-stu-id="41eb4-126">**[Circuit Breaker](../patterns/circuit-breaker.md)**.</span></span> <span data-ttu-id="41eb4-127">失敗的要求過多可能會造成瓶頸，因為擱置中的要求會累積在佇列中。</span><span class="sxs-lookup"><span data-stu-id="41eb4-127">Too many failed requests can cause a bottleneck, as pending requests accumulate in the queue.</span></span> <span data-ttu-id="41eb4-128">這些已封鎖的要求可能會佔據重要的系統資源，例如記憶體、執行緒、資料庫連線等等，可能會造成串聯式失敗。</span><span class="sxs-lookup"><span data-stu-id="41eb4-128">These blocked requests might hold critical system resources such as memory, threads, database connections, and so on, which can cause cascading failures.</span></span> <span data-ttu-id="41eb4-129">「斷路器」模式可防止服務重複嘗試很可能會失敗的作業。</span><span class="sxs-lookup"><span data-stu-id="41eb4-129">The Circuit Breaker pattern can prevent a service from repeatedly trying an operation that is likely to fail.</span></span>

<span data-ttu-id="41eb4-130">**負載平衡**。</span><span class="sxs-lookup"><span data-stu-id="41eb4-130">**Load balancing**.</span></span> <span data-ttu-id="41eb4-131">服務「A」呼叫服務「B」時，要求必須觸達服務「B」的執行個體。</span><span class="sxs-lookup"><span data-stu-id="41eb4-131">When service "A" calls service "B", the request must reach a running instance of service "B".</span></span> <span data-ttu-id="41eb4-132">在 Kubernetes 中，`Service` 資源類型可為 Pod 群組提供穩定的 IP 位址。</span><span class="sxs-lookup"><span data-stu-id="41eb4-132">In Kubernetes, the `Service` resource type provides a stable IP address for a group of pods.</span></span> <span data-ttu-id="41eb4-133">通往服務 IP 位址的網路流量，會透過 iptable 規則轉送給 Pod。</span><span class="sxs-lookup"><span data-stu-id="41eb4-133">Network traffic to the service's IP address gets forwarded to a pod by means of iptable rules.</span></span> <span data-ttu-id="41eb4-134">依預設會隨機選擇 Pod。</span><span class="sxs-lookup"><span data-stu-id="41eb4-134">By default, a random pod is chosen.</span></span> <span data-ttu-id="41eb4-135">服務網格 (請參閱下方) 可根據觀察到的延遲時間或其他度量，提供更加聰明的負載平衡演算法。</span><span class="sxs-lookup"><span data-stu-id="41eb4-135">A service mesh (see below) can provide more intelligent load balancing algorithms based on observed latency or other metrics.</span></span>

<span data-ttu-id="41eb4-136">**分散式追蹤**。</span><span class="sxs-lookup"><span data-stu-id="41eb4-136">**Distributed tracing**.</span></span> <span data-ttu-id="41eb4-137">單一交易可能會跨越多個服務。</span><span class="sxs-lookup"><span data-stu-id="41eb4-137">A single transaction may span multiple services.</span></span> <span data-ttu-id="41eb4-138">這會讓您難以監視系統的整體效能和健康情況。</span><span class="sxs-lookup"><span data-stu-id="41eb4-138">That can make it hard to monitor the overall performance and health of the system.</span></span> <span data-ttu-id="41eb4-139">即使每個服務都會產生記錄和度量，若無法將其繫結在一起，則用途有限。</span><span class="sxs-lookup"><span data-stu-id="41eb4-139">Even if every service generates logs and metrics, without some way to tie them together, they are of limited use.</span></span> <span data-ttu-id="41eb4-140">[記錄和監視](./logging-monitoring.md)一章中深入探討了分散式追蹤，但我們在此將其視為挑戰。</span><span class="sxs-lookup"><span data-stu-id="41eb4-140">The chapter [Logging and monitoring](./logging-monitoring.md) talks more about distributed tracing, but we mention it here as a challenge.</span></span>

<span data-ttu-id="41eb4-141">**服務版本設定**。</span><span class="sxs-lookup"><span data-stu-id="41eb4-141">**Service versioning**.</span></span> <span data-ttu-id="41eb4-142">小組在部署新版本的服務時，必須避免中斷其他服務或依存該服務的外部用戶端。</span><span class="sxs-lookup"><span data-stu-id="41eb4-142">When a team deploys a new version of a service, they must avoid breaking any other services or external clients that depend on it.</span></span> <span data-ttu-id="41eb4-143">此外，您可能會並存執行多個版本的服務，並將要求路由傳送到特定版本。</span><span class="sxs-lookup"><span data-stu-id="41eb4-143">In addition, you might want to run multiple versions of a service side-by-side, and route requests to a particular version.</span></span> <span data-ttu-id="41eb4-144">有關此問題的詳細討論，請參閱 [API 版本設定](./api-design.md#api-versioning)。</span><span class="sxs-lookup"><span data-stu-id="41eb4-144">See [API Versioning](./api-design.md#api-versioning) for more discussion of this issue.</span></span>

<span data-ttu-id="41eb4-145">**TLS 加密和相互 TLS 驗證**。</span><span class="sxs-lookup"><span data-stu-id="41eb4-145">**TLS encryption and mutual TLS authentication**.</span></span> <span data-ttu-id="41eb4-146">基於安全性理由，建議您加密服務與 TLS 之間的流量，並使用相互 TLS 驗證來驗證呼叫者。</span><span class="sxs-lookup"><span data-stu-id="41eb4-146">For security reasons, you may want to encrypt traffic between services with TLS, and use mutual TLS authentication to authenticate callers.</span></span>

## <a name="synchronous-versus-asynchronous-messaging"></a><span data-ttu-id="41eb4-147">同步與非同步傳訊</span><span class="sxs-lookup"><span data-stu-id="41eb4-147">Synchronous versus asynchronous messaging</span></span>

<span data-ttu-id="41eb4-148">微服務有兩種可用來與其他微服務進行通訊的基本傳訊模式。</span><span class="sxs-lookup"><span data-stu-id="41eb4-148">There are two basic messaging patterns that microservices can use to communicate with other microservices.</span></span>

1. <span data-ttu-id="41eb4-149">同步通訊。</span><span class="sxs-lookup"><span data-stu-id="41eb4-149">Synchronous communication.</span></span> <span data-ttu-id="41eb4-150">在此模式中，服務會使用 HTTP 或 gRPC 等通訊協定，來呼叫其他服務所公開的的 API。</span><span class="sxs-lookup"><span data-stu-id="41eb4-150">In this pattern, a service calls an API that another service exposes, using a protocol such as HTTP or gRPC.</span></span> <span data-ttu-id="41eb4-151">這個選項是同步傳訊模式，因為呼叫者會等候來自接收者的回應。</span><span class="sxs-lookup"><span data-stu-id="41eb4-151">This option is a synchronous messaging pattern because the caller waits for a response from the receiver.</span></span>

2. <span data-ttu-id="41eb4-152">非同步訊息傳遞。</span><span class="sxs-lookup"><span data-stu-id="41eb4-152">Asynchronous message passing.</span></span> <span data-ttu-id="41eb4-153">在此模式中，服務會傳送訊息而不等候回應，且一或多個服務會以非同步方式處理訊息。</span><span class="sxs-lookup"><span data-stu-id="41eb4-153">In this pattern, a service sends message without waiting for a response, and one or more services process the message asynchronously.</span></span>

<span data-ttu-id="41eb4-154">請務必區別非同步 I/O 和非同步通訊協定之間的不同。</span><span class="sxs-lookup"><span data-stu-id="41eb4-154">It's important to distinguish between asynchronous I/O and an asynchronous protocol.</span></span> <span data-ttu-id="41eb4-155">非同步 I/O 指的是在 I/O 完成時不會封鎖呼叫執行緒。</span><span class="sxs-lookup"><span data-stu-id="41eb4-155">Asynchronous I/O means the calling thread is not blocked while the I/O completes.</span></span> <span data-ttu-id="41eb4-156">這對效能而言很重要，但這是架構方面的實作詳細資料。</span><span class="sxs-lookup"><span data-stu-id="41eb4-156">That's important for performance, but is an implementation detail in terms of the architecture.</span></span> <span data-ttu-id="41eb4-157">非同步通訊協定指的是傳送者不會等候回應。</span><span class="sxs-lookup"><span data-stu-id="41eb4-157">An asynchronous protocol means the sender doesn't wait for a response.</span></span> <span data-ttu-id="41eb4-158">即使 HTTP 用戶端在傳送要求時，可能會使用非同步 I/O，但 HTTP 仍屬同步通訊協定。</span><span class="sxs-lookup"><span data-stu-id="41eb4-158">HTTP is a synchronous protocol, even though an HTTP client may use asynchronous I/O when it sends a request.</span></span>

<span data-ttu-id="41eb4-159">每種模式都有其權衡取捨。</span><span class="sxs-lookup"><span data-stu-id="41eb4-159">There are tradeoffs to each pattern.</span></span> <span data-ttu-id="41eb4-160">要求/回應是人們已充分理解的範例，因此我們可能會認為設計 API 比設計傳訊系統更好。</span><span class="sxs-lookup"><span data-stu-id="41eb4-160">Request/response is a well-understood paradigm, so designing an API may feel more natural than designing a messaging system.</span></span> <span data-ttu-id="41eb4-161">不過，非同步傳訊在微服務架構中具有某些非常有用的優勢：</span><span class="sxs-lookup"><span data-stu-id="41eb4-161">However, asynchronous messaging has some advantages that can be very useful in a microservices architecture:</span></span>

- <span data-ttu-id="41eb4-162">**可降低結合程度**。</span><span class="sxs-lookup"><span data-stu-id="41eb4-162">**Reduced coupling**.</span></span> <span data-ttu-id="41eb4-163">訊息傳送者無須了解取用者。</span><span class="sxs-lookup"><span data-stu-id="41eb4-163">The message sender does not need to know about the consumer.</span></span>

- <span data-ttu-id="41eb4-164">**能有多個訂閱者**。</span><span class="sxs-lookup"><span data-stu-id="41eb4-164">**Multiple subscribers**.</span></span> <span data-ttu-id="41eb4-165">多個取用者可使用發行/訂閱模型來訂閱，以便接收事件。</span><span class="sxs-lookup"><span data-stu-id="41eb4-165">Using a pub/sub model, multiple consumers can subscribe to receive events.</span></span> <span data-ttu-id="41eb4-166">請參閱[事件驅動架構樣式](/azure/architecture/guide/architecture-styles/event-driven)。</span><span class="sxs-lookup"><span data-stu-id="41eb4-166">See [Event-driven architecture style](/azure/architecture/guide/architecture-styles/event-driven).</span></span>

- <span data-ttu-id="41eb4-167">**可隔離失敗**。</span><span class="sxs-lookup"><span data-stu-id="41eb4-167">**Failure isolation**.</span></span> <span data-ttu-id="41eb4-168">若取用者失敗，傳送者仍然可以傳送訊息。</span><span class="sxs-lookup"><span data-stu-id="41eb4-168">If the consumer fails, the sender can still send messages.</span></span> <span data-ttu-id="41eb4-169">取用者復原時就可得到訊息。</span><span class="sxs-lookup"><span data-stu-id="41eb4-169">The messages will be picked up when the consumer recovers.</span></span> <span data-ttu-id="41eb4-170">這項功能在微服務架構中特別有用，因為每個服務都有其自己的生命週期。</span><span class="sxs-lookup"><span data-stu-id="41eb4-170">This ability is especially useful in a microservices architecture, because each service has its own lifecycle.</span></span> <span data-ttu-id="41eb4-171">服務隨時都可能會停用，或由新版本的服務取代舊服務。</span><span class="sxs-lookup"><span data-stu-id="41eb4-171">A service could become unavailable or be replaced with a newer version at any given time.</span></span> <span data-ttu-id="41eb4-172">非同步傳訊可以處理間歇性停機。</span><span class="sxs-lookup"><span data-stu-id="41eb4-172">Asynchronous messaging can handle intermittent downtime.</span></span> <span data-ttu-id="41eb4-173">相反地，同步 API 則需要下游服務可供使用，否則作業就會失敗。</span><span class="sxs-lookup"><span data-stu-id="41eb4-173">Synchronous APIs, on the other hand, require the downstream service to be available or the operation fails.</span></span>

- <span data-ttu-id="41eb4-174">**具有回應能力**。</span><span class="sxs-lookup"><span data-stu-id="41eb4-174">**Responsiveness**.</span></span> <span data-ttu-id="41eb4-175">若不等候下游服務，上游服務就可以更快回覆。</span><span class="sxs-lookup"><span data-stu-id="41eb4-175">An upstream service can reply faster if it does not wait on downstream services.</span></span> <span data-ttu-id="41eb4-176">這在微服務架構中特別有用。</span><span class="sxs-lookup"><span data-stu-id="41eb4-176">This is especially useful in a microservices architecture.</span></span> <span data-ttu-id="41eb4-177">若有服務相依性鏈結存在 (服務 A 呼叫 B、服務 B 呼叫 C，依此類推)，則等候同步呼叫可能會導致無法接受的延遲。</span><span class="sxs-lookup"><span data-stu-id="41eb4-177">If there is a chain of service dependencies (service A calls B, which calls C, and so on), waiting on synchronous calls can add unacceptable amounts of latency.</span></span>

- <span data-ttu-id="41eb4-178">**負載調節**。</span><span class="sxs-lookup"><span data-stu-id="41eb4-178">**Load leveling**.</span></span> <span data-ttu-id="41eb4-179">佇列可作為緩衝區來調節工作負載，讓接收者能以自己的步調來處理訊息。</span><span class="sxs-lookup"><span data-stu-id="41eb4-179">A queue can act as a buffer to level the workload, so that receivers can process messages at their own rate.</span></span>

- <span data-ttu-id="41eb4-180">**工作流程**。</span><span class="sxs-lookup"><span data-stu-id="41eb4-180">**Workflows**.</span></span> <span data-ttu-id="41eb4-181">透過在執行工作流程的每個步驟後對訊息進行檢查點設置，佇列可用來管理工作流程。</span><span class="sxs-lookup"><span data-stu-id="41eb4-181">Queues can be used to manage a workflow, by check-pointing the message after each step in the workflow.</span></span>

<span data-ttu-id="41eb4-182">不過，想要有效使用非同步傳訊也有一些挑戰。</span><span class="sxs-lookup"><span data-stu-id="41eb4-182">However, there are also some challenges to using asynchronous messaging effectively.</span></span>

- <span data-ttu-id="41eb4-183">**與傳訊基礎結構的結合程度**。</span><span class="sxs-lookup"><span data-stu-id="41eb4-183">**Coupling with the messaging infrastructure**.</span></span> <span data-ttu-id="41eb4-184">若使用特定的傳訊基礎結構，系統可能會與該基礎結構密不可分。</span><span class="sxs-lookup"><span data-stu-id="41eb4-184">Using a particular messaging infrastructure may cause tight coupling with that infrastructure.</span></span> <span data-ttu-id="41eb4-185">稍後要切換到其他傳訊基礎結構會很困難。</span><span class="sxs-lookup"><span data-stu-id="41eb4-185">It will be difficult to switch to another messaging infrastructure later.</span></span>

- <span data-ttu-id="41eb4-186">**延遲**。</span><span class="sxs-lookup"><span data-stu-id="41eb4-186">**Latency**.</span></span> <span data-ttu-id="41eb4-187">若訊息佇列已滿，作業的端對端延遲時間可能會變長。</span><span class="sxs-lookup"><span data-stu-id="41eb4-187">End-to-end latency for an operation may become high if the message queues fill up.</span></span>

- <span data-ttu-id="41eb4-188">**成本**。</span><span class="sxs-lookup"><span data-stu-id="41eb4-188">**Cost**.</span></span> <span data-ttu-id="41eb4-189">輸送量很高時，傳訊基礎結構的貨幣成本可能會非常高。</span><span class="sxs-lookup"><span data-stu-id="41eb4-189">At high throughputs, the monetary cost of the messaging infrastructure could be significant.</span></span>

- <span data-ttu-id="41eb4-190">**複雜度**。</span><span class="sxs-lookup"><span data-stu-id="41eb4-190">**Complexity**.</span></span> <span data-ttu-id="41eb4-191">處理非同步傳訊不是簡單的工作。</span><span class="sxs-lookup"><span data-stu-id="41eb4-191">Handling asynchronous messaging is not a trivial task.</span></span> <span data-ttu-id="41eb4-192">例如，您必須處理重複的訊息 (無論是透過刪除重複資料，或是讓作業具有等冪性)。</span><span class="sxs-lookup"><span data-stu-id="41eb4-192">For example, you must handle duplicated messages, either by de-duplicating or by making operations idempotent.</span></span> <span data-ttu-id="41eb4-193">此外，使用非同步傳訊也難以實作要求-回應語意。</span><span class="sxs-lookup"><span data-stu-id="41eb4-193">It's also hard to implement request-response semantics using asynchronous messaging.</span></span> <span data-ttu-id="41eb4-194">若要傳送回應，您不但需要其他佇列，還需要能夠使要求和回應訊息相互關聯的方法。</span><span class="sxs-lookup"><span data-stu-id="41eb4-194">To send a response, you need another queue, plus a way to correlate request and response messages.</span></span>

- <span data-ttu-id="41eb4-195">**輸送量**。</span><span class="sxs-lookup"><span data-stu-id="41eb4-195">**Throughput**.</span></span> <span data-ttu-id="41eb4-196">若訊息需要「佇列語意」，佇列可能會變成系統中的瓶頸。</span><span class="sxs-lookup"><span data-stu-id="41eb4-196">If messages require *queue semantics*, the queue can become a bottleneck in the system.</span></span> <span data-ttu-id="41eb4-197">每個訊息都需要至少一個佇列作業，以及一個清除佇列作業。</span><span class="sxs-lookup"><span data-stu-id="41eb4-197">Each message requires at least one queue operation and one dequeue operation.</span></span> <span data-ttu-id="41eb4-198">此外，在傳訊基礎結構內，佇列語意一般會需要某種鎖定機制。</span><span class="sxs-lookup"><span data-stu-id="41eb4-198">Moreover, queue semantics generally require some kind of locking inside the messaging infrastructure.</span></span> <span data-ttu-id="41eb4-199">如果佇列是受控服務，可能會有額外的延遲時間，因為佇列位在叢集的虛擬網路外部。</span><span class="sxs-lookup"><span data-stu-id="41eb4-199">If the queue is a managed service, there may be additional latency, because the queue is external to the cluster's virtual network.</span></span> <span data-ttu-id="41eb4-200">您可以批次處理訊息以減輕這些問題，但這會使程式碼變得很複雜。</span><span class="sxs-lookup"><span data-stu-id="41eb4-200">You can mitigate these issues by batching messages, but that complicates the code.</span></span> <span data-ttu-id="41eb4-201">若訊息不需要佇列語意，您也許可以使用 stream 事件來取代佇列。</span><span class="sxs-lookup"><span data-stu-id="41eb4-201">If the messages don't require queue semantics, you might be able to use an event *stream* instead of a queue.</span></span> <span data-ttu-id="41eb4-202">如需詳細資訊，請參閱[事件驅動架構樣式](../guide/architecture-styles/event-driven.md)。</span><span class="sxs-lookup"><span data-stu-id="41eb4-202">For more information, see [Event-driven architectural style](../guide/architecture-styles/event-driven.md).</span></span>

## <a name="drone-delivery-choosing-the-messaging-patterns"></a><span data-ttu-id="41eb4-203">無人機遞送：選擇傳訊模式</span><span class="sxs-lookup"><span data-stu-id="41eb4-203">Drone Delivery: Choosing the messaging patterns</span></span>

<span data-ttu-id="41eb4-204">考量上述事項後，開發小組針對無人機遞送應用程式的設計，做出下列選擇</span><span class="sxs-lookup"><span data-stu-id="41eb4-204">With these considerations in mind, the development team made the following design choices for the Drone Delivery application</span></span>

- <span data-ttu-id="41eb4-205">「擷取」服務會公開用戶端應用程式用來排程、更新或取消遞送的公用 REST API。</span><span class="sxs-lookup"><span data-stu-id="41eb4-205">The Ingestion service exposes a public REST API that client applications use to schedule, update, or cancel deliveries.</span></span>

- <span data-ttu-id="41eb4-206">「擷取」服務會使用事件中樞將非同步訊息傳送到「排程器」服務。</span><span class="sxs-lookup"><span data-stu-id="41eb4-206">The Ingestion service uses Event Hubs to send asynchronous messages to the Scheduler service.</span></span> <span data-ttu-id="41eb4-207">要實作擷取所需的負載調節，會需要非同步訊息。</span><span class="sxs-lookup"><span data-stu-id="41eb4-207">Asynchronous messages are necessary to implement the load-leveling that is required for ingestion.</span></span> <span data-ttu-id="41eb4-208">如需「擷取」和「排程器」服務的互動方式詳細資訊，請參閱[擷取與工作流程][ingestion-workflow]。</span><span class="sxs-lookup"><span data-stu-id="41eb4-208">For details on how the Ingestion and Scheduler services interact, see [Ingestion and workflow][ingestion-workflow].</span></span>

- <span data-ttu-id="41eb4-209">「帳戶」、「遞送」、「包裹」、「無人機」和「第三方運輸」服務全都會公開內部 REST API。</span><span class="sxs-lookup"><span data-stu-id="41eb4-209">The Account, Delivery, Package, Drone, and Third-party Transport services all expose internal REST APIs.</span></span> <span data-ttu-id="41eb4-210">「排程器」服務會呼叫上述 API 來執行使用者要求。</span><span class="sxs-lookup"><span data-stu-id="41eb4-210">The Scheduler service calls these APIs to carry out a user request.</span></span> <span data-ttu-id="41eb4-211">使用同步 API 的原因之一是「排程器」需要得到來自各下游服務的回應。</span><span class="sxs-lookup"><span data-stu-id="41eb4-211">One reason to use synchronous APIs is that the Scheduler needs to get a response from each of the downstream services.</span></span> <span data-ttu-id="41eb4-212">若任何一個下游服務失敗，即代表整個作業失敗。</span><span class="sxs-lookup"><span data-stu-id="41eb4-212">A failure in any of the downstream services means the entire operation failed.</span></span> <span data-ttu-id="41eb4-213">不過，潛在的問題是呼叫後端服務所造成的延遲時間。</span><span class="sxs-lookup"><span data-stu-id="41eb4-213">However, a potential issue is the amount of latency that is introduced by calling the backend services.</span></span>

- <span data-ttu-id="41eb4-214">若任何一個下游服務具有非暫時性的失敗，就應該將整個交易標示為失敗。</span><span class="sxs-lookup"><span data-stu-id="41eb4-214">If any downstream service has a non-transient failure, the entire transaction should be marked as failed.</span></span> <span data-ttu-id="41eb4-215">為了處理這種情況，「排程器」服務會將非同步訊息傳送給「監督員」，讓「監督員」可以排程補償交易，如[擷取與工作流程][ingestion-workflow]一章中所述。</span><span class="sxs-lookup"><span data-stu-id="41eb4-215">To handle this case, the Scheduler service sends an asynchronous message to the Supervisor, so that the Supervisor can schedule compensating transactions, as described in the chapter [Ingestion and workflow][ingestion-workflow].</span></span>

- <span data-ttu-id="41eb4-216">「遞送」服務會公開用戶端可用以取得遞送狀態的公用 API。</span><span class="sxs-lookup"><span data-stu-id="41eb4-216">The Delivery service exposes a public API that clients can use to get the status of a delivery.</span></span> <span data-ttu-id="41eb4-217">在 [API 閘道](./gateway.md)一章中，我們會討論 API 閘道如何對用戶端隱藏基礎服務，如此用戶端就不會知道哪些服務公開了哪些 API。</span><span class="sxs-lookup"><span data-stu-id="41eb4-217">In the chapter [API gateway](./gateway.md), we discuss how an API gateway can hide the underlying services from the client, so the client doesn't need to know which services expose which APIs.</span></span>

- <span data-ttu-id="41eb4-218">無人機在飛行的同時，「無人機」服務會傳送包含無人機目前位置和狀態的事件。</span><span class="sxs-lookup"><span data-stu-id="41eb4-218">While a drone is in flight, the Drone service sends events that contain the drone's current location and status.</span></span> <span data-ttu-id="41eb4-219">「遞送」服務會接聽這些事件，以便追蹤遞送狀態。</span><span class="sxs-lookup"><span data-stu-id="41eb4-219">The Delivery service listens to these events in order to track the status of a delivery.</span></span>

- <span data-ttu-id="41eb4-220">遞送狀態有所改變時，「遞送」服務會傳送遞送狀態事件 (例如 `DeliveryCreated` 或 `DeliveryCompleted`)。</span><span class="sxs-lookup"><span data-stu-id="41eb4-220">When the status of a delivery changes, the Delivery service sends a delivery status event, such as `DeliveryCreated` or `DeliveryCompleted`.</span></span> <span data-ttu-id="41eb4-221">任何服務都能訂閱這些事件。</span><span class="sxs-lookup"><span data-stu-id="41eb4-221">Any service can subscribe to these events.</span></span> <span data-ttu-id="41eb4-222">在目前的設計中，「遞送」服務是唯一的訂閱者，但稍後可能會有其他訂閱者。</span><span class="sxs-lookup"><span data-stu-id="41eb4-222">In the current design, the Delivery service is the only subscriber, but there might be other subscribers later.</span></span> <span data-ttu-id="41eb4-223">例如，系統可能會將事件傳送給即時分析服務。</span><span class="sxs-lookup"><span data-stu-id="41eb4-223">For example, the events might go to a real-time analytics service.</span></span> <span data-ttu-id="41eb4-224">而因為排程器無須等候回應，所以新增更多訂閱者並不會影響主要工作流程路徑。</span><span class="sxs-lookup"><span data-stu-id="41eb4-224">And because the Scheduler doesn't have to wait for a response, adding more subscribers doesn't affect the main workflow path.</span></span>

![無人機通訊圖](./images/drone-communication.png)

<span data-ttu-id="41eb4-226">請注意，遞送狀態事件是從無人機位置事件所衍生出來的。</span><span class="sxs-lookup"><span data-stu-id="41eb4-226">Notice that delivery status events are derived from drone location events.</span></span> <span data-ttu-id="41eb4-227">例如，無人機到達遞送位置並丟下包裹時，「遞送」服務會將此行為轉譯成 DeliveryCompleted 事件。</span><span class="sxs-lookup"><span data-stu-id="41eb4-227">For example, when a drone reaches a delivery location and drops off a package, the Delivery service translates this into a DeliveryCompleted event.</span></span> <span data-ttu-id="41eb4-228">這是以領域模型進行思考的範例。</span><span class="sxs-lookup"><span data-stu-id="41eb4-228">This is an example of thinking in terms of domain models.</span></span> <span data-ttu-id="41eb4-229">如先前所述，無人機管理屬於不同的限界內容。</span><span class="sxs-lookup"><span data-stu-id="41eb4-229">As described earlier, Drone Management belongs in a separate bounded context.</span></span> <span data-ttu-id="41eb4-230">無人機事件會傳達無人機的實體位置。</span><span class="sxs-lookup"><span data-stu-id="41eb4-230">The drone events convey the physical location of a drone.</span></span> <span data-ttu-id="41eb4-231">相反地，遞送事件則代表遞送狀態的改變，而這是不同的商務實體。</span><span class="sxs-lookup"><span data-stu-id="41eb4-231">The delivery events, on the other hand, represent changes in the status of a delivery, which is a different business entity.</span></span>

## <a name="using-a-service-mesh"></a><span data-ttu-id="41eb4-232">使用服務網格</span><span class="sxs-lookup"><span data-stu-id="41eb4-232">Using a service mesh</span></span>

<span data-ttu-id="41eb4-233">「服務網格」是種處理服務對服務通訊的軟體層。</span><span class="sxs-lookup"><span data-stu-id="41eb4-233">A *service mesh* is a software layer that handles service-to-service communication.</span></span> <span data-ttu-id="41eb4-234">服務網格旨在解決前一節中所列的許多疑慮，並將關於這些疑慮的責任從微服務本身移轉到共用層。</span><span class="sxs-lookup"><span data-stu-id="41eb4-234">Service meshes are designed to address many of the concerns listed in the previous section, and to move responsibility for these concerns away from the microservices themselves and into a shared layer.</span></span> <span data-ttu-id="41eb4-235">服務網格會扮演攔截叢集中微服務之間網路通訊的 Proxy 角色。</span><span class="sxs-lookup"><span data-stu-id="41eb4-235">The service mesh acts as a proxy that intercepts network communication between microservices in the cluster.</span></span>

> [!NOTE]
> <span data-ttu-id="41eb4-236">服務網格是[大使模式](../patterns/ambassador.md)的範例 &mdash; 這是種會代表應用程式傳送網路要求的協助程式服務。</span><span class="sxs-lookup"><span data-stu-id="41eb4-236">Service mesh is an example of the [Ambassador pattern](../patterns/ambassador.md) &mdash; a helper service that sends network requests on behalf of the application.</span></span>

<span data-ttu-id="41eb4-237">目前，Kubernetes 中服務網格的主要選項是 [linkerd](https://linkerd.io/) 和 [Istio](https://istio.io/)。</span><span class="sxs-lookup"><span data-stu-id="41eb4-237">Right now, the main options for a service mesh in Kubernetes are [linkerd](https://linkerd.io/) and [Istio](https://istio.io/).</span></span> <span data-ttu-id="41eb4-238">這兩種技術都在迅速發展中。</span><span class="sxs-lookup"><span data-stu-id="41eb4-238">Both of these technologies are evolving rapidly.</span></span> <span data-ttu-id="41eb4-239">不過，linkerd 和 Istio 所具有的共通功能包括：</span><span class="sxs-lookup"><span data-stu-id="41eb4-239">However, some features that both linkerd and Istio have in common include:</span></span>

- <span data-ttu-id="41eb4-240">根據觀察到的延遲時間或未處理的要求數目，在工作階段層級進行負載平衡。</span><span class="sxs-lookup"><span data-stu-id="41eb4-240">Load balancing at the session level, based on observed latencies or number of outstanding requests.</span></span> <span data-ttu-id="41eb4-241">這可以透過 Kubernetes 所提供的第 4 層負載平衡來改善效能。</span><span class="sxs-lookup"><span data-stu-id="41eb4-241">This can improve performance over the layer-4 load balancing that is provided by Kubernetes.</span></span>

- <span data-ttu-id="41eb4-242">會根據 URL 路徑、主機標題、API 版本或其他應用程式層級的規則，來進行第 7 層路由傳送。</span><span class="sxs-lookup"><span data-stu-id="41eb4-242">Layer-7 routing based on URL path, Host header, API version, or other application-level rules.</span></span>

- <span data-ttu-id="41eb4-243">重試失敗的要求。</span><span class="sxs-lookup"><span data-stu-id="41eb4-243">Retry of failed requests.</span></span> <span data-ttu-id="41eb4-244">服務網格了解 HTTP 錯誤碼，並可自動重試失敗的要求。</span><span class="sxs-lookup"><span data-stu-id="41eb4-244">A service mesh understands HTTP error codes, and can automatically retry failed requests.</span></span> <span data-ttu-id="41eb4-245">您可以設定重試次數上限以及逾時期限，以便繫結延遲上限。</span><span class="sxs-lookup"><span data-stu-id="41eb4-245">You can configure that maximum number of retries, along with a timeout period in order to bound the maximum latency.</span></span>

- <span data-ttu-id="41eb4-246">進行斷路。</span><span class="sxs-lookup"><span data-stu-id="41eb4-246">Circuit breaking.</span></span> <span data-ttu-id="41eb4-247">若執行個體的要求持續失敗，服務網格會暫時將其標示為停用。</span><span class="sxs-lookup"><span data-stu-id="41eb4-247">If an instance consistently fails requests, the service mesh will temporarily mark it as unavailable.</span></span> <span data-ttu-id="41eb4-248">輪詢期間過後，服務網格會重試執行個體。</span><span class="sxs-lookup"><span data-stu-id="41eb4-248">After a backoff period, it will try the instance again.</span></span> <span data-ttu-id="41eb4-249">您可以根據各種準則 (例如連續失敗次數) 來設定斷路器。</span><span class="sxs-lookup"><span data-stu-id="41eb4-249">You can configure the circuit breaker based on various criteria, such as the number of consecutive failures,</span></span>  

- <span data-ttu-id="41eb4-250">服務網格會擷取關於服務間呼叫的度量，例如要求量、延遲、錯誤和成功率，以及回應大小。</span><span class="sxs-lookup"><span data-stu-id="41eb4-250">Service mesh captures metrics about interservice calls, such as the request volume, latency, error and success rates, and response sizes.</span></span> <span data-ttu-id="41eb4-251">服務網格也可透過在要求中新增每個躍點的相互關聯資訊，來實現分散式追蹤。</span><span class="sxs-lookup"><span data-stu-id="41eb4-251">The service mesh also enables distributed tracing by adding correlation information for each hop in a request.</span></span>

- <span data-ttu-id="41eb4-252">針對服務對服務呼叫，進行相互 TLS 驗證。</span><span class="sxs-lookup"><span data-stu-id="41eb4-252">Mutual TLS Authentication for service-to-service calls.</span></span>

<span data-ttu-id="41eb4-253">您需要服務網格嗎？</span><span class="sxs-lookup"><span data-stu-id="41eb4-253">Do you need a service mesh?</span></span> <span data-ttu-id="41eb4-254">網狀網格能為分散式系統帶來的附加價值肯定很吸引人。</span><span class="sxs-lookup"><span data-stu-id="41eb4-254">The value they add to a distributed system is certainly compelling.</span></span> <span data-ttu-id="41eb4-255">若您沒有服務網格，就需要考量本章開頭所提到的各項挑戰。</span><span class="sxs-lookup"><span data-stu-id="41eb4-255">If you don't have a service mesh, you will need to consider each of the challenges mentioned at the beginning of the chapter.</span></span> <span data-ttu-id="41eb4-256">就算沒有服務網格，仍可解決重試、斷路器和分散式追蹤之類的問題；但服務網格可將這些疑慮從個別服務移轉到專用層級中。</span><span class="sxs-lookup"><span data-stu-id="41eb4-256">You can solve problems like retry, circuit breaker, and distributed tracing without a service mesh, but a service mesh moves these concerns out of the individual services and into a dedicated layer.</span></span> <span data-ttu-id="41eb4-257">另一方面，服務網格仍是尚未完全成熟而相對較新的技術。</span><span class="sxs-lookup"><span data-stu-id="41eb4-257">On the other hand, service meshes are a relatively new technology that is still maturing.</span></span> <span data-ttu-id="41eb4-258">要部署服務網格會使設定和配置叢集更加複雜。</span><span class="sxs-lookup"><span data-stu-id="41eb4-258">Deploying a service mesh adds complexity to the setup and configuration of the cluster.</span></span> <span data-ttu-id="41eb4-259">由於系統現在會透過服務網格 Proxy 來路由傳送要求，而且現在叢集中的每個節點上都有額外的服務在執行，因此這可能會對效能造成影響。</span><span class="sxs-lookup"><span data-stu-id="41eb4-259">There may be performance implications, because requests now get routed through the service mesh proxy, and because extra services are now running on every node in the cluster.</span></span> <span data-ttu-id="41eb4-260">在生產環境中部署服務網格之前，您應該先徹底測試效能和負載。</span><span class="sxs-lookup"><span data-stu-id="41eb4-260">You should do thorough performance and load testing before deploying a service mesh in production.</span></span>

> [!div class="nextstepaction"]
> [<span data-ttu-id="41eb4-261">API 設計</span><span class="sxs-lookup"><span data-stu-id="41eb4-261">API design</span></span>](./api-design.md)

<!-- links -->

[ingestion-workflow]: ./ingestion-workflow.md
