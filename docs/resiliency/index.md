---
title: "為 Azure 設計復原應用程式"
description: "如何在 Azure 中建置復原應用程式，如高可用性和災害復原。"
author: MikeWasson
ms.date: 05/26/2017
ms.custom: resiliency
pnp.series.title: Design for Resiliency
ms.openlocfilehash: 31a685e46da02fb59d93a210e6f14da5c68331de
ms.sourcegitcommit: b0482d49aab0526be386837702e7724c61232c60
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/14/2017
---
# <a name="designing-resilient-applications-for-azure"></a><span data-ttu-id="ce247-103">為 Azure 設計復原應用程式</span><span class="sxs-lookup"><span data-stu-id="ce247-103">Designing resilient applications for Azure</span></span>

<span data-ttu-id="ce247-104">在分散式系統中，將會發生失敗。</span><span class="sxs-lookup"><span data-stu-id="ce247-104">In a distributed system, failures will happen.</span></span> <span data-ttu-id="ce247-105">硬體可能會失敗。</span><span class="sxs-lookup"><span data-stu-id="ce247-105">Hardware can fail.</span></span> <span data-ttu-id="ce247-106">網路可能會暫時性失敗。</span><span class="sxs-lookup"><span data-stu-id="ce247-106">The network can have transient failures.</span></span> <span data-ttu-id="ce247-107">整個服務或區域很少會發生中斷，但即使如此仍必須加以規劃。</span><span class="sxs-lookup"><span data-stu-id="ce247-107">Rarely, an entire service or region may experience a disruption, but even those must be planned for.</span></span> 

<span data-ttu-id="ce247-108">在雲端中建立可靠的應用程式不同於在企業設定中建置可靠的應用程式。</span><span class="sxs-lookup"><span data-stu-id="ce247-108">Building a reliable application in the cloud is different than building a reliable application in an enterprise setting.</span></span> <span data-ttu-id="ce247-109">儘管您在過去可能已購買更高階的硬體來相應增加，但在雲端環境中，您必須相應放大而不是相應增加。</span><span class="sxs-lookup"><span data-stu-id="ce247-109">While historically you may have purchased higher-end hardware to scale up, in a cloud environment you must scale out instead of scaling up.</span></span> <span data-ttu-id="ce247-110">透過使用商用硬體，可將雲端環境維持在較低的成本。</span><span class="sxs-lookup"><span data-stu-id="ce247-110">Costs for cloud environments are kept low through the use of commodity hardware.</span></span> <span data-ttu-id="ce247-111">這個新環境並非將焦點放在預防故障以及最佳化「失敗之間的平均時間」，而是將焦點轉移到「還原的平均時間」。</span><span class="sxs-lookup"><span data-stu-id="ce247-111">Instead of focusing on preventing failures and optimizing "mean time between failures," in this new environment the focus shifts to "mean time to restore."</span></span> <span data-ttu-id="ce247-112">目標是將失敗的影響降至最低。</span><span class="sxs-lookup"><span data-stu-id="ce247-112">The goal is to minimize the effect of a failure.</span></span>

<span data-ttu-id="ce247-113">本文提供的概觀說明如何在 Microsoft Azure 中建置復原應用程式。</span><span class="sxs-lookup"><span data-stu-id="ce247-113">This article provides an overview of how to build resilient applications in Microsoft Azure.</span></span> <span data-ttu-id="ce247-114">開頭會說明復原這個字詞的定義和相關的概念。</span><span class="sxs-lookup"><span data-stu-id="ce247-114">It starts with a definition of the term *resiliency* and related concepts.</span></span> <span data-ttu-id="ce247-115">然後它會描述在應用程式存留期間使用結構化的方法達成復原的流程，從設計和實作到部署和作業。</span><span class="sxs-lookup"><span data-stu-id="ce247-115">Then it describes a process for achieving resiliency, using a structured approach over the lifetime of an application, from design and implementation to deployment and operations.</span></span>

## <a name="what-is-resiliency"></a><span data-ttu-id="ce247-116">復原是什麼？</span><span class="sxs-lookup"><span data-stu-id="ce247-116">What is resiliency?</span></span>
<span data-ttu-id="ce247-117">**復原**是系統從失敗中復原並繼續運作的能力。</span><span class="sxs-lookup"><span data-stu-id="ce247-117">**Resiliency** is the ability of a system to recover from failures and continue to function.</span></span> <span data-ttu-id="ce247-118">它不是避免失敗，而是以避免停機或資料遺失的方式來回應失敗。</span><span class="sxs-lookup"><span data-stu-id="ce247-118">It's not about *avoiding* failures, but *responding* to failures in a way that avoids downtime or data loss.</span></span> <span data-ttu-id="ce247-119">復原的目標是讓應用程式在失敗後完全回到正常運作的狀態。</span><span class="sxs-lookup"><span data-stu-id="ce247-119">The goal of resiliency is to return the application to a fully functioning state following a failure.</span></span>

<span data-ttu-id="ce247-120">復原的兩個重要層面是高可用性和災害復原。</span><span class="sxs-lookup"><span data-stu-id="ce247-120">Two important aspects of resiliency are high availability and disaster recovery.</span></span>

* <span data-ttu-id="ce247-121">**高可用性** (HA)：可讓應用程式繼續在狀況良好狀態下執行，而不需要長期停機。</span><span class="sxs-lookup"><span data-stu-id="ce247-121">**High availability** (HA) is the ability of the application to continue running in a healthy state, without significant downtime.</span></span> <span data-ttu-id="ce247-122">「狀況良好狀態」是指應用程式有回應，而且使用者可以連線到應用程式並與其互動。</span><span class="sxs-lookup"><span data-stu-id="ce247-122">By "healthy state," we mean the application is responsive, and users can connect to the application and interact with it.</span></span>  
* <span data-ttu-id="ce247-123">**災害復原** (DR) 是從罕見但重大的事件中復原的能力，這些事件是非暫時性且規模廣泛的失敗，例如影響整個區域的服務中斷。</span><span class="sxs-lookup"><span data-stu-id="ce247-123">**Disaster recovery** (DR) is the ability to recover from rare but major incidents: non-transient, wide-scale failures, such as service disruption that affects an entire region.</span></span> <span data-ttu-id="ce247-124">災害復原包括資料備份和封存，而且可能包括手動操作，例如從備份中還原資料庫。</span><span class="sxs-lookup"><span data-stu-id="ce247-124">Disaster recovery includes data backup and archiving, and may include manual intervention, such as restoring a database from backup.</span></span> 

<span data-ttu-id="ce247-125">思考 HA 與 DR 的方法之一，是當錯誤的影響超過 HA 設計可處理錯誤的能力時即啟動 DR。</span><span class="sxs-lookup"><span data-stu-id="ce247-125">One way to think about HA versus DR is that DR starts when the impact of a fault exceeds the ability of the HA design to handle it.</span></span> <span data-ttu-id="ce247-126">例如，將數個負載平衡器放在 VM 後方，會在一個 VM 失敗時提供可用性，但如果它們都在相同的時間失敗，就無法提供可用性。</span><span class="sxs-lookup"><span data-stu-id="ce247-126">For example, putting several VMs behind a load balancer will provide availability if one VM fails, but not if they all fail at the same time.</span></span> 

<span data-ttu-id="ce247-127">當您將應用程式設計為具有復原功能時，必須了解您的可用性要求。</span><span class="sxs-lookup"><span data-stu-id="ce247-127">When you design an application to be resilient, you have to understand your availability requirements.</span></span> <span data-ttu-id="ce247-128">可接受多少停機時間？</span><span class="sxs-lookup"><span data-stu-id="ce247-128">How much downtime is acceptable?</span></span> <span data-ttu-id="ce247-129">這是有一部分是成本的功能。</span><span class="sxs-lookup"><span data-stu-id="ce247-129">This is partly a function of cost.</span></span> <span data-ttu-id="ce247-130">可能的停機時間會造成多少業務成本？</span><span class="sxs-lookup"><span data-stu-id="ce247-130">How much will potential downtime cost your business?</span></span> <span data-ttu-id="ce247-131">您應該將多少成本投資於此應用程式的高可用性？</span><span class="sxs-lookup"><span data-stu-id="ce247-131">How much should you invest in making the application highly available?</span></span> <span data-ttu-id="ce247-132">您也必須定義應用程式可用的意義。</span><span class="sxs-lookup"><span data-stu-id="ce247-132">You also have to define what it means for the application to be available.</span></span> <span data-ttu-id="ce247-133">例如，如果客戶可以提交訂單，但系統無法在一般時間範圍內處理，則應用程式是否為「停機」？</span><span class="sxs-lookup"><span data-stu-id="ce247-133">For example, is the application "down" if a customer can submit an order but the system cannot process it within the normal timeframe?</span></span> <span data-ttu-id="ce247-134">也請考慮特定類型中斷的發生機率，以及因應措施是否符合成本效益。</span><span class="sxs-lookup"><span data-stu-id="ce247-134">Also consider the probability of a particular type of outage occurring, and whether a mitigation strategy is cost-effective.</span></span>

<span data-ttu-id="ce247-135">另一個常見的字詞是**業務續航力** (BC)，這是指在不利的狀況 (例如天然災害或服務暫停) 期間和之後，執行重要商務功能的能力。</span><span class="sxs-lookup"><span data-stu-id="ce247-135">Another common term is **business continuity** (BC), which is the ability to perform essential business functions during and after adverse conditions, such as a natural disaster or a downed service.</span></span> <span data-ttu-id="ce247-136">BC 涵蓋整個企業的作業，包括實體設備、人員、通訊、運輸和 IT。</span><span class="sxs-lookup"><span data-stu-id="ce247-136">BC covers the entire operation of the business, including physical facilities, people, communications, transportation, and IT.</span></span> <span data-ttu-id="ce247-137">本文著重於雲端應用程式，但必須在整體 BC 需求的內容中完成復原規劃。</span><span class="sxs-lookup"><span data-stu-id="ce247-137">This article focuses on cloud applications, but resilience planning must be done in the context of overall BC requirements.</span></span> <span data-ttu-id="ce247-138">如需詳細資訊，請參閱 National Institute of Science and Technology (NIST) 提供的 [應變計劃指南][capacity-planning-guide]。</span><span class="sxs-lookup"><span data-stu-id="ce247-138">For more information, see the [Contingency Planning Guide][capacity-planning-guide] from the National Institute of Science and Technology (NIST).</span></span>

## <a name="process-to-achieve-resiliency"></a><span data-ttu-id="ce247-139">要達到復原的程序</span><span class="sxs-lookup"><span data-stu-id="ce247-139">Process to achieve resiliency</span></span>
<span data-ttu-id="ce247-140">復原並非附加元件。</span><span class="sxs-lookup"><span data-stu-id="ce247-140">Resiliency is not an add-on.</span></span> <span data-ttu-id="ce247-141">它必須設計到系統並放入作業做法。</span><span class="sxs-lookup"><span data-stu-id="ce247-141">It must be designed into the system and put into operational practice.</span></span> <span data-ttu-id="ce247-142">以下是需遵循的一般模型：</span><span class="sxs-lookup"><span data-stu-id="ce247-142">Here is a general model to follow:</span></span>

1. <span data-ttu-id="ce247-143">以商務需求作為基礎，**定義**程式的可用性需求。</span><span class="sxs-lookup"><span data-stu-id="ce247-143">**Define** your availability requirements, based on business needs.</span></span>
2. <span data-ttu-id="ce247-144">針對復原**設計**應用程式。</span><span class="sxs-lookup"><span data-stu-id="ce247-144">**Design** the application for resiliency.</span></span> <span data-ttu-id="ce247-145">從遵循經過證實之做法的架構開始，然後在該架構中找出可能的失敗點。</span><span class="sxs-lookup"><span data-stu-id="ce247-145">Start with an architecture that follows proven practices, and then identify the possible failure points in that architecture.</span></span>
3. <span data-ttu-id="ce247-146">**實作**策略來偵測失敗並從中復原。</span><span class="sxs-lookup"><span data-stu-id="ce247-146">**Implement** strategies to detect and recover from failures.</span></span> 
4. <span data-ttu-id="ce247-147">**測試**實作，方法是模擬錯誤及觸發強制容錯移轉。</span><span class="sxs-lookup"><span data-stu-id="ce247-147">**Test** the implementation by simulating faults and triggering forced failovers.</span></span> 
5. <span data-ttu-id="ce247-148">使用可靠的可重複執行程序，將應用程式**部署**到生產環境內。</span><span class="sxs-lookup"><span data-stu-id="ce247-148">**Deploy** the application into production using a reliable, repeatable process.</span></span> 
6. <span data-ttu-id="ce247-149">**監視**應用程式來偵測失敗。</span><span class="sxs-lookup"><span data-stu-id="ce247-149">**Monitor** the application to detect failures.</span></span> <span data-ttu-id="ce247-150">您可以藉由監視系統來評估應用程式的健康情況，並視需要回應事件。</span><span class="sxs-lookup"><span data-stu-id="ce247-150">By monitoring the system, you can gauge the health of the application and respond to incidents if necessary.</span></span> 
7. <span data-ttu-id="ce247-151">如果有需要手動介入的事件就**回應**。</span><span class="sxs-lookup"><span data-stu-id="ce247-151">**Respond** if there are incidents that require manual interventions.</span></span>

<span data-ttu-id="ce247-152">本文的其餘部分中，我們會深入討論每個步驟。</span><span class="sxs-lookup"><span data-stu-id="ce247-152">In the remainder of this article, we discuss each of these steps in more detail.</span></span>

## <a name="defining-your-resiliency-requirements"></a><span data-ttu-id="ce247-153">定義您的復原需求</span><span class="sxs-lookup"><span data-stu-id="ce247-153">Defining your resiliency requirements</span></span>
<span data-ttu-id="ce247-154">復原計劃會從商業需求開始。</span><span class="sxs-lookup"><span data-stu-id="ce247-154">Resiliency planning starts with business requirements.</span></span> <span data-ttu-id="ce247-155">以下是在這些字詞中思考復原的一些方法。</span><span class="sxs-lookup"><span data-stu-id="ce247-155">Here are some approaches for thinking about resiliency in those terms.</span></span>

### <a name="decompose-by-workload"></a><span data-ttu-id="ce247-156">依工作負載分解</span><span class="sxs-lookup"><span data-stu-id="ce247-156">Decompose by workload</span></span>
<span data-ttu-id="ce247-157">許多雲端解決方案包含多個應用程式工作負載。</span><span class="sxs-lookup"><span data-stu-id="ce247-157">Many cloud solutions consist of multiple application workloads.</span></span> <span data-ttu-id="ce247-158">「工作負載」一詞在此內容中是指不連續的功能或計算工作，可根據商務邏輯和資料儲存體需求，以邏輯方式與其他工作區隔。</span><span class="sxs-lookup"><span data-stu-id="ce247-158">The term "workload" in this context means a discrete capability or computing task, which can be logically separated from other tasks, in terms of business logic and data storage requirements.</span></span> <span data-ttu-id="ce247-159">例如，電子商務應用程式可能會包含下列工作負載：</span><span class="sxs-lookup"><span data-stu-id="ce247-159">For example, an e-commerce app might include the following workloads:</span></span>

* <span data-ttu-id="ce247-160">瀏覽及搜尋產品類別目錄。</span><span class="sxs-lookup"><span data-stu-id="ce247-160">Browse and search a product catalog.</span></span>
* <span data-ttu-id="ce247-161">建立並追蹤訂單。</span><span class="sxs-lookup"><span data-stu-id="ce247-161">Create and track orders.</span></span>
* <span data-ttu-id="ce247-162">檢視建議。</span><span class="sxs-lookup"><span data-stu-id="ce247-162">View recommendations.</span></span>

<span data-ttu-id="ce247-163">這些工作負載在可用性、延展性、資料一致性、災害復原等方面，可能有不同的需求。</span><span class="sxs-lookup"><span data-stu-id="ce247-163">These workloads might have different requirements for availability, scalability, data consistency, disaster recovery, and so forth.</span></span> <span data-ttu-id="ce247-164">同樣地，這些是業務決策。</span><span class="sxs-lookup"><span data-stu-id="ce247-164">Again, these are business decisions.</span></span>

<span data-ttu-id="ce247-165">也請考慮使用方式模式。</span><span class="sxs-lookup"><span data-stu-id="ce247-165">Also consider usage patterns.</span></span> <span data-ttu-id="ce247-166">必須使用系統時，是否有某些重要的期間？</span><span class="sxs-lookup"><span data-stu-id="ce247-166">Are there certain critical periods when the system must be available?</span></span> <span data-ttu-id="ce247-167">例如，報稅服務不能在歸檔期限前當機，影片串流服務在大型運動賽事期間必須維持運作等等。</span><span class="sxs-lookup"><span data-stu-id="ce247-167">For example, a tax-filing service can't go down right before the filing deadline, a video streaming service must stay up during a big sports event, and so on.</span></span> <span data-ttu-id="ce247-168">在重要的期間，您可能會在數個區域有備援部署，所以如果一個區域失敗，應用程式可能就無法容錯移轉。</span><span class="sxs-lookup"><span data-stu-id="ce247-168">During the critical periods, you might have redundant deployments across several regions, so the application could fail over if one region failed.</span></span> <span data-ttu-id="ce247-169">不過，多區域部署較昂貴，因此在較不重要的時間，您可以在單一區域中執行應用程式。</span><span class="sxs-lookup"><span data-stu-id="ce247-169">However, a multi-region deployment is more expensive, so during less critical times, you might run the application in a single region.</span></span>

### <a name="rto-and-rpo"></a><span data-ttu-id="ce247-170">RTO 和 RPO</span><span class="sxs-lookup"><span data-stu-id="ce247-170">RTO and RPO</span></span>
<span data-ttu-id="ce247-171">所需考慮的兩個重要指標是復原時間目標和復原點目標。</span><span class="sxs-lookup"><span data-stu-id="ce247-171">Two important metrics to consider are the recovery time objective and recovery point objective.</span></span>

* <span data-ttu-id="ce247-172">**復原時間目標** (RTO) 是應用程式在事件之後可能無法使用的最大可接受時間。</span><span class="sxs-lookup"><span data-stu-id="ce247-172">**Recovery time objective** (RTO) is the maximum acceptable time that an application can be unavailable after an incident.</span></span> <span data-ttu-id="ce247-173">如果您的 RTO 為 90 分鐘，就必須能夠在災害開始的 90 分鐘內，將應用程式還原為執行狀態。</span><span class="sxs-lookup"><span data-stu-id="ce247-173">If your RTO is 90 minutes, you must be able to restore the application to a running state within 90 minutes from the start of a disaster.</span></span> <span data-ttu-id="ce247-174">如果您的 RTO 非常低，就可以保留第二個部署持續以待命狀態執行，從而防止區域性中斷。</span><span class="sxs-lookup"><span data-stu-id="ce247-174">If you have a very low RTO, you might keep a second deployment continually running on standby, to protect against a regional outage.</span></span>
* <span data-ttu-id="ce247-175">**復原點目標** (RPO) 是在災害期間可接受的最大資料遺失時間長度。</span><span class="sxs-lookup"><span data-stu-id="ce247-175">**Recovery point objective** (RPO) is the maximum duration of data loss that is acceptable during a disaster.</span></span> <span data-ttu-id="ce247-176">例如，如果您在單一資料庫中儲存資料，沒有複寫到其他資料庫，且每小時執行備份，可能會遺失最多一個小時的資料。</span><span class="sxs-lookup"><span data-stu-id="ce247-176">For example, if you store data in a single database, with no replication to other databases, and perform hourly backups, you could lose up to an hour of data.</span></span> 

<span data-ttu-id="ce247-177">RTO 和 RPO 是商務需求。</span><span class="sxs-lookup"><span data-stu-id="ce247-177">RTO and RPO are business requirements.</span></span> <span data-ttu-id="ce247-178">進行風險評量有助於定義應用程式的 RTO 和 RPO。</span><span class="sxs-lookup"><span data-stu-id="ce247-178">Conducting a risk assessment can help you define the application's RTO and RPO.</span></span> <span data-ttu-id="ce247-179">另一個常見的計量是**平均復原時間** (MTTR)，這是在失敗後還原應用程式所花費的平均時間。</span><span class="sxs-lookup"><span data-stu-id="ce247-179">Another common metric is **mean time to recover** (MTTR), which is the average time that it takes to restore the application after a failure.</span></span> <span data-ttu-id="ce247-180">MTTR 是有關系統的經驗事實。</span><span class="sxs-lookup"><span data-stu-id="ce247-180">MTTR is an empirical fact about a system.</span></span> <span data-ttu-id="ce247-181">如果 MTTR 超過 RTO，系統失敗就會導致無法接受的商務中斷，因為將無法在定義的 RTO 內還原系統。</span><span class="sxs-lookup"><span data-stu-id="ce247-181">If MTTR exceeds the RTO, then a failure in the system will cause an unacceptable business disruption, because it won't be possible to restore the system within the defined RTO.</span></span> 

### <a name="slas"></a><span data-ttu-id="ce247-182">SLA</span><span class="sxs-lookup"><span data-stu-id="ce247-182">SLAs</span></span>
<span data-ttu-id="ce247-183">在 Azure 中，[服務等級協定][sla] (SLA) 描述 Microsoft 對執行時間與連線能力的承諾。</span><span class="sxs-lookup"><span data-stu-id="ce247-183">In Azure, the [Service Level Agreement][sla] (SLA) describes Microsoft’s commitments for uptime and connectivity.</span></span> <span data-ttu-id="ce247-184">如果特定服務的 SLA 是 99.9%，表示您應該預期 99.9% 的時間皆可提供服務。</span><span class="sxs-lookup"><span data-stu-id="ce247-184">If the SLA for a particular service is 99.9%, it means you should expect the service to be available 99.9% of the time.</span></span>

> [!NOTE]
> <span data-ttu-id="ce247-185">如果不符合 SLA，Azure SLA 也包括取得服務退費的佈建，以及每個服務的明確定義「可用性」。</span><span class="sxs-lookup"><span data-stu-id="ce247-185">The Azure SLA also includes provisions for obtaining a service credit if the SLA is not met, along with specific definitions of "availability" for each service.</span></span> <span data-ttu-id="ce247-186">SLA 的這個部分會作為強制執行原則。</span><span class="sxs-lookup"><span data-stu-id="ce247-186">That aspect of the SLA acts as an enforcement policy.</span></span> 
> 
> 

<span data-ttu-id="ce247-187">您應該在解決方案中針對每個工作負載定義自己的目標 SLA。</span><span class="sxs-lookup"><span data-stu-id="ce247-187">You should define your own target SLAs for each workload in your solution.</span></span> <span data-ttu-id="ce247-188">SLA 可讓您評估架構是否符合商務需求。</span><span class="sxs-lookup"><span data-stu-id="ce247-188">An SLA makes it possible to evaluate whether the architecture meets the business requirements.</span></span> <span data-ttu-id="ce247-189">例如，如果工作負載需要 99.99% 的執行時間，但需根據具有 99.9 % SLA 的服務而定，該服務就不能是系統中的單點失敗。</span><span class="sxs-lookup"><span data-stu-id="ce247-189">For example, if a workload requires 99.99% uptime, but depends on a service with a 99.9% SLA, that service cannot be a single-point of failure in the system.</span></span> <span data-ttu-id="ce247-190">萬一服務失敗時，一個補救是指一個後援的路徑，或採取其他措施從該服務的失敗中復原。</span><span class="sxs-lookup"><span data-stu-id="ce247-190">One remedy is to have a fallback path in case the service fails, or take other measures to recover from a failure in that service.</span></span> 

<span data-ttu-id="ce247-191">下表顯示各種 SLA 層級的潛在累計停機時間。</span><span class="sxs-lookup"><span data-stu-id="ce247-191">The following table shows the potential cumulative downtime for various SLA levels.</span></span> 

| <span data-ttu-id="ce247-192">SLA</span><span class="sxs-lookup"><span data-stu-id="ce247-192">SLA</span></span> | <span data-ttu-id="ce247-193">每週停機時間</span><span class="sxs-lookup"><span data-stu-id="ce247-193">Downtime per week</span></span> | <span data-ttu-id="ce247-194">每月停機時間</span><span class="sxs-lookup"><span data-stu-id="ce247-194">Downtime per month</span></span> | <span data-ttu-id="ce247-195">每年停機時間</span><span class="sxs-lookup"><span data-stu-id="ce247-195">Downtime per year</span></span> |
| --- | --- | --- | --- |
| <span data-ttu-id="ce247-196">99%</span><span class="sxs-lookup"><span data-stu-id="ce247-196">99%</span></span> |<span data-ttu-id="ce247-197">1.68 小時</span><span class="sxs-lookup"><span data-stu-id="ce247-197">1.68 hours</span></span> |<span data-ttu-id="ce247-198">7.2 小時</span><span class="sxs-lookup"><span data-stu-id="ce247-198">7.2 hours</span></span> |<span data-ttu-id="ce247-199">3.65 天</span><span class="sxs-lookup"><span data-stu-id="ce247-199">3.65 days</span></span> |
| <span data-ttu-id="ce247-200">99.9%</span><span class="sxs-lookup"><span data-stu-id="ce247-200">99.9%</span></span> |<span data-ttu-id="ce247-201">10.1 分鐘</span><span class="sxs-lookup"><span data-stu-id="ce247-201">10.1 minutes</span></span> |<span data-ttu-id="ce247-202">43.2 分鐘</span><span class="sxs-lookup"><span data-stu-id="ce247-202">43.2 minutes</span></span> |<span data-ttu-id="ce247-203">8.76 小時</span><span class="sxs-lookup"><span data-stu-id="ce247-203">8.76 hours</span></span> |
| <span data-ttu-id="ce247-204">99.95%</span><span class="sxs-lookup"><span data-stu-id="ce247-204">99.95%</span></span> |<span data-ttu-id="ce247-205">5 分鐘</span><span class="sxs-lookup"><span data-stu-id="ce247-205">5 minutes</span></span> |<span data-ttu-id="ce247-206">21.6 分鐘</span><span class="sxs-lookup"><span data-stu-id="ce247-206">21.6 minutes</span></span> |<span data-ttu-id="ce247-207">4.38 小時</span><span class="sxs-lookup"><span data-stu-id="ce247-207">4.38 hours</span></span> |
| <span data-ttu-id="ce247-208">99.99%</span><span class="sxs-lookup"><span data-stu-id="ce247-208">99.99%</span></span> |<span data-ttu-id="ce247-209">1.01 分鐘</span><span class="sxs-lookup"><span data-stu-id="ce247-209">1.01 minutes</span></span> |<span data-ttu-id="ce247-210">4.32 分鐘</span><span class="sxs-lookup"><span data-stu-id="ce247-210">4.32 minutes</span></span> |<span data-ttu-id="ce247-211">52.56 分鐘</span><span class="sxs-lookup"><span data-stu-id="ce247-211">52.56 minutes</span></span> |
| <span data-ttu-id="ce247-212">99.999%</span><span class="sxs-lookup"><span data-stu-id="ce247-212">99.999%</span></span> |<span data-ttu-id="ce247-213">6 秒</span><span class="sxs-lookup"><span data-stu-id="ce247-213">6 seconds</span></span> |<span data-ttu-id="ce247-214">25.9 秒</span><span class="sxs-lookup"><span data-stu-id="ce247-214">25.9 seconds</span></span> |<span data-ttu-id="ce247-215">5.26 分鐘</span><span class="sxs-lookup"><span data-stu-id="ce247-215">5.26 minutes</span></span> |

<span data-ttu-id="ce247-216">當然，可用性越高越好，其他所有項目則相同。</span><span class="sxs-lookup"><span data-stu-id="ce247-216">Of course, higher availability is better, everything else being equal.</span></span> <span data-ttu-id="ce247-217">但是，隨著您尋求更多的 9，達到該可用性層級的成本與複雜性也會隨之提高。</span><span class="sxs-lookup"><span data-stu-id="ce247-217">But as you strive for more 9s, the cost and complexity to achieve that level of availability grows.</span></span> <span data-ttu-id="ce247-218">99.99% 的執行時間相當於每個月的總停機時間約 5 分鐘。</span><span class="sxs-lookup"><span data-stu-id="ce247-218">An uptime of 99.99% translates to about 5 minutes of total downtime per month.</span></span> <span data-ttu-id="ce247-219">是否值得額外的複雜性和成本來達到五個 9？</span><span class="sxs-lookup"><span data-stu-id="ce247-219">Is it worth the additional complexity and cost to reach five 9s?</span></span> <span data-ttu-id="ce247-220">答案需視商務需求而定。</span><span class="sxs-lookup"><span data-stu-id="ce247-220">The answer depends on the business requirements.</span></span> 

<span data-ttu-id="ce247-221">以下是定義 SLA 時的一些其他考量：</span><span class="sxs-lookup"><span data-stu-id="ce247-221">Here are some other considerations when defining an SLA:</span></span>

* <span data-ttu-id="ce247-222">若要達到四個 9 (99.99%)，您可能無法依賴手動介入來從失敗中復原。</span><span class="sxs-lookup"><span data-stu-id="ce247-222">To achieve four 9's (99.99%), you probably can't rely on manual intervention to recover from failures.</span></span> <span data-ttu-id="ce247-223">應用程式必須是自我診斷及自我修復。</span><span class="sxs-lookup"><span data-stu-id="ce247-223">The application must be self-diagnosing and self-healing.</span></span> 
* <span data-ttu-id="ce247-224">超過四個 9 時，就不容易以夠快的速度偵測到中斷狀況來符合 SLA。</span><span class="sxs-lookup"><span data-stu-id="ce247-224">Beyond four 9's, it is challenging to detect outages quickly enough to meet the SLA.</span></span>
* <span data-ttu-id="ce247-225">請思考您 SLA 測量根據的時間間隔。</span><span class="sxs-lookup"><span data-stu-id="ce247-225">Think about the time window that your SLA is measured against.</span></span> <span data-ttu-id="ce247-226">間隔越小，容錯度就更緊密。</span><span class="sxs-lookup"><span data-stu-id="ce247-226">The smaller the window, the tighter the tolerances.</span></span> <span data-ttu-id="ce247-227">根據每小時或每日執行時間來定義 SLA 可能沒有意義。</span><span class="sxs-lookup"><span data-stu-id="ce247-227">It probably doesn't make sense to define your SLA in terms of hourly or daily uptime.</span></span> 

### <a name="composite-slas"></a><span data-ttu-id="ce247-228">複合 SLA</span><span class="sxs-lookup"><span data-stu-id="ce247-228">Composite SLAs</span></span>
<span data-ttu-id="ce247-229">請考慮將寫入 Azure SQL Database 中的 App Service web 應用程式。</span><span class="sxs-lookup"><span data-stu-id="ce247-229">Consider an App Service web app that writes to Azure SQL Database.</span></span> <span data-ttu-id="ce247-230">在撰寫本文時，這些 Azure 服務都有下列 SLA：</span><span class="sxs-lookup"><span data-stu-id="ce247-230">At the time of this writing, these Azure services have the following SLAs:</span></span>

* <span data-ttu-id="ce247-231">App Service Web Apps = 99.95%</span><span class="sxs-lookup"><span data-stu-id="ce247-231">App Service Web Apps = 99.95%</span></span>
* <span data-ttu-id="ce247-232">SQL Database = 99.99%</span><span class="sxs-lookup"><span data-stu-id="ce247-232">SQL Database = 99.99%</span></span>

![複合 SLA](./images/sla1.png)

<span data-ttu-id="ce247-234">您預期這個應用程式的停機時間最長是多久？</span><span class="sxs-lookup"><span data-stu-id="ce247-234">What is the maximum downtime you would expect for this application?</span></span> <span data-ttu-id="ce247-235">如果其中一項服務失敗，整個應用程式就會失敗。</span><span class="sxs-lookup"><span data-stu-id="ce247-235">If either service fails, the whole application fails.</span></span> <span data-ttu-id="ce247-236">一般情況下，每個服務的失敗機率互相無關，所以這個應用程式的複合 SLA 是 99.95% &times; 99.99% = 99.94%。</span><span class="sxs-lookup"><span data-stu-id="ce247-236">In general, the probability of each service failing is independent, so the composite SLA for this application is 99.95% &times; 99.99% = 99.94%.</span></span> <span data-ttu-id="ce247-237">這低於個別的 SLA，但並不令人意外，因為仰賴多個服務的應用程式會有多個可能的失敗點。</span><span class="sxs-lookup"><span data-stu-id="ce247-237">That's lower than the individual SLAs, which isn't surprising, because an application that relies on multiple services has more potential failure points.</span></span> 

<span data-ttu-id="ce247-238">另一方面，您可以藉由建立獨立的後援路徑來改善複合 SLA。</span><span class="sxs-lookup"><span data-stu-id="ce247-238">On the other hand, you can improve the composite SLA by creating independent fallback paths.</span></span> <span data-ttu-id="ce247-239">例如，如果 SQL Database 無法使用，請將交易放入佇列，以供稍後處理。</span><span class="sxs-lookup"><span data-stu-id="ce247-239">For example, if SQL Database is unavailable, put transactions into a queue, to be processed later.</span></span>

![複合 SLA](./images/sla2.png)

<span data-ttu-id="ce247-241">透過這個設計，即使在無法連線到資料庫的情況下，應用程式還是可以使用。</span><span class="sxs-lookup"><span data-stu-id="ce247-241">With this design, the application is still available even if it can't connect to the database.</span></span> <span data-ttu-id="ce247-242">不過，如果資料庫與佇列同時失敗，它就會失敗。</span><span class="sxs-lookup"><span data-stu-id="ce247-242">However, it fails if the database and the queue both fail at the same time.</span></span> <span data-ttu-id="ce247-243">預期的同時失敗時間百分比是 0.0001 &times; 0.001，因此這個合併路徑的複合 SLA 是：</span><span class="sxs-lookup"><span data-stu-id="ce247-243">The expected percentage of time for a simultaneous failure is 0.0001 &times; 0.001, so the composite SLA for this combined path is:</span></span>  

* <span data-ttu-id="ce247-244">資料庫或佇列 = 1.0 &minus; (0.0001 &times; 0.001) = 99.99999%</span><span class="sxs-lookup"><span data-stu-id="ce247-244">Database OR queue = 1.0 &minus; (0.0001 &times; 0.001) = 99.99999%</span></span>

<span data-ttu-id="ce247-245">複合 SLA 總計是：</span><span class="sxs-lookup"><span data-stu-id="ce247-245">The total composite SLA is:</span></span>

* <span data-ttu-id="ce247-246">Web 應用程式和 (資料庫或佇列) = 99.95% &times; 99.99999% = ~99.95%</span><span class="sxs-lookup"><span data-stu-id="ce247-246">Web app AND (database OR queue) = 99.95% &times; 99.99999% = ~99.95%</span></span>

<span data-ttu-id="ce247-247">但這種方法有其優缺點。</span><span class="sxs-lookup"><span data-stu-id="ce247-247">But there are tradeoffs to this approach.</span></span> <span data-ttu-id="ce247-248">應用程式邏輯更複雜、您需支付佇列，並且可能要考量資料一致性的問題。</span><span class="sxs-lookup"><span data-stu-id="ce247-248">The application logic is more complex, you are paying for the queue, and there may be data consistency issues to consider.</span></span>

<span data-ttu-id="ce247-249">**多區域部署的 SLA**。</span><span class="sxs-lookup"><span data-stu-id="ce247-249">**SLA for multi-region deployments**.</span></span> <span data-ttu-id="ce247-250">另一項高可用性技術是將應用程式部署在多個區域中，且如果應用程式在一個區域中失敗，就使用 Azure Traffic Manager 進行容錯移轉。</span><span class="sxs-lookup"><span data-stu-id="ce247-250">Another HA technique is to deploy the application in more than one region, and use Azure Traffic Manager to fail over if the application fails in one region.</span></span> <span data-ttu-id="ce247-251">針對兩個區域部署，複合 SLA 的計算方式如下。</span><span class="sxs-lookup"><span data-stu-id="ce247-251">For a two-region deployment, the composite SLA is calculated as follows.</span></span> 

<span data-ttu-id="ce247-252">假設部署在一個區域之應用程式的複合 SLA 為 N。</span><span class="sxs-lookup"><span data-stu-id="ce247-252">Let *N* be the composite SLA for the application deployed in one region.</span></span> <span data-ttu-id="ce247-253">應用程式在這兩個地區同時失敗的預期機率為 (1 &minus; N) &times; (1 &minus; N)。</span><span class="sxs-lookup"><span data-stu-id="ce247-253">The expected chance that the application will fail in both regions at the same time is (1 &minus; N) &times; (1 &minus; N).</span></span> <span data-ttu-id="ce247-254">因此，</span><span class="sxs-lookup"><span data-stu-id="ce247-254">Therefore,</span></span>

* <span data-ttu-id="ce247-255">這兩個地區的合併 SLA = 1 &minus; (1 &minus; N)(1 &minus; N) = N + (1 &minus; N)N</span><span class="sxs-lookup"><span data-stu-id="ce247-255">Combined SLA for both regions = 1 &minus; (1 &minus; N)(1 &minus; N) = N + (1 &minus; N)N</span></span>

<span data-ttu-id="ce247-256">最後，您必須納入[適用於流量管理員的 SLA][tm-sla]。</span><span class="sxs-lookup"><span data-stu-id="ce247-256">Finally, you must factor in the [SLA for Traffic Manager][tm-sla].</span></span> <span data-ttu-id="ce247-257">在撰寫本文時，流量管理員 SLA 的 SLA 為 99.99%。</span><span class="sxs-lookup"><span data-stu-id="ce247-257">At the time of this writing, the SLA for Traffic Manager SLA is 99.99%.</span></span>

* <span data-ttu-id="ce247-258">複合 SLA = 99.99% &times; (這兩個區域的合併 SLA)</span><span class="sxs-lookup"><span data-stu-id="ce247-258">Composite SLA = 99.99% &times; (combined SLA for both regions)</span></span>

<span data-ttu-id="ce247-259">此外，容錯移轉不是在瞬間完成，並且在容錯移轉期間可能導致停機一段時間。</span><span class="sxs-lookup"><span data-stu-id="ce247-259">Also, failing over is not instantaneous and can result in some downtime during a failover.</span></span> <span data-ttu-id="ce247-260">請參閱[流量管理員端點監視和容錯移轉][tm-failover]。</span><span class="sxs-lookup"><span data-stu-id="ce247-260">See [Traffic Manager endpoint monitoring and failover][tm-failover].</span></span>

<span data-ttu-id="ce247-261">計算的 SLA 數目是實用的基準，但不會顯示有關可用性的整體內容。</span><span class="sxs-lookup"><span data-stu-id="ce247-261">The calculated SLA number is a useful baseline, but it doesn't tell the whole story about availability.</span></span> <span data-ttu-id="ce247-262">通常，當非關鍵路徑失敗時，應用程式可能會依正常程序降級。</span><span class="sxs-lookup"><span data-stu-id="ce247-262">Often, an application can degrade gracefully when a non-critical path fails.</span></span> <span data-ttu-id="ce247-263">請考慮顯示書籍目錄的應用程式。</span><span class="sxs-lookup"><span data-stu-id="ce247-263">Consider an application that shows a catalog of books.</span></span> <span data-ttu-id="ce247-264">如果應用程式無法擷取封面的縮圖映像，它可能會顯示預留位置映像。</span><span class="sxs-lookup"><span data-stu-id="ce247-264">If the application can't retrieve the thumbnail image for the cover, it might show a placeholder image.</span></span> <span data-ttu-id="ce247-265">在此情況下，雖然會影響使用者體驗，但無法取得映像並不會減少應用程式的執行時間。</span><span class="sxs-lookup"><span data-stu-id="ce247-265">In that case, failing to get the image does not reduce the application's uptime, although it affects the user experience.</span></span>  

## <a name="designing-for-resiliency"></a><span data-ttu-id="ce247-266">針對復原而設計</span><span class="sxs-lookup"><span data-stu-id="ce247-266">Designing for resiliency</span></span>
<span data-ttu-id="ce247-267">在設計階段中，您應該執行失敗模式分析 (FMA)。</span><span class="sxs-lookup"><span data-stu-id="ce247-267">During the design phase, you should perform a failure mode analysis (FMA).</span></span> <span data-ttu-id="ce247-268">FMA 的目標是要找出失敗的可能點，並定義應用程式回應這些失敗的方式。</span><span class="sxs-lookup"><span data-stu-id="ce247-268">The goal of an FMA is to identify possible points of failure, and define how the application will respond to those failures.</span></span>

* <span data-ttu-id="ce247-269">應用程式會如何偵測此類型的失敗？</span><span class="sxs-lookup"><span data-stu-id="ce247-269">How will the application detect this type of failure?</span></span>
* <span data-ttu-id="ce247-270">應用程式會如何回應此類型的失敗？</span><span class="sxs-lookup"><span data-stu-id="ce247-270">How will the application respond to this type of failure?</span></span>
* <span data-ttu-id="ce247-271">您會如何記錄和監視此類型的失敗？</span><span class="sxs-lookup"><span data-stu-id="ce247-271">How will you log and monitor this type of failure?</span></span> 

<span data-ttu-id="ce247-272">如需包含適用於 Azure 之特定建議事項的 FMA 程序相關資訊，請參閱 [Azure 復原指引：失敗模式分析][fma]。</span><span class="sxs-lookup"><span data-stu-id="ce247-272">For more information about the FMA process, with specific recommendations for Azure, see [Azure resiliency guidance: Failure mode analysis][fma].</span></span>

### <a name="example-of-identifying-failure-modes-and-detection-strategy"></a><span data-ttu-id="ce247-273">識別失敗模式和偵測策略的範例</span><span class="sxs-lookup"><span data-stu-id="ce247-273">Example of identifying failure modes and detection strategy</span></span>
<span data-ttu-id="ce247-274">**失敗點：**呼叫外部 web 服務/API。</span><span class="sxs-lookup"><span data-stu-id="ce247-274">**Failure point:** Call to an external web service / API.</span></span>

| <span data-ttu-id="ce247-275">失敗模式</span><span class="sxs-lookup"><span data-stu-id="ce247-275">Failure mode</span></span> | <span data-ttu-id="ce247-276">偵測策略</span><span class="sxs-lookup"><span data-stu-id="ce247-276">Detection strategy</span></span> |
| --- | --- |
| <span data-ttu-id="ce247-277">服務停用</span><span class="sxs-lookup"><span data-stu-id="ce247-277">Service is unavailable</span></span> |<span data-ttu-id="ce247-278">HTTP 5xx</span><span class="sxs-lookup"><span data-stu-id="ce247-278">HTTP 5xx</span></span> |
| <span data-ttu-id="ce247-279">節流</span><span class="sxs-lookup"><span data-stu-id="ce247-279">Throttling</span></span> |<span data-ttu-id="ce247-280">HTTP 429 (太多要求)</span><span class="sxs-lookup"><span data-stu-id="ce247-280">HTTP 429 (Too Many Requests)</span></span> |
| <span data-ttu-id="ce247-281">驗證</span><span class="sxs-lookup"><span data-stu-id="ce247-281">Authentication</span></span> |<span data-ttu-id="ce247-282">HTTP 401 (未經授權)</span><span class="sxs-lookup"><span data-stu-id="ce247-282">HTTP 401 (Unauthorized)</span></span> |
| <span data-ttu-id="ce247-283">回應變慢</span><span class="sxs-lookup"><span data-stu-id="ce247-283">Slow response</span></span> |<span data-ttu-id="ce247-284">要求逾時</span><span class="sxs-lookup"><span data-stu-id="ce247-284">Request times out</span></span> |

## <a name="resiliency-strategies"></a><span data-ttu-id="ce247-285">復原策略</span><span class="sxs-lookup"><span data-stu-id="ce247-285">Resiliency strategies</span></span>
<span data-ttu-id="ce247-286">本節提供一些常見復原策略的問卷調查。</span><span class="sxs-lookup"><span data-stu-id="ce247-286">This section provides a survey of some common resiliency strategies.</span></span> <span data-ttu-id="ce247-287">這些大多數並不限於特定技術。</span><span class="sxs-lookup"><span data-stu-id="ce247-287">Most of these are not limited to a particular technology.</span></span> <span data-ttu-id="ce247-288">本節的描述彙總每一種技巧的一般概念，並提供進一步閱讀的連結。</span><span class="sxs-lookup"><span data-stu-id="ce247-288">The descriptions in this section summarize the general idea behind each technique, with links to further reading.</span></span>

### <a name="retry-transient-failures"></a><span data-ttu-id="ce247-289">重試暫時性失敗</span><span class="sxs-lookup"><span data-stu-id="ce247-289">Retry transient failures</span></span>
<span data-ttu-id="ce247-290">可能會因暫時遺失網路連線、卸除資料庫連線或服務忙碌時的逾時而造成暫時性失敗。</span><span class="sxs-lookup"><span data-stu-id="ce247-290">Transient failures can be caused by momentary loss of network connectivity, a dropped database connection, or a timeout when a service is busy.</span></span> <span data-ttu-id="ce247-291">通常，只需重試要求就可以解決暫時性失敗。</span><span class="sxs-lookup"><span data-stu-id="ce247-291">Often, a transient failure can be resolved simply by retrying the request.</span></span> <span data-ttu-id="ce247-292">對於許多 Azure 服務，用戶端 SDK 會透過對呼叫端透明的方式實作自動重試；請參閱[重試服務的特定指引][retry-service-specific guidance]。</span><span class="sxs-lookup"><span data-stu-id="ce247-292">For many Azure services, the client SDK implements automatic retries, in a way that is transparent to the caller; see [Retry service specific guidance][retry-service-specific guidance].</span></span>

<span data-ttu-id="ce247-293">每次重試都會新增至總延遲。</span><span class="sxs-lookup"><span data-stu-id="ce247-293">Each retry attempt adds to the total latency.</span></span> <span data-ttu-id="ce247-294">此外，失敗的要求過多可能會造成瓶頸，因為擱置中的要求會累積在佇列中。</span><span class="sxs-lookup"><span data-stu-id="ce247-294">Also, too many failed requests can cause a bottleneck, as pending requests accumulate in the queue.</span></span> <span data-ttu-id="ce247-295">這些已封鎖的要求可能會佔據重要的系統資源，例如記憶體、執行緒、資料庫連線等等，可能會造成串聯式失敗。</span><span class="sxs-lookup"><span data-stu-id="ce247-295">These blocked requests might hold critical system resources such as memory, threads, database connections, and so on, which can cause cascading failures.</span></span> <span data-ttu-id="ce247-296">若要避免這個問題，請在每次重試之間增加延遲，並限制失敗的要求總數。</span><span class="sxs-lookup"><span data-stu-id="ce247-296">To avoid this, increase the delay between each retry attempt, and limit the total number of failed requests.</span></span>

![複合 SLA](./images/retry.png)

<span data-ttu-id="ce247-298">如需詳細資訊，請參閱[重試模式][retry-pattern]。</span><span class="sxs-lookup"><span data-stu-id="ce247-298">For more information, see [Retry Pattern][retry-pattern].</span></span>

### <a name="load-balance-across-instances"></a><span data-ttu-id="ce247-299">在執行個體之間進行負載平衡</span><span class="sxs-lookup"><span data-stu-id="ce247-299">Load balance across instances</span></span>
<span data-ttu-id="ce247-300">就延展性而言，雲端應用程式應該能夠藉由新增更多執行個體來相應放大。</span><span class="sxs-lookup"><span data-stu-id="ce247-300">For scalability, a cloud application should be able to scale out by adding more instances.</span></span> <span data-ttu-id="ce247-301">這種方法也會改善復原，因為狀況不良的執行個體可從旋轉中移除。</span><span class="sxs-lookup"><span data-stu-id="ce247-301">This approach also improves resiliency, because unhealthy instances can be removed from rotation.</span></span>  

<span data-ttu-id="ce247-302">例如：</span><span class="sxs-lookup"><span data-stu-id="ce247-302">For example:</span></span>

* <span data-ttu-id="ce247-303">將兩個或多個 VM 放在負載平衡器後。</span><span class="sxs-lookup"><span data-stu-id="ce247-303">Put two or more VMs behind a load balancer.</span></span> <span data-ttu-id="ce247-304">負載平衡器會散發所有 VM 的流量。</span><span class="sxs-lookup"><span data-stu-id="ce247-304">The load balancer distributes traffic to all the VMs.</span></span> <span data-ttu-id="ce247-305">請參閱[執行負載平衡的 VM 以獲得延展性和可用性][ra-multi-vm]。</span><span class="sxs-lookup"><span data-stu-id="ce247-305">See [Run load-balanced VMs for scalability and availability][ra-multi-vm].</span></span>
* <span data-ttu-id="ce247-306">將 Azure App Service 應用程式相應放大至多個執行個體。</span><span class="sxs-lookup"><span data-stu-id="ce247-306">Scale out an Azure App Service app to multiple instances.</span></span> <span data-ttu-id="ce247-307">App Service 會自動平衡執行個體之間的負載。</span><span class="sxs-lookup"><span data-stu-id="ce247-307">App Service automatically balances load across instances.</span></span> <span data-ttu-id="ce247-308">請參閱[基本 Web 應用程式][ra-basic-web]。</span><span class="sxs-lookup"><span data-stu-id="ce247-308">See [Basic web application][ra-basic-web].</span></span>
* <span data-ttu-id="ce247-309">使用 [Azure 流量管理員][tm]來散發一組端點之間的流量。</span><span class="sxs-lookup"><span data-stu-id="ce247-309">Use [Azure Traffic Manager][tm] to distribute traffic across a set of endpoints.</span></span>


### <a name="replicate-data"></a><span data-ttu-id="ce247-310">複寫資料</span><span class="sxs-lookup"><span data-stu-id="ce247-310">Replicate data</span></span>
<span data-ttu-id="ce247-311">複寫資料是處理資料存放區中非暫時性失敗的一般策略。</span><span class="sxs-lookup"><span data-stu-id="ce247-311">Replicating data is a general strategy for handling non-transient failures in a data store.</span></span> <span data-ttu-id="ce247-312">許多儲存體技術都會提供內建的複寫，包括 Azure SQL Database、Cosmos DB 和 Apache Cassandra。</span><span class="sxs-lookup"><span data-stu-id="ce247-312">Many storage technologies provide built-in replication, including Azure SQL Database, Cosmos DB, and Apache Cassandra.</span></span>  

<span data-ttu-id="ce247-313">請務必考慮讀取和寫入的路徑。</span><span class="sxs-lookup"><span data-stu-id="ce247-313">It's important to consider both the read and write paths.</span></span> <span data-ttu-id="ce247-314">根據儲存體技術，您可能有多個可寫入複本，或單一可寫入複本及多個唯讀複本。</span><span class="sxs-lookup"><span data-stu-id="ce247-314">Depending on the storage technology, you might have multiple writable replicas, or a single writable replica and multiple read-only replicas.</span></span> 

<span data-ttu-id="ce247-315">若要將可用性最大化，可將複本放在多個區域。</span><span class="sxs-lookup"><span data-stu-id="ce247-315">To maximize availability, replicas can be placed in multiple regions.</span></span> <span data-ttu-id="ce247-316">不過，這會在複寫資料時增加延遲。</span><span class="sxs-lookup"><span data-stu-id="ce247-316">However, this increases the latency when replicating the data.</span></span> <span data-ttu-id="ce247-317">一般而言，跨區域複寫會以非同步方式進行，這表示複本失敗時，會有最終一致性模型和資料遺失。</span><span class="sxs-lookup"><span data-stu-id="ce247-317">Typically, replicating across regions is done asynchronously, which implies an eventual consistency model and potential data loss if a replica fails.</span></span> 

### <a name="degrade-gracefully"></a><span data-ttu-id="ce247-318">正常降級</span><span class="sxs-lookup"><span data-stu-id="ce247-318">Degrade gracefully</span></span>
<span data-ttu-id="ce247-319">如果服務失敗且沒有容錯移轉路徑，應用程式就可以正常降級，但仍會提供可接受的使用者體驗。</span><span class="sxs-lookup"><span data-stu-id="ce247-319">If a service fails and there is no failover path, the application may be able to degrade gracefully while still providing an acceptable user experience.</span></span> <span data-ttu-id="ce247-320">例如：</span><span class="sxs-lookup"><span data-stu-id="ce247-320">For example:</span></span>

* <span data-ttu-id="ce247-321">將工作項目放入佇列，以供稍後處理。</span><span class="sxs-lookup"><span data-stu-id="ce247-321">Put a work item on a queue, to be handled later.</span></span> 
* <span data-ttu-id="ce247-322">傳回預估的值。</span><span class="sxs-lookup"><span data-stu-id="ce247-322">Return an estimated value.</span></span>
* <span data-ttu-id="ce247-323">使用本機快取的資料。</span><span class="sxs-lookup"><span data-stu-id="ce247-323">Use locally cached data.</span></span> 
* <span data-ttu-id="ce247-324">向使用者顯示錯誤訊息。</span><span class="sxs-lookup"><span data-stu-id="ce247-324">Show the user an error message.</span></span> <span data-ttu-id="ce247-325">(這個選項優於讓應用程式停止回應要求。)</span><span class="sxs-lookup"><span data-stu-id="ce247-325">(This option is better than having the application stop responding to requests.)</span></span>

### <a name="throttle-high-volume-users"></a><span data-ttu-id="ce247-326">節流處理大量的使用者</span><span class="sxs-lookup"><span data-stu-id="ce247-326">Throttle high-volume users</span></span>
<span data-ttu-id="ce247-327">有時候，少數使用者會建立過多的負載。</span><span class="sxs-lookup"><span data-stu-id="ce247-327">Sometimes a small number of users create excessive load.</span></span> <span data-ttu-id="ce247-328">這可能會對其他使用者造成影響，從而減少您應用程式的整體可用性。</span><span class="sxs-lookup"><span data-stu-id="ce247-328">That can have an impact on other users, reducing the overall availability of your application.</span></span>

<span data-ttu-id="ce247-329">當單一用戶端的要求數目過多時，應用程式可能會將用戶端節流一段時間。</span><span class="sxs-lookup"><span data-stu-id="ce247-329">When a single client makes an excessive number of requests, the application might throttle the client for a certain period of time.</span></span> <span data-ttu-id="ce247-330">在節流期間，應用程式會拒絕來自該用戶端的部分或所有要求 (取決於實際的節流策略)。</span><span class="sxs-lookup"><span data-stu-id="ce247-330">During the throttling period, the application refuses some or all of the requests from that client (depending on the exact throttling strategy).</span></span> <span data-ttu-id="ce247-331">節流的臨界值可能會取決於客戶的服務層。</span><span class="sxs-lookup"><span data-stu-id="ce247-331">The threshold for throttling might depend on the customer's service tier.</span></span> 

<span data-ttu-id="ce247-332">節流並不表示用戶端一定有惡意行動，僅表示它超過其服務配額。</span><span class="sxs-lookup"><span data-stu-id="ce247-332">Throttling does not imply the client was necessarily acting maliciously, only that it exceeded its service quota.</span></span> <span data-ttu-id="ce247-333">在某些情況下，取用者可能會持續超過其配額或是行為不當。</span><span class="sxs-lookup"><span data-stu-id="ce247-333">In some cases, a consumer might consistently exceed their quota or otherwise behave badly.</span></span> <span data-ttu-id="ce247-334">在此情況下，您可能會繼續執行並封鎖使用者。</span><span class="sxs-lookup"><span data-stu-id="ce247-334">In that case, you might go further and block the user.</span></span> <span data-ttu-id="ce247-335">一般而言，這是透過封鎖 API 金鑰或 IP 位址範圍來完成。</span><span class="sxs-lookup"><span data-stu-id="ce247-335">Typically, this is done by blocking an API key or an IP address range.</span></span>

<span data-ttu-id="ce247-336">如需詳細資訊，請參閱 [Throttling Pattern (分節流模式)][throttling-pattern]。</span><span class="sxs-lookup"><span data-stu-id="ce247-336">For more information, see [Throttling Pattern][throttling-pattern].</span></span>

### <a name="use-a-circuit-breaker"></a><span data-ttu-id="ce247-337">使用斷路器</span><span class="sxs-lookup"><span data-stu-id="ce247-337">Use a circuit breaker</span></span>
<span data-ttu-id="ce247-338">斷路器模式可防止應用程式重複嘗試很可能會失敗的作業。</span><span class="sxs-lookup"><span data-stu-id="ce247-338">The Circuit Breaker pattern can prevent an application from repeatedly trying an operation that is likely to fail.</span></span> <span data-ttu-id="ce247-339">這類似於實體斷路器，是在電路多載時會中斷電流流程的開關。</span><span class="sxs-lookup"><span data-stu-id="ce247-339">This is similar to a physical circuit breaker, a switch that interrupts the flow of current when a circuit is overloaded.</span></span>

<span data-ttu-id="ce247-340">斷路器會包裝對服務的呼叫。</span><span class="sxs-lookup"><span data-stu-id="ce247-340">The circuit breaker wraps calls to a service.</span></span> <span data-ttu-id="ce247-341">它有三種狀態：</span><span class="sxs-lookup"><span data-stu-id="ce247-341">It has three states:</span></span>

* <span data-ttu-id="ce247-342">**關閉**.</span><span class="sxs-lookup"><span data-stu-id="ce247-342">**Closed**.</span></span> <span data-ttu-id="ce247-343">這是正常的狀態。</span><span class="sxs-lookup"><span data-stu-id="ce247-343">This is the normal state.</span></span> <span data-ttu-id="ce247-344">斷路器會將要求傳送至服務，而計數器會追蹤最近的失敗數目。</span><span class="sxs-lookup"><span data-stu-id="ce247-344">The circuit breaker sends requests to the service, and a counter tracks the number of recent failures.</span></span> <span data-ttu-id="ce247-345">如果失敗計數在指定的時段內超過臨界值，斷路器會切換成 [開啟] 狀態。</span><span class="sxs-lookup"><span data-stu-id="ce247-345">If the failure count exceeds a threshold within a given time period, the circuit breaker switches to the Open state.</span></span> 
* <span data-ttu-id="ce247-346">**開啟**。</span><span class="sxs-lookup"><span data-stu-id="ce247-346">**Open**.</span></span> <span data-ttu-id="ce247-347">在這個狀態下，斷路器會立即使所有要求失敗，而不呼叫服務。</span><span class="sxs-lookup"><span data-stu-id="ce247-347">In this state, the circuit breaker immediately fails all requests, without calling the service.</span></span> <span data-ttu-id="ce247-348">應用程式應該使用風險降低路徑，例如從複本中讀取資料，或只將錯誤傳回給使用者。</span><span class="sxs-lookup"><span data-stu-id="ce247-348">The application should use a mitigation path, such as reading data from a replica or simply returning an error to the user.</span></span> <span data-ttu-id="ce247-349">當斷路器切換到 [開啟] 時，就會啟動計時器。</span><span class="sxs-lookup"><span data-stu-id="ce247-349">When the circuit breaker switches to Open, it starts a timer.</span></span> <span data-ttu-id="ce247-350">當計時器過期時，斷路器會切換成 [半開啟] 狀態。</span><span class="sxs-lookup"><span data-stu-id="ce247-350">When the timer expires, the circuit breaker switches to the Half-open state.</span></span>
* <span data-ttu-id="ce247-351">**半開啟**。</span><span class="sxs-lookup"><span data-stu-id="ce247-351">**Half-open**.</span></span> <span data-ttu-id="ce247-352">在這個狀態下，斷路器只會讓有限數量的要求通過服務。</span><span class="sxs-lookup"><span data-stu-id="ce247-352">In this state, the circuit breaker lets a limited number of requests go through to the service.</span></span> <span data-ttu-id="ce247-353">如果成功，服務會假設為復原，而斷路器會切換回 [關閉] 狀態。</span><span class="sxs-lookup"><span data-stu-id="ce247-353">If they succeed, the service is assumed to be recovered, and the circuit breaker switches back to the Closed state.</span></span> <span data-ttu-id="ce247-354">否則，它會還原為 [開啟] 狀態。</span><span class="sxs-lookup"><span data-stu-id="ce247-354">Otherwise, it reverts to the Open state.</span></span> <span data-ttu-id="ce247-355">[半開啟] 狀態可以防止復原服務突然出現的許多要求。</span><span class="sxs-lookup"><span data-stu-id="ce247-355">The Half-Open state prevents a recovering service from suddenly being inundated with requests.</span></span>

<span data-ttu-id="ce247-356">如需詳細資料，請參閱[斷路器模式][circuit-breaker-pattern]。</span><span class="sxs-lookup"><span data-stu-id="ce247-356">For more information, see [Circuit Breaker Pattern][circuit-breaker-pattern].</span></span>

### <a name="use-load-leveling-to-smooth-out-spikes-in-traffic"></a><span data-ttu-id="ce247-357">使用負載均衡來消除流量尖峰</span><span class="sxs-lookup"><span data-stu-id="ce247-357">Use load leveling to smooth out spikes in traffic</span></span>
<span data-ttu-id="ce247-358">應用程式可能會突然出現流量尖峰，可能會在後端灌爆服務。</span><span class="sxs-lookup"><span data-stu-id="ce247-358">Applications may experience sudden spikes in traffic, which can overwhelm services on the backend.</span></span> <span data-ttu-id="ce247-359">如果後端服務回應要求的速度不夠快，可能會造成要求排入佇列 (備份)，或導致服務節流應用程式。</span><span class="sxs-lookup"><span data-stu-id="ce247-359">If a backend service cannot respond to requests quickly enough, it may cause requests to queue (back up), or cause the service to throttle the application.</span></span>

<span data-ttu-id="ce247-360">若要避免這個問題，您可以使用佇列作為緩衝區。</span><span class="sxs-lookup"><span data-stu-id="ce247-360">To avoid this, you can use a queue as a buffer.</span></span> <span data-ttu-id="ce247-361">沒有新的工作項目時，並非立即呼叫後端服務，而是應用程式會佇列工作項目，以非同步的方式執行。</span><span class="sxs-lookup"><span data-stu-id="ce247-361">When there is a new work item, instead of calling the backend service immediately, the application queues a work item to run asynchronously.</span></span> <span data-ttu-id="ce247-362">佇列會作為消除負載尖峰的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="ce247-362">The queue acts as a buffer that smooths out peaks in the load.</span></span> 

<span data-ttu-id="ce247-363">如需詳細資訊，請參閱[佇列型負載調節模式][load-leveling-pattern]。</span><span class="sxs-lookup"><span data-stu-id="ce247-363">For more information, see [Queue-Based Load Leveling Pattern][load-leveling-pattern].</span></span>

### <a name="isolate-critical-resources"></a><span data-ttu-id="ce247-364">隔離重要的資源</span><span class="sxs-lookup"><span data-stu-id="ce247-364">Isolate critical resources</span></span>
<span data-ttu-id="ce247-365">一個子系統中的失敗有時候可能會重疊，導致應用程式其他部分失敗。</span><span class="sxs-lookup"><span data-stu-id="ce247-365">Failures in one subsystem can sometimes cascade, causing failures in other parts of the application.</span></span> <span data-ttu-id="ce247-366">如果失敗造成某些資源 (例如執行緒或通訊端) 無法即時釋出，而導致資源耗盡，就會發生這個情況。</span><span class="sxs-lookup"><span data-stu-id="ce247-366">This can happen if a failure causes some resources, such as threads or sockets, not to get freed in a timely manner, leading to resource exhaustion.</span></span> 

<span data-ttu-id="ce247-367">若要避免這個問題，您可以將系統分割為隔離群組，讓一個分割區中的失敗不會使整個系統當機。</span><span class="sxs-lookup"><span data-stu-id="ce247-367">To avoid this, you can partition a system into isolated groups, so that a failure in one partition does not bring down the entire system.</span></span> <span data-ttu-id="ce247-368">這項技術通常稱為艙模式。</span><span class="sxs-lookup"><span data-stu-id="ce247-368">This technique is sometimes called the Bulkhead pattern.</span></span>

<span data-ttu-id="ce247-369">範例：</span><span class="sxs-lookup"><span data-stu-id="ce247-369">Examples:</span></span>

* <span data-ttu-id="ce247-370">資料資料庫 (例如，依由租用戶)，並針對每個分割區指派 web 伺服器執行個體的個別集區。</span><span class="sxs-lookup"><span data-stu-id="ce247-370">Partition a database (for example, by tenant) and assign a separate pool of web server instances for each partition.</span></span>  
* <span data-ttu-id="ce247-371">使用個別執行緒集區將呼叫隔離至不同的服務。</span><span class="sxs-lookup"><span data-stu-id="ce247-371">Use separate thread pools to isolate calls to different services.</span></span> <span data-ttu-id="ce247-372">如果其中一個服務失敗，這有助於防止階層式失敗。</span><span class="sxs-lookup"><span data-stu-id="ce247-372">This helps to prevent cascading failures if one of the services fails.</span></span> <span data-ttu-id="ce247-373">如需範例，請參閱 Netflix [Hystrix 文件庫][hystrix]。</span><span class="sxs-lookup"><span data-stu-id="ce247-373">For an example, see the Netflix [Hystrix library][hystrix].</span></span>
* <span data-ttu-id="ce247-374">使用[容器][containers]來限制特定子系統的可用資源。</span><span class="sxs-lookup"><span data-stu-id="ce247-374">Use [containers][containers] to limit the resources available to a particular subsystem.</span></span> 

![複合 SLA](./images/bulkhead.png)

### <a name="apply-compensating-transactions"></a><span data-ttu-id="ce247-376">套用補償交易</span><span class="sxs-lookup"><span data-stu-id="ce247-376">Apply compensating transactions</span></span>
<span data-ttu-id="ce247-377">補償交易是將另一個已完成交易的影響復原的交易。</span><span class="sxs-lookup"><span data-stu-id="ce247-377">A compensating transaction is a transaction that undoes the effects of another completed transaction.</span></span>

<span data-ttu-id="ce247-378">在分散式系統中，要達到強式交易一致性非常困難。</span><span class="sxs-lookup"><span data-stu-id="ce247-378">In a distributed system, it can be very difficult to achieve strong transactional consistency.</span></span> <span data-ttu-id="ce247-379">補償交易是達到一致性的方式，方法為使用一系列可以在每個步驟中復原的較小型個別交易。</span><span class="sxs-lookup"><span data-stu-id="ce247-379">Compensating transactions are a way to achieve consistency by using a series of smaller, individual transactions that can be undone at each step.</span></span>

<span data-ttu-id="ce247-380">例如，若要預訂旅程，客戶可能要預約汽車、旅館房間和班機。</span><span class="sxs-lookup"><span data-stu-id="ce247-380">For example, to book a trip, a customer might reserve a car, a hotel room, and a flight.</span></span> <span data-ttu-id="ce247-381">如果其中任何步驟失敗，整個作業就會失敗。</span><span class="sxs-lookup"><span data-stu-id="ce247-381">If any of these steps fails, the entire operation fails.</span></span> <span data-ttu-id="ce247-382">您並非在整個作業中嘗試使用單一的分散式交易，而是可以定義每個步驟的補償交易。</span><span class="sxs-lookup"><span data-stu-id="ce247-382">Instead of trying to use a single distributed transaction for the entire operation, you can define a compensating transaction for each step.</span></span> <span data-ttu-id="ce247-383">例如，若要復原汽車預約，您要取消此預約。</span><span class="sxs-lookup"><span data-stu-id="ce247-383">For example, to undo a car reservation, you cancel the reservation.</span></span> <span data-ttu-id="ce247-384">若要完成整個作業，協調員會執行每個步驟。</span><span class="sxs-lookup"><span data-stu-id="ce247-384">In order to complete the whole operation, a coordinator executes each step.</span></span> <span data-ttu-id="ce247-385">如果任何步驟失敗，協調員會套用補償交易來復原任何已完成的步驟。</span><span class="sxs-lookup"><span data-stu-id="ce247-385">If any step fails, the coordinator applies compensating transactions to undo any steps that were completed.</span></span> 

<span data-ttu-id="ce247-386">如需詳細資訊，請參閱 [補償交易模式][compensating-transaction-pattern]。</span><span class="sxs-lookup"><span data-stu-id="ce247-386">For more information, see [Compensating Transaction Pattern][compensating-transaction-pattern].</span></span> 


## <a name="testing-for-resiliency"></a><span data-ttu-id="ce247-387">針對復原而測試</span><span class="sxs-lookup"><span data-stu-id="ce247-387">Testing for resiliency</span></span>
<span data-ttu-id="ce247-388">一般而言，您無法使用與您測試應用程式功能 (藉由執行單元測試等等) 的方式相同來測試復原。</span><span class="sxs-lookup"><span data-stu-id="ce247-388">Generally, you can't test resiliency in the same way that you test application functionality (by running unit tests and so on).</span></span> <span data-ttu-id="ce247-389">相反地，您必須測試端對端工作負載在失敗情況下的執行方式，這只會間歇性發生。</span><span class="sxs-lookup"><span data-stu-id="ce247-389">Instead, you must test how the end-to-end workload performs under failure conditions which only occur intermittently.</span></span>

<span data-ttu-id="ce247-390">測試是反覆的程序。</span><span class="sxs-lookup"><span data-stu-id="ce247-390">Testing is an iterative process.</span></span> <span data-ttu-id="ce247-391">測試應用程式、測量結果、分析及解決所發生的任何失敗，並重複此程序。</span><span class="sxs-lookup"><span data-stu-id="ce247-391">Test the application, measure the outcome, analyze and address any failures that result, and repeat the process.</span></span>

<span data-ttu-id="ce247-392">**錯誤插入式測試**。</span><span class="sxs-lookup"><span data-stu-id="ce247-392">**Fault injection testing**.</span></span> <span data-ttu-id="ce247-393">在失敗期間測試系統的復原，方法為觸發實際的失敗或加以模擬。</span><span class="sxs-lookup"><span data-stu-id="ce247-393">Test the resiliency of the system during failures, either by triggering actual failures or by simulating them.</span></span> <span data-ttu-id="ce247-394">以下是一些要測試的常見失敗案例：</span><span class="sxs-lookup"><span data-stu-id="ce247-394">Here are some common failure scenarios to test:</span></span>

* <span data-ttu-id="ce247-395">關閉 VM 執行個體。</span><span class="sxs-lookup"><span data-stu-id="ce247-395">Shut down VM instances.</span></span>
* <span data-ttu-id="ce247-396">毀損程序。</span><span class="sxs-lookup"><span data-stu-id="ce247-396">Crash processes.</span></span>
* <span data-ttu-id="ce247-397">憑證到期。</span><span class="sxs-lookup"><span data-stu-id="ce247-397">Expire certificates.</span></span>
* <span data-ttu-id="ce247-398">變更存取金鑰。</span><span class="sxs-lookup"><span data-stu-id="ce247-398">Change access keys.</span></span>
* <span data-ttu-id="ce247-399">關閉網域控制站上的 DNS 服務。</span><span class="sxs-lookup"><span data-stu-id="ce247-399">Shut down the DNS service on domain controllers.</span></span>
* <span data-ttu-id="ce247-400">限制可用的系統資源，例如 RAM 或執行緒的數目。</span><span class="sxs-lookup"><span data-stu-id="ce247-400">Limit available system resources, such as RAM or number of threads.</span></span>
* <span data-ttu-id="ce247-401">取消掛接磁碟。</span><span class="sxs-lookup"><span data-stu-id="ce247-401">Unmount disks.</span></span>
* <span data-ttu-id="ce247-402">重新部署 VM。</span><span class="sxs-lookup"><span data-stu-id="ce247-402">Redeploy a VM.</span></span>

<span data-ttu-id="ce247-403">測量復原時間，並確認已符合您的業務需求。</span><span class="sxs-lookup"><span data-stu-id="ce247-403">Measure the recovery times and verify that your business requirements are met.</span></span> <span data-ttu-id="ce247-404">此外，也需測試失敗模式組合。</span><span class="sxs-lookup"><span data-stu-id="ce247-404">Test combinations of failure modes as well.</span></span> <span data-ttu-id="ce247-405">請確定失敗不會重疊，且會以隔離的方式處理。</span><span class="sxs-lookup"><span data-stu-id="ce247-405">Make sure that failures don't cascade, and are handled in an isolated way.</span></span>

<span data-ttu-id="ce247-406">這是分析設計階段期間可能的失敗點另一個重要的原因。</span><span class="sxs-lookup"><span data-stu-id="ce247-406">This is another reason why it's important to analyze possible failure points during the design phase.</span></span> <span data-ttu-id="ce247-407">該分析的結果應該輸入您的測試計劃。</span><span class="sxs-lookup"><span data-stu-id="ce247-407">The results of that analysis should be inputs into your test plan.</span></span>

<span data-ttu-id="ce247-408">**負載測試**.</span><span class="sxs-lookup"><span data-stu-id="ce247-408">**Load testing**.</span></span> <span data-ttu-id="ce247-409">使用諸如 [Visual Studio Team Services][vsts] 或 [Apache JMeter][jmeter] 等工具負載測試應用程式。</span><span class="sxs-lookup"><span data-stu-id="ce247-409">Load test the application using a tool such as [Visual Studio Team Services][vsts] or [Apache JMeter][jmeter].</span></span> <span data-ttu-id="ce247-410">負載測試對於識別只有在負載下發生的失敗而言十分重要，例如後端資料庫遭灌爆或服務節流。</span><span class="sxs-lookup"><span data-stu-id="ce247-410">Load testing is crucial for identifying failures that only happen under load, such as the backend database being overwhelmed or service throttling.</span></span> <span data-ttu-id="ce247-411">使用生產資料或盡可能最接近生產資料的綜合資料，針對尖峰負載進行測試。</span><span class="sxs-lookup"><span data-stu-id="ce247-411">Test for peak load, using production data or synthetic data that is as close to production data as possible.</span></span> <span data-ttu-id="ce247-412">目標是查看應用程式在真實世界情況下的運作方式。</span><span class="sxs-lookup"><span data-stu-id="ce247-412">The goal is to see how the application behaves under real-world conditions.</span></span>   

## <a name="resilient-deployment"></a><span data-ttu-id="ce247-413">復原部署</span><span class="sxs-lookup"><span data-stu-id="ce247-413">Resilient deployment</span></span>
<span data-ttu-id="ce247-414">一旦應用程式部署到生產環境後，更新就會成為可能的錯誤來源。</span><span class="sxs-lookup"><span data-stu-id="ce247-414">Once an application is deployed to production, updates are a possible source of errors.</span></span> <span data-ttu-id="ce247-415">在最糟的情況下，不良的更新可能會導致停機時間。</span><span class="sxs-lookup"><span data-stu-id="ce247-415">In the worst case, a bad update can cause downtime.</span></span> <span data-ttu-id="ce247-416">若要避免這個問題，部署程序必須是可預測且可重複。</span><span class="sxs-lookup"><span data-stu-id="ce247-416">To avoid this, the deployment process must be predictable and repeatable.</span></span> <span data-ttu-id="ce247-417">部署包括佈建 Azure 資源、部署應用程式的程式碼，以及套用組態集。</span><span class="sxs-lookup"><span data-stu-id="ce247-417">Deployment includes provisioning Azure resources, deploying application code, and applying configuration settings.</span></span> <span data-ttu-id="ce247-418">更新可能需要這三個全部或一個子集。</span><span class="sxs-lookup"><span data-stu-id="ce247-418">An update may involve all three, or a subset.</span></span> 

<span data-ttu-id="ce247-419">重點是手動部署容易出錯。</span><span class="sxs-lookup"><span data-stu-id="ce247-419">The crucial point is that manual deployments are prone to error.</span></span> <span data-ttu-id="ce247-420">因此，建議具有自動化的等冪程序，您可以視需要執行，並在失敗時重新執行。</span><span class="sxs-lookup"><span data-stu-id="ce247-420">Therefore, it's recommended to have an automated, idempotent process that you can run on demand, and re-run if something fails.</span></span> 

* <span data-ttu-id="ce247-421">您可以使用 Resource Manager 範本自動佈建 Azure 資源。</span><span class="sxs-lookup"><span data-stu-id="ce247-421">Use Resource Manager templates to automate provisioning of Azure resources.</span></span>
* <span data-ttu-id="ce247-422">使用 [Azure 自動化期望狀態設定][dsc] (DSC) 來設定 VM。</span><span class="sxs-lookup"><span data-stu-id="ce247-422">Use [Azure Automation Desired State Configuration][dsc] (DSC) to configure VMs.</span></span>
* <span data-ttu-id="ce247-423">使用應用程式程式碼的自動部署程序。</span><span class="sxs-lookup"><span data-stu-id="ce247-423">Use an automated deployment process for application code.</span></span>

<span data-ttu-id="ce247-424">與復原部署相關的兩個概念是「基礎結構即程式碼」和「不可變的基礎結構」。</span><span class="sxs-lookup"><span data-stu-id="ce247-424">Two concepts related to resilient deployment are *infrastructure as code* and *immutable infrastructure*.</span></span>

* <span data-ttu-id="ce247-425">**基礎結構即程式碼**是使用程式碼來佈建及設定基礎結構的做法。</span><span class="sxs-lookup"><span data-stu-id="ce247-425">**Infrastructure as code** is the practice of using code to provision and configure infrastructure.</span></span> <span data-ttu-id="ce247-426">基礎結構即程式碼可以使用宣告式方法或命令式方法 (或兩者的組合)。</span><span class="sxs-lookup"><span data-stu-id="ce247-426">Infrastructure as code may use a declarative approach or an imperative approach (or a combination of both).</span></span> <span data-ttu-id="ce247-427">Resource Manager 範本便是宣告式方法的其中一個範例。</span><span class="sxs-lookup"><span data-stu-id="ce247-427">Resource Manager templates are an example of a declarative approach.</span></span> <span data-ttu-id="ce247-428">PowerShell 指令碼是命令式方法的其中一個範例。</span><span class="sxs-lookup"><span data-stu-id="ce247-428">PowerShell scripts are an example of an imperative approach.</span></span>
* <span data-ttu-id="ce247-429">**不可變的基礎結構**是您在將基礎結構部署至生產環境之後不應該修改的準則。</span><span class="sxs-lookup"><span data-stu-id="ce247-429">**Immutable infrastructure** is the principle that you shouldn’t modify infrastructure after it’s deployed to production.</span></span> <span data-ttu-id="ce247-430">否則，就可以進入已套用臨機操作變更的狀態，因此很難完全了解變更的內容，而且難以理解系統。</span><span class="sxs-lookup"><span data-stu-id="ce247-430">Otherwise, you can get into a state where ad hoc changes have been applied, so it's hard to know exactly what changed, and hard to reason about the system.</span></span> 

<span data-ttu-id="ce247-431">另一個問題是如何推出應用程式更新。</span><span class="sxs-lookup"><span data-stu-id="ce247-431">Another question is how to roll out an application update.</span></span> <span data-ttu-id="ce247-432">建議使用諸如藍綠部署或 Canary 版本等技術，可透過高度控制的方式，將錯誤部署可能造成的影響降至最低。</span><span class="sxs-lookup"><span data-stu-id="ce247-432">We recommend techniques such as blue-green deployment or canary releases, which push updates in highly controlled way to minimize possible impacts from a bad deployment.</span></span>

* <span data-ttu-id="ce247-433">[藍綠部署][blue-green]是將更新部署到獨立於即時應用程式之生產環境中的一種技術。</span><span class="sxs-lookup"><span data-stu-id="ce247-433">[Blue-green deployment][blue-green] is a technique where an update is deployed into a production environment separate from the live application.</span></span> <span data-ttu-id="ce247-434">驗證部署之後，將流量路由切換為更新的版本。</span><span class="sxs-lookup"><span data-stu-id="ce247-434">After you validate the deployment, switch the traffic routing to the updated version.</span></span> <span data-ttu-id="ce247-435">例如，Azure App Service Web Apps 可利用預備位置來加以啟用。</span><span class="sxs-lookup"><span data-stu-id="ce247-435">For example, Azure App Service Web Apps enables this with staging slots.</span></span>
* <span data-ttu-id="ce247-436">[Canary 版本][canary-release]類似於藍綠部署。</span><span class="sxs-lookup"><span data-stu-id="ce247-436">[Canary releases][canary-release] are similar to blue-green deployments.</span></span> <span data-ttu-id="ce247-437">您不需切換更新版本的所有流量，而是將更新發行至一小部分的使用者，方法是將部分的流量路由到新的部署。</span><span class="sxs-lookup"><span data-stu-id="ce247-437">Instead of switching all traffic to the updated version, you roll out the update to a small percentage of users, by routing a portion of the traffic to the new deployment.</span></span> <span data-ttu-id="ce247-438">如果有問題，請退出並還原成舊的部署。</span><span class="sxs-lookup"><span data-stu-id="ce247-438">If there is a problem, back off and revert to the old deployment.</span></span> <span data-ttu-id="ce247-439">否則，將更多流量路由至新的版本，直到它取得 100% 的流量。</span><span class="sxs-lookup"><span data-stu-id="ce247-439">Otherwise, route more of the traffic to the new version, until it gets 100% of the traffic.</span></span>

<span data-ttu-id="ce247-440">不論您採取的方法為何，萬一新的版本無法正常運作，請確定您可以復原至最後一個已知的良好部署。</span><span class="sxs-lookup"><span data-stu-id="ce247-440">Whatever approach you take, make sure that you can roll back to the last-known-good deployment, in case the new version is not functioning.</span></span> <span data-ttu-id="ce247-441">此外，如果發生錯誤，應用程式記錄必須指出是哪一個版本造成錯誤。</span><span class="sxs-lookup"><span data-stu-id="ce247-441">Also, if errors occur, the application logs must indicate which version caused the error.</span></span> 

## <a name="monitoring-and-diagnostics"></a><span data-ttu-id="ce247-442">監視和診斷</span><span class="sxs-lookup"><span data-stu-id="ce247-442">Monitoring and diagnostics</span></span>
<span data-ttu-id="ce247-443">監視和診斷對於復原非常重要。</span><span class="sxs-lookup"><span data-stu-id="ce247-443">Monitoring and diagnostics are crucial for resiliency.</span></span> <span data-ttu-id="ce247-444">如果發生失敗，您必須知道該失敗，且需要深入了解失敗的原因。</span><span class="sxs-lookup"><span data-stu-id="ce247-444">If something fails, you need to know that it failed, and you need insights into the cause of the failure.</span></span> 

<span data-ttu-id="ce247-445">監視大規模分散式系統會是重大挑戰。</span><span class="sxs-lookup"><span data-stu-id="ce247-445">Monitoring a large-scale distributed system poses a significant challenge.</span></span> <span data-ttu-id="ce247-446">試想在數十個 VM 上執行的應用程式 &mdash; 以一次一個的方式登入每個 VM，然後查看記錄檔並嘗試針對問題進行疑難排解，這並不實際。</span><span class="sxs-lookup"><span data-stu-id="ce247-446">Think about an application that runs on a few dozen VMs &mdash; it's not practical to log into each VM, one at a time, and look through log files, trying to troubleshoot a problem.</span></span> <span data-ttu-id="ce247-447">此外，VM 執行個體的數目可能不是靜態的。</span><span class="sxs-lookup"><span data-stu-id="ce247-447">Moreover, the number of VM instances is probably not static.</span></span> <span data-ttu-id="ce247-448">VM 會隨著應用程式相應縮小和相應放大而新增及移除，執行個體偶爾可能會失敗，且需要重新佈健。</span><span class="sxs-lookup"><span data-stu-id="ce247-448">VMs get added and removed as the application scales in and out, and occasionally an instance may fail and need to be reprovisioned.</span></span> <span data-ttu-id="ce247-449">此外，典型的雲端應用程式可能會使用多個資料存放區 (Azure 儲存體、SQL Database、Cosmos DB、Redis 快取)，且單一使用者動作可能會跨越多個子系統。</span><span class="sxs-lookup"><span data-stu-id="ce247-449">In addition, a typical cloud application might use multiple data stores (Azure storage, SQL Database, Cosmos DB, Redis cache), and a single user action may span multiple subsystems.</span></span> 

<span data-ttu-id="ce247-450">您可以將監視和診斷程序視為具有數個不同階段的管線：</span><span class="sxs-lookup"><span data-stu-id="ce247-450">You can think of the monitoring and diagnostics process as a pipeline with several distinct stages:</span></span>

![複合 SLA](./images/monitoring.png)

* <span data-ttu-id="ce247-452">**檢測**。</span><span class="sxs-lookup"><span data-stu-id="ce247-452">**Instrumentation**.</span></span> <span data-ttu-id="ce247-453">監視和診斷的未經處理資料會來自各種不同的來源，包括應用程式記錄、web 伺服器記錄、OS 效能計數器、資料庫記錄，以及 Azure 平台內建的診斷。</span><span class="sxs-lookup"><span data-stu-id="ce247-453">The raw data for monitoring and diagnostics comes from a variety of sources, including application logs, web server logs, OS performance counters, database logs, and diagnostics built into the Azure platform.</span></span> <span data-ttu-id="ce247-454">大部分的 Azure 服務都具有診斷功能，可讓您判斷問題的原因。</span><span class="sxs-lookup"><span data-stu-id="ce247-454">Most Azure services have a diagnostics feature that you can use to determine the cause of problems.</span></span>
* <span data-ttu-id="ce247-455">**收集和儲存**。</span><span class="sxs-lookup"><span data-stu-id="ce247-455">**Collection and storage**.</span></span> <span data-ttu-id="ce247-456">未經處理的檢測資料可以保留在各種不同的位置以及使用各種格式 (例如，應用程式追蹤記錄、IIS 記錄、效能計數器)。</span><span class="sxs-lookup"><span data-stu-id="ce247-456">Raw instrumentation data can be held in various locations and with various formats (e.g., application trace logs, IIS logs, performance counters).</span></span> <span data-ttu-id="ce247-457">這些不同的來源會收集、彙總，並放入可靠的儲存體。</span><span class="sxs-lookup"><span data-stu-id="ce247-457">These disparate sources are collected, consolidated, and put into reliable storage.</span></span>
* <span data-ttu-id="ce247-458">**分析及診斷**。</span><span class="sxs-lookup"><span data-stu-id="ce247-458">**Analysis and diagnosis**.</span></span> <span data-ttu-id="ce247-459">資料在彙總之後，可以加以分析來針對問題進行疑難排解，並提供應用程式健康情況的整體檢視。</span><span class="sxs-lookup"><span data-stu-id="ce247-459">After the data is consolidated, it can be analyzed to troubleshoot issues and provide an overall view of application health.</span></span>
* <span data-ttu-id="ce247-460">**視覺效果和警示**。</span><span class="sxs-lookup"><span data-stu-id="ce247-460">**Visualization and alerts**.</span></span> <span data-ttu-id="ce247-461">在這個階段，遙測資料所呈現的方式，能讓操作員快速注意到問題和趨勢。</span><span class="sxs-lookup"><span data-stu-id="ce247-461">In this stage, telemetry data is presented in such a way that an operator can quickly notice problems or trends.</span></span> <span data-ttu-id="ce247-462">範例包括儀表板或電子郵件警示。</span><span class="sxs-lookup"><span data-stu-id="ce247-462">Example include dashboards or email alerts.</span></span>  

<span data-ttu-id="ce247-463">監視與失敗偵測不相同。</span><span class="sxs-lookup"><span data-stu-id="ce247-463">Monitoring is not the same as failure detection.</span></span> <span data-ttu-id="ce247-464">例如，您的應用程式可能會偵測到暫時性錯誤然後重試，導致無停機時間。</span><span class="sxs-lookup"><span data-stu-id="ce247-464">For example, your application might detect a transient error and retry, resulting in no downtime.</span></span> <span data-ttu-id="ce247-465">但是，它應該也記錄重試作業，好讓您可以監視錯誤率，以取得整體的應用程式健康情況。</span><span class="sxs-lookup"><span data-stu-id="ce247-465">But it should also log the retry operation, so that you can monitor the error rate, in order to get an overall picture of application health.</span></span> 

<span data-ttu-id="ce247-466">應用程式記錄是診斷資料的重要來源。</span><span class="sxs-lookup"><span data-stu-id="ce247-466">Application logs are an important source of diagnostics data.</span></span> <span data-ttu-id="ce247-467">應用程式記錄的最佳做法包括：</span><span class="sxs-lookup"><span data-stu-id="ce247-467">Best practices for application logging include:</span></span>

* <span data-ttu-id="ce247-468">登入生產環境。</span><span class="sxs-lookup"><span data-stu-id="ce247-468">Log in production.</span></span> <span data-ttu-id="ce247-469">否則，您在最需要的部分就無法深入解析。</span><span class="sxs-lookup"><span data-stu-id="ce247-469">Otherwise, you lose insight where you need it most.</span></span>
* <span data-ttu-id="ce247-470">記錄服務界限上的事件。</span><span class="sxs-lookup"><span data-stu-id="ce247-470">Log events at service boundaries.</span></span> <span data-ttu-id="ce247-471">包含流過服務界限的相互關聯識別碼。</span><span class="sxs-lookup"><span data-stu-id="ce247-471">Include a correlation ID that flows across service boundaries.</span></span> <span data-ttu-id="ce247-472">如果交易流經多個服務且其中一個失敗，相互關聯識別碼可協助您準確地確定交易失敗的原因。</span><span class="sxs-lookup"><span data-stu-id="ce247-472">If a transaction flows through multiple services and one of them fails, the correlation ID will help you pinpoint why the transaction failed.</span></span>
* <span data-ttu-id="ce247-473">使用語意記錄，也稱為結構化記錄。</span><span class="sxs-lookup"><span data-stu-id="ce247-473">Use semantic logging, also known as structured logging.</span></span> <span data-ttu-id="ce247-474">非結構化記錄會讓您難以將雲端規模所需的記錄資料之耗用量及分析自動化。</span><span class="sxs-lookup"><span data-stu-id="ce247-474">Unstructured logs make it hard to automate the consumption and analysis of the log data, which is needed at cloud scale.</span></span>
* <span data-ttu-id="ce247-475">使用非同步記錄。</span><span class="sxs-lookup"><span data-stu-id="ce247-475">Use asynchronous logging.</span></span> <span data-ttu-id="ce247-476">否則，記錄系統本身會造成要求備份而導致應用程式失敗，因為它們在等候寫入記錄事件時會予以封鎖。</span><span class="sxs-lookup"><span data-stu-id="ce247-476">Otherwise, the logging system itself can cause the application to fail by causing requests to back up, as they block while waiting to write a logging event.</span></span>
* <span data-ttu-id="ce247-477">應用程式記錄與稽核不同。</span><span class="sxs-lookup"><span data-stu-id="ce247-477">Application logging is not the same as auditing.</span></span> <span data-ttu-id="ce247-478">可就合規性或法規原因完成稽核。</span><span class="sxs-lookup"><span data-stu-id="ce247-478">Auditing may be done for compliance or regulatory reasons.</span></span> <span data-ttu-id="ce247-479">因此，稽核資料列必須完成，且不得在處理交易時卸除任何稽核資料列。</span><span class="sxs-lookup"><span data-stu-id="ce247-479">As such, audit records must be complete, and it's not acceptible to drop any while processing transactions.</span></span> <span data-ttu-id="ce247-480">如果應用程式需要稽核，這應該與診斷記錄有所區隔。</span><span class="sxs-lookup"><span data-stu-id="ce247-480">If an application requires auditing, this should be kept separate from diagnostics logging.</span></span> 

<span data-ttu-id="ce247-481">如需監視和診斷的詳細資訊，請參閱[監視和診斷指引][monitoring-guidance]。</span><span class="sxs-lookup"><span data-stu-id="ce247-481">For more information about monitoring and diagnostics, see [Monitoring and diagnostics guidance][monitoring-guidance].</span></span>

## <a name="manual-failure-responses"></a><span data-ttu-id="ce247-482">手動失敗回應</span><span class="sxs-lookup"><span data-stu-id="ce247-482">Manual failure responses</span></span>
<span data-ttu-id="ce247-483">前幾節著重於自動化復原策略，對於高可用性是很重要的。</span><span class="sxs-lookup"><span data-stu-id="ce247-483">Previous sections have focused on automated recovery strategies, which are critical for high availability.</span></span> <span data-ttu-id="ce247-484">不過，有時需要手動介入。</span><span class="sxs-lookup"><span data-stu-id="ce247-484">However, sometimes manual intervention is needed.</span></span>

* <span data-ttu-id="ce247-485">**警示**。</span><span class="sxs-lookup"><span data-stu-id="ce247-485">**Alerts**.</span></span> <span data-ttu-id="ce247-486">監視您的應用程式，注意可能需要主動介入的跡象。</span><span class="sxs-lookup"><span data-stu-id="ce247-486">Monitor your application for warning signs that may require proactive intervention.</span></span> <span data-ttu-id="ce247-487">例如，如果您看見 SQL Database 或 Cosmos DB 一致地節流您的應用程式，可能就需要增加您的資料庫容量或最佳化查詢。</span><span class="sxs-lookup"><span data-stu-id="ce247-487">For example, if you see that SQL Database or Cosmos DB consistently throttles your application, you might need to increase your database capacity or optimize your queries.</span></span> <span data-ttu-id="ce247-488">在此範例中，即使應用程式可能會以透明的方式節流錯誤，您的遙測仍應發出警示，讓您可以追蹤。</span><span class="sxs-lookup"><span data-stu-id="ce247-488">In this example, even though the application might handle the throttling errors transparently, your telemetry should still raise an alert so that you can follow up.</span></span>  
* <span data-ttu-id="ce247-489">**手動容錯移轉**。</span><span class="sxs-lookup"><span data-stu-id="ce247-489">**Manual failover**.</span></span> <span data-ttu-id="ce247-490">某些系統無法自動容錯移轉，而需要手動容錯移轉。</span><span class="sxs-lookup"><span data-stu-id="ce247-490">Some systems cannot fail over automatically and require a manual failover.</span></span> 
* <span data-ttu-id="ce247-491">**作業整備測試**。</span><span class="sxs-lookup"><span data-stu-id="ce247-491">**Operational readiness testing**.</span></span> <span data-ttu-id="ce247-492">如果您的應用程式容錯移轉到次要地區，就應該在容錯回復到主要區域之前，執行作業整備測試。</span><span class="sxs-lookup"><span data-stu-id="ce247-492">If your application fails over to a secondary region, you should perform an operational readiness test before you fail back to the primary region.</span></span> <span data-ttu-id="ce247-493">測試應該確認主要區域健康情況，且就緒可再次接收流量。</span><span class="sxs-lookup"><span data-stu-id="ce247-493">The test should verify that the primary region is healthy and ready to receive traffic again.</span></span>
* <span data-ttu-id="ce247-494">**資料一致性檢查**。</span><span class="sxs-lookup"><span data-stu-id="ce247-494">**Data consistency check**.</span></span> <span data-ttu-id="ce247-495">如果失敗發生在資料存放區中，當存放區再次可用時，可能會有資料不一致的情況，特別是在已複寫資料時。</span><span class="sxs-lookup"><span data-stu-id="ce247-495">If a failure happens in a data store, there may be data inconsistencies when the store becomes available again, especially if the data was replicated.</span></span> 
* <span data-ttu-id="ce247-496">**從備份還原**。</span><span class="sxs-lookup"><span data-stu-id="ce247-496">**Restoring from backup**.</span></span> <span data-ttu-id="ce247-497">例如，如果 SQL Database 遇到區域性中斷，您可以從最新的備份異地還原資料庫。</span><span class="sxs-lookup"><span data-stu-id="ce247-497">For example, if SQL Database experiences a regional outage, you can geo-restore the database from the latest backup.</span></span>

<span data-ttu-id="ce247-498">記錄並測試災害復原計畫。</span><span class="sxs-lookup"><span data-stu-id="ce247-498">Document and test your disaster recovery plan.</span></span> <span data-ttu-id="ce247-499">評估應用程式失敗的商務影響。</span><span class="sxs-lookup"><span data-stu-id="ce247-499">Evaluate the business impact of application failures.</span></span> <span data-ttu-id="ce247-500">盡可能自動化程序並記錄任何手動步驟，例如手動容錯移轉或從備份還原資料。</span><span class="sxs-lookup"><span data-stu-id="ce247-500">Automate the process as much as possible, and document any manual steps, such as manual failover or data restoration from backups.</span></span> <span data-ttu-id="ce247-501">定期測試您的災害復原程序來驗證和改善計劃。</span><span class="sxs-lookup"><span data-stu-id="ce247-501">Regularly test your disaster recovery process to validate and improve the plan.</span></span> 

## <a name="summary"></a><span data-ttu-id="ce247-502">摘要</span><span class="sxs-lookup"><span data-stu-id="ce247-502">Summary</span></span>
<span data-ttu-id="ce247-503">本文以整體的觀點討論復原，強調一些雲端的唯一挑戰。</span><span class="sxs-lookup"><span data-stu-id="ce247-503">This article discussed resiliency from a holistic perspective, emphasizing some of the unique challenges of the cloud.</span></span> <span data-ttu-id="ce247-504">這些包括雲端運算的散發本質、使用商用硬體，以及暫時性網路錯誤的存在。</span><span class="sxs-lookup"><span data-stu-id="ce247-504">These include the distributed nature of cloud computing, the use of commodity hardware, and the presence of transient network faults.</span></span>

<span data-ttu-id="ce247-505">以下是本文強調的幾個重點：</span><span class="sxs-lookup"><span data-stu-id="ce247-505">Here are the major points to take away from this article:</span></span>

* <span data-ttu-id="ce247-506">復原會帶來較高的可用性，且從失敗中復原的平均時間較少。</span><span class="sxs-lookup"><span data-stu-id="ce247-506">Resiliency leads to higher availability, and lower mean time to recover from failures.</span></span> 
* <span data-ttu-id="ce247-507">在雲端中達到復原需要傳統內部部署解決方案中一組不同的技術。</span><span class="sxs-lookup"><span data-stu-id="ce247-507">Achieving resiliency in the cloud requires a different set of techniques from traditional on-premises solutions.</span></span> 
* <span data-ttu-id="ce247-508">復原不會意外發生。</span><span class="sxs-lookup"><span data-stu-id="ce247-508">Resiliency does not happen by accident.</span></span> <span data-ttu-id="ce247-509">它必須從頭設計並內建。</span><span class="sxs-lookup"><span data-stu-id="ce247-509">It must be designed and built in from the start.</span></span>
* <span data-ttu-id="ce247-510">復原會觸及應用程式生命週期的每個部分，從計劃與撰寫程式碼到作業。</span><span class="sxs-lookup"><span data-stu-id="ce247-510">Resiliency touches every part of the application lifecycle, from planning and coding to operations.</span></span>
* <span data-ttu-id="ce247-511">測試與監視！</span><span class="sxs-lookup"><span data-stu-id="ce247-511">Test and monitor!</span></span>


<!-- links -->

[blue-green]: http://martinfowler.com/bliki/BlueGreenDeployment.html
[canary-release]: http://martinfowler.com/bliki/CanaryRelease.html
[circuit-breaker-pattern]: https://msdn.microsoft.com/library/dn589784.aspx
[compensating-transaction-pattern]: https://msdn.microsoft.com/library/dn589804.aspx
[containers]: https://en.wikipedia.org/wiki/Operating-system-level_virtualization
[dsc]: /azure/automation/automation-dsc-overview
[contingency-planning-guide]: http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-34r1.pdf
[fma]: failure-mode-analysis.md
[hystrix]: http://techblog.netflix.com/2012/11/hystrix.html
[jmeter]: http://jmeter.apache.org/
[load-leveling-pattern]: ../patterns/queue-based-load-leveling.md
[monitoring-guidance]: ../best-practices/monitoring.md
[ra-basic-web]: ../reference-architectures/app-service-web-app/basic-web-app.md
[ra-multi-vm]: ../reference-architectures/virtual-machines-windows/multi-vm.md
[checklist]: ../checklist/resiliency.md
[retry-pattern]: ../patterns/retry.md
[retry-service-specific guidance]: ../best-practices/retry-service-specific.md
[sla]: https://azure.microsoft.com/support/legal/sla/
[throttling-pattern]: ../patterns/throttling.md
[tm]: https://azure.microsoft.com/services/traffic-manager/
[tm-failover]: /azure/traffic-manager/traffic-manager-monitoring
[tm-sla]: https://azure.microsoft.com/support/legal/sla/traffic-manager/v1_0/
[vsts]: https://www.visualstudio.com/features/vso-cloud-load-testing-vs.aspx
