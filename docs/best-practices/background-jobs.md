---
title: "背景作業指引"
description: "獨立於使用者介面之外執行的背景工作指引。"
author: dragon119
ms.date: 05/24/2017
pnp.series.title: Best Practices
ms.openlocfilehash: d8c1d4dfe12208b72fd6991def805f90a830b5f0
ms.sourcegitcommit: a8453c4bc7c870fa1a12bb3c02e3b310db87530c
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 12/29/2017
---
# <a name="background-jobs"></a><span data-ttu-id="2369f-103">背景作業作業</span><span class="sxs-lookup"><span data-stu-id="2369f-103">Background jobs</span></span>
[!INCLUDE [header](../_includes/header.md)]

<span data-ttu-id="2369f-104">許多類型的應用程式需要執行與使用者介面 (UI) 無關的背景工作。</span><span class="sxs-lookup"><span data-stu-id="2369f-104">Many types of applications require background tasks that run independently of the user interface (UI).</span></span> <span data-ttu-id="2369f-105">範例包括批次作業、大量處理的工作，以及長時間執行的處理序，例如工作流程。</span><span class="sxs-lookup"><span data-stu-id="2369f-105">Examples include batch jobs, intensive processing tasks, and long-running processes such as workflows.</span></span> <span data-ttu-id="2369f-106">背景作業可以在不需要和使用者互動的情形下執行。應用程式可以啟動此作業，然後繼續處理使用者的互動式要求。</span><span class="sxs-lookup"><span data-stu-id="2369f-106">Background jobs can be executed without requiring user interaction--the application can start the job and then continue to process interactive requests from users.</span></span> <span data-ttu-id="2369f-107">這有助於減少應用程式 UI 的負載，如此可以改善可用性，並降低互動式回應時間。</span><span class="sxs-lookup"><span data-stu-id="2369f-107">This can help to minimize the load on the application UI, which can improve availability and reduce interactive response times.</span></span>

<span data-ttu-id="2369f-108">比方說，如果產生使用者上傳的影像縮圖時需要使用應用程式，可將它作為背景作業執行，並在完成時將縮圖儲存到儲存體，使用者不需要等待處理序完成。</span><span class="sxs-lookup"><span data-stu-id="2369f-108">For example, if an application is required to generate thumbnails of images that are uploaded by users, it can do this as a background job and save the thumbnail to storage when it is complete--without the user needing to wait for the process to be completed.</span></span> <span data-ttu-id="2369f-109">同樣地，下訂單的使用者可以起始背景工作流程來處理訂單，而同時 UI 能讓使用者繼續瀏覽 Web 應用程式。</span><span class="sxs-lookup"><span data-stu-id="2369f-109">In the same way, a user placing an order can initiate a background workflow that processes the order, while the UI allows the user to continue browsing the web app.</span></span> <span data-ttu-id="2369f-110">當背景作業完成時，可更新儲存的訂單資料，並將電子郵件傳送給確認訂單的使用者。</span><span class="sxs-lookup"><span data-stu-id="2369f-110">When the background job is complete, it can update the stored orders data and send an email to the user that confirms the order.</span></span>

<span data-ttu-id="2369f-111">當您考慮是否將工作作為背景作業執行時，主要的準則是：是否可以執行工作而不需要使用者互動，且不需要讓 UI 等待作業完成。</span><span class="sxs-lookup"><span data-stu-id="2369f-111">When you consider whether to implement a task as a background job, the main criteria is whether the task can run without user interaction and without the UI needing to wait for the job to be completed.</span></span> <span data-ttu-id="2369f-112">需要讓使用者或 UI 等待完成的工作，可能不適合作為背景作業。</span><span class="sxs-lookup"><span data-stu-id="2369f-112">Tasks that require the user or the UI to wait while they are completed might not be appropriate as background jobs.</span></span>

## <a name="types-of-background-jobs"></a><span data-ttu-id="2369f-113">背景工作類型</span><span class="sxs-lookup"><span data-stu-id="2369f-113">Types of background jobs</span></span>
<span data-ttu-id="2369f-114">背景作業通常具有下列一個或多個的作業類型：</span><span class="sxs-lookup"><span data-stu-id="2369f-114">Background jobs typically include one or more of the following types of jobs:</span></span>

* <span data-ttu-id="2369f-115">需要大量 CPU 處理的作業，例如數學計算或結構化模型分析。</span><span class="sxs-lookup"><span data-stu-id="2369f-115">CPU-intensive jobs, such as mathematical calculations or structural model analysis.</span></span>
* <span data-ttu-id="2369f-116">進行大量 I/O 動作的作業，例如執行一系列的儲存體交易或索引檔。</span><span class="sxs-lookup"><span data-stu-id="2369f-116">I/O-intensive jobs, such as executing a series of storage transactions or indexing files.</span></span>
* <span data-ttu-id="2369f-117">如夜間資料更新或排程處理的批次作業。</span><span class="sxs-lookup"><span data-stu-id="2369f-117">Batch jobs, such as nightly data updates or scheduled processing.</span></span>
* <span data-ttu-id="2369f-118">長時間執行的工作流程，例如訂單履行或佈建服務和系統。</span><span class="sxs-lookup"><span data-stu-id="2369f-118">Long-running workflows, such as order fulfillment, or provisioning services and systems.</span></span>
* <span data-ttu-id="2369f-119">其中的工作移交至更安全的位置，以便進行處理的敏感性資料處理序。</span><span class="sxs-lookup"><span data-stu-id="2369f-119">Sensitive-data processing where the task is handed off to a more secure location for processing.</span></span> <span data-ttu-id="2369f-120">例如，您可能不想在 Web 應用程式中處理敏感性資料。</span><span class="sxs-lookup"><span data-stu-id="2369f-120">For example, you might not want to process sensitive data within a web app.</span></span> <span data-ttu-id="2369f-121">相反的，您可以改用如 [閘道管理員](http://msdn.microsoft.com/library/dn589793.aspx) 的模式將資料傳送到隔離的背景處理序中，且該處理序擁有受保護儲存體的存取權。</span><span class="sxs-lookup"><span data-stu-id="2369f-121">Instead, you might use a pattern such as [Gatekeeper](http://msdn.microsoft.com/library/dn589793.aspx) to transfer the data to an isolated background process that has access to protected storage.</span></span>

## <a name="triggers"></a><span data-ttu-id="2369f-122">觸發程序</span><span class="sxs-lookup"><span data-stu-id="2369f-122">Triggers</span></span>
<span data-ttu-id="2369f-123">可利用數個不同的方式啟動背景工作。</span><span class="sxs-lookup"><span data-stu-id="2369f-123">Background jobs can be initiated in several different ways.</span></span> <span data-ttu-id="2369f-124">它們全都屬於下列類別之一：</span><span class="sxs-lookup"><span data-stu-id="2369f-124">They fall into one of the following categories:</span></span>

* <span data-ttu-id="2369f-125">[**事件驅動觸發程序**](#event-driven-triggers)。</span><span class="sxs-lookup"><span data-stu-id="2369f-125">[**Event-driven triggers**](#event-driven-triggers).</span></span> <span data-ttu-id="2369f-126">工作會啟動以回應事件，通常是使用者或工作流程中的步驟所採取的動作。</span><span class="sxs-lookup"><span data-stu-id="2369f-126">The task is started in response to an event, typically an action taken by a user or a step in a workflow.</span></span>
* <span data-ttu-id="2369f-127">[**排程驅動觸發程序**](#schedule-driven-triggers)。</span><span class="sxs-lookup"><span data-stu-id="2369f-127">[**Schedule-driven triggers**](#schedule-driven-triggers).</span></span> <span data-ttu-id="2369f-128">根據計時器在排程上叫用的工作。</span><span class="sxs-lookup"><span data-stu-id="2369f-128">The task is invoked on a schedule based on a timer.</span></span> <span data-ttu-id="2369f-129">這可能是重複執行的排程，或指定在稍後執行的一次性叫用。</span><span class="sxs-lookup"><span data-stu-id="2369f-129">This might be a recurring schedule or a one-off invocation that is specified for a later time.</span></span>

### <a name="event-driven-triggers"></a><span data-ttu-id="2369f-130">事件驅動觸發程序</span><span class="sxs-lookup"><span data-stu-id="2369f-130">Event-driven triggers</span></span>
<span data-ttu-id="2369f-131">事件驅動叫用會使用觸發程序來啟動背景工作。</span><span class="sxs-lookup"><span data-stu-id="2369f-131">Event-driven invocation uses a trigger to start the background task.</span></span> <span data-ttu-id="2369f-132">使用事件驅動觸發程序的範例包括：</span><span class="sxs-lookup"><span data-stu-id="2369f-132">Examples of using event-driven triggers include:</span></span>

* <span data-ttu-id="2369f-133">UI 或另一項工作可將訊息放在佇列中。</span><span class="sxs-lookup"><span data-stu-id="2369f-133">The UI or another job places a message in a queue.</span></span> <span data-ttu-id="2369f-134">訊息包含已經執行的動作相關資料，例如下訂單的使用者。</span><span class="sxs-lookup"><span data-stu-id="2369f-134">The message contains data about an action that has taken place, such as the user placing an order.</span></span> <span data-ttu-id="2369f-135">背景工作會在此佇列上接聽，並偵測新訊息到達。</span><span class="sxs-lookup"><span data-stu-id="2369f-135">The background task listens on this queue and detects the arrival of a new message.</span></span> <span data-ttu-id="2369f-136">它會讀取訊息，並將其中的資料做為背景工作的輸入。</span><span class="sxs-lookup"><span data-stu-id="2369f-136">It reads the message and uses the data in it as the input to the background job.</span></span>
* <span data-ttu-id="2369f-137">UI 或另一項工作會儲存或更新儲存體中的值。</span><span class="sxs-lookup"><span data-stu-id="2369f-137">The UI or another job saves or updates a value in storage.</span></span> <span data-ttu-id="2369f-138">背景工作監視儲存體並偵測變更。</span><span class="sxs-lookup"><span data-stu-id="2369f-138">The background task monitors the storage and detects changes.</span></span> <span data-ttu-id="2369f-139">它會讀取資料，並使用它做為背景工作的輸入。</span><span class="sxs-lookup"><span data-stu-id="2369f-139">It reads the data and uses it as the input to the background job.</span></span>
* <span data-ttu-id="2369f-140">UI 或另一項作業會要求端點 (例如 HTTPS URI)，或公開為 Web 服務的 API。</span><span class="sxs-lookup"><span data-stu-id="2369f-140">The UI or another job makes a request to an endpoint, such as an HTTPS URI, or an API that is exposed as a web service.</span></span> <span data-ttu-id="2369f-141">它會在要求的過程中，傳遞完成背景工作所需的資料。</span><span class="sxs-lookup"><span data-stu-id="2369f-141">It passes the data that is required to complete the background task as part of the request.</span></span> <span data-ttu-id="2369f-142">端點或 Web 服務會叫用背景工作，將資料做為其輸入。</span><span class="sxs-lookup"><span data-stu-id="2369f-142">The endpoint or web service invokes the background task, which uses the data as its input.</span></span>

<span data-ttu-id="2369f-143">適合事件驅動叫用的工作一般範例包括影像處理、工作流程、將資訊傳送至遠端服務、傳送電子郵件訊息、在多組織用戶共享的應用程式中佈建新使用者等等。</span><span class="sxs-lookup"><span data-stu-id="2369f-143">Typical examples of tasks that are suited to event-driven invocation include image processing, workflows, sending information to remote services, sending email messages, and provisioning new users in multitenant applications.</span></span>

### <a name="schedule-driven-triggers"></a><span data-ttu-id="2369f-144">排程驅動觸發程序</span><span class="sxs-lookup"><span data-stu-id="2369f-144">Schedule-driven triggers</span></span>
<span data-ttu-id="2369f-145">排程驅動叫用會使用計時器啟動背景工作。</span><span class="sxs-lookup"><span data-stu-id="2369f-145">Schedule-driven invocation uses a timer to start the background task.</span></span> <span data-ttu-id="2369f-146">使用排程驅動觸發程序的範例包括：</span><span class="sxs-lookup"><span data-stu-id="2369f-146">Examples of using schedule-driven triggers include:</span></span>

* <span data-ttu-id="2369f-147">在應用程式內本機執行的計時器，或作為應用程式作業系統一部分的計時器，會定期叫用背景工作。</span><span class="sxs-lookup"><span data-stu-id="2369f-147">A timer that is running locally within the application or as part of the application’s operating system invokes a background task on a regular basis.</span></span>
* <span data-ttu-id="2369f-148">在不同的應用程式中執行的計時器，或計時器服務 (例如 Azure 排程器)，會定期將要求傳送到 API 或 Web 服務。</span><span class="sxs-lookup"><span data-stu-id="2369f-148">A timer that is running in a different application, or a timer service such as Azure Scheduler, sends a request to an API or web service on a regular basis.</span></span> <span data-ttu-id="2369f-149">API 或 Web 服務會叫用背景工作。</span><span class="sxs-lookup"><span data-stu-id="2369f-149">The API or web service invokes the background task.</span></span>
* <span data-ttu-id="2369f-150">不同的程序或應用程式會啟動計時器，以便在指定的時間延遲後或特定的時間，叫用背景工作一次。</span><span class="sxs-lookup"><span data-stu-id="2369f-150">A separate process or application starts a timer that causes the background task to be invoked once after a specified time delay, or at a specific time.</span></span>

<span data-ttu-id="2369f-151">適合排程驅動叫用工作的一般範例包含批次處理常式 (例如根據使用者最新的行為來更新其相關的產品清單)、例行資料處理工作 (例如更新索引或產生累積結果)、每日報告的資料分析、資料保留清除、資料一致性檢查。</span><span class="sxs-lookup"><span data-stu-id="2369f-151">Typical examples of tasks that are suited to schedule-driven invocation include batch-processing routines (such as updating related-products lists for users based on their recent behavior), routine data processing tasks (such as updating indexes or generating accumulated results), data analysis for daily reports, data retention cleanup, and data consistency checks.</span></span>

<span data-ttu-id="2369f-152">如果您使用必須作為單一執行個體執行的排程驅動工作，請注意下列事項：</span><span class="sxs-lookup"><span data-stu-id="2369f-152">If you use a schedule-driven task that must run as a single instance, be aware of the following:</span></span>

* <span data-ttu-id="2369f-153">如果調整正在執行排程器的計算執行個體 (例如使用 Windows 排程工作的虛擬機器)，您必須執行排程器的多個執行個體。</span><span class="sxs-lookup"><span data-stu-id="2369f-153">If the compute instance that is running the scheduler (such as a virtual machine using Windows scheduled tasks) is scaled, you will have multiple instances of the scheduler running.</span></span> <span data-ttu-id="2369f-154">這些動作可能啟動工作的多個執行個體。</span><span class="sxs-lookup"><span data-stu-id="2369f-154">These could start multiple instances of the task.</span></span>
* <span data-ttu-id="2369f-155">如果工作的執行時間超過排程器事件之間的期間，排程器可能在前一個工作仍在執行時啟動工作的另一個執行個體。</span><span class="sxs-lookup"><span data-stu-id="2369f-155">If tasks run for longer than the period between scheduler events, the scheduler may start another instance of the task while the previous one is still running.</span></span>

## <a name="returning-results"></a><span data-ttu-id="2369f-156">傳回結果</span><span class="sxs-lookup"><span data-stu-id="2369f-156">Returning results</span></span>
<span data-ttu-id="2369f-157">背景作業以非同步的方式，在不同的處理序或甚至不同的位置內 (從 UI 或叫用背景工作的處理序) 中執行。</span><span class="sxs-lookup"><span data-stu-id="2369f-157">Background jobs execute asynchronously in a separate process, or even in a separate location, from the UI or the process that invoked the background task.</span></span> <span data-ttu-id="2369f-158">在理想的情況下，背景工作是「射後不理」(Fire and Forget) 的作業，而且其執行進度不會影響 UI 或呼叫程序。</span><span class="sxs-lookup"><span data-stu-id="2369f-158">Ideally, background tasks are “fire and forget” operations, and their execution progress has no impact on the UI or the calling process.</span></span> <span data-ttu-id="2369f-159">這表示呼叫處理序不會等候工作完成。</span><span class="sxs-lookup"><span data-stu-id="2369f-159">This means that the calling process does not wait for completion of the tasks.</span></span> <span data-ttu-id="2369f-160">因此，此處理序就無法自動偵測工作的結束時間。</span><span class="sxs-lookup"><span data-stu-id="2369f-160">Therefore, it cannot automatically detect when the task ends.</span></span>

<span data-ttu-id="2369f-161">如果您需要背景工作與呼叫工作通訊，以指出進度或完成，您必須為此實作一種機制。</span><span class="sxs-lookup"><span data-stu-id="2369f-161">If you require a background task to communicate with the calling task to indicate progress or completion, you must implement a mechanism for this.</span></span> <span data-ttu-id="2369f-162">部分範例如下：</span><span class="sxs-lookup"><span data-stu-id="2369f-162">Some examples are:</span></span>

* <span data-ttu-id="2369f-163">將狀態指標值寫入至可存取 UI 或呼叫者工作的儲存體，也就是可在必要時監視或檢查此值。</span><span class="sxs-lookup"><span data-stu-id="2369f-163">Write a status indicator value to storage that is accessible to the UI or caller task, which can monitor or check this value when required.</span></span> <span data-ttu-id="2369f-164">可將背景工作必須傳回給呼叫端的資料，放入相同的儲存體中。</span><span class="sxs-lookup"><span data-stu-id="2369f-164">Other data that the background task must return to the caller can be placed into the same storage.</span></span>
* <span data-ttu-id="2369f-165">建立 UI 或呼叫端會接聽的回覆佇列。</span><span class="sxs-lookup"><span data-stu-id="2369f-165">Establish a reply queue that the UI or caller listens on.</span></span> <span data-ttu-id="2369f-166">背景工作可以將訊息傳送至佇列，此佇列表示出狀態和工作的完成。</span><span class="sxs-lookup"><span data-stu-id="2369f-166">The background task can send messages to the queue that indicate status and completion.</span></span> <span data-ttu-id="2369f-167">可將背景工作必須傳回給呼叫端的資料放入訊息中。</span><span class="sxs-lookup"><span data-stu-id="2369f-167">Data that the background task must return to the caller can be placed into the messages.</span></span> <span data-ttu-id="2369f-168">如果您使用 Azure 服務匯流排，您可以使用 **ReplyTo** 和 **CorrelationId** 屬性來實作這項功能。</span><span class="sxs-lookup"><span data-stu-id="2369f-168">If you are using Azure Service Bus, you can use the **ReplyTo** and **CorrelationId** properties to implement this capability.</span></span> <span data-ttu-id="2369f-169">如需詳細資訊，請參閱 [服務匯流排代理傳訊中的相互關聯](http://www.cloudcasts.net/devguide/Default.aspx?id=13029)。</span><span class="sxs-lookup"><span data-stu-id="2369f-169">For more information, see [Correlation in Service Bus Brokered Messaging](http://www.cloudcasts.net/devguide/Default.aspx?id=13029).</span></span>
* <span data-ttu-id="2369f-170">從 UI 或呼叫端可以存取來取得狀態資訊的背景工作中，公開 API 或端點。</span><span class="sxs-lookup"><span data-stu-id="2369f-170">Expose an API or endpoint from the background task that the UI or caller can access to obtain status information.</span></span> <span data-ttu-id="2369f-171">可在回應中包含背景工作必須傳回給呼叫端的資料。</span><span class="sxs-lookup"><span data-stu-id="2369f-171">Data that the background task must return to the caller can be included in the response.</span></span>
* <span data-ttu-id="2369f-172">讓背景工作透過 API 回呼至 UI 或呼叫端，以表示預先定義的時間點或完成時的狀態。</span><span class="sxs-lookup"><span data-stu-id="2369f-172">Have the background task call back to the UI or caller through an API to indicate status at predefined points or on completion.</span></span> <span data-ttu-id="2369f-173">這可能是透過本機引發的事件，或透過發佈和訂閱機制。</span><span class="sxs-lookup"><span data-stu-id="2369f-173">This might be through events raised locally or through a publish-and-subscribe mechanism.</span></span> <span data-ttu-id="2369f-174">可在要求或事件裝載中，包含背景工作必須傳回給呼叫端的資料。</span><span class="sxs-lookup"><span data-stu-id="2369f-174">Data that the background task must return to the caller can be included in the request or event payload.</span></span>

## <a name="hosting-environment"></a><span data-ttu-id="2369f-175">裝載環境</span><span class="sxs-lookup"><span data-stu-id="2369f-175">Hosting environment</span></span>
<span data-ttu-id="2369f-176">您可以使用各種不同的 Azure 平台服務來裝載背景工作：</span><span class="sxs-lookup"><span data-stu-id="2369f-176">You can host background tasks by using a range of different Azure platform services:</span></span>

* <span data-ttu-id="2369f-177">[**Azure Web Apps 及 WebJobs**](#azure-web-apps-and-webjobs)。</span><span class="sxs-lookup"><span data-stu-id="2369f-177">[**Azure Web Apps and WebJobs**](#azure-web-apps-and-webjobs).</span></span> <span data-ttu-id="2369f-178">您可以根據 Web 應用程式內容中各種不同類型的指令碼或可執行程式，來使用 Web 工作執行自訂工作。</span><span class="sxs-lookup"><span data-stu-id="2369f-178">You can use WebJobs to execute custom jobs based on a range of different types of scripts or executable programs within the context of a web app.</span></span>
* <span data-ttu-id="2369f-179">[**Azure 虛擬機器**](#azure-virtual-machines)。</span><span class="sxs-lookup"><span data-stu-id="2369f-179">[**Azure Virtual Machines**](#azure-virtual-machines).</span></span> <span data-ttu-id="2369f-180">如果您使用 Windows 服務，或您想要使用 Windows 工作排程器，它一般會在專用的虛擬機器內裝載您的背景工作。</span><span class="sxs-lookup"><span data-stu-id="2369f-180">If you have a Windows service or want to use the Windows Task Scheduler, it is common to host your background tasks within a dedicated virtual machine.</span></span>
* <span data-ttu-id="2369f-181">[**Azure Batch**](#azure-batch)。</span><span class="sxs-lookup"><span data-stu-id="2369f-181">[**Azure Batch**](#azure-batch).</span></span> <span data-ttu-id="2369f-182">Batch 是一項平台服務，可排程要在一組受控虛擬機器上執行的計算密集型工作，</span><span class="sxs-lookup"><span data-stu-id="2369f-182">Batch is a platform service that schedules compute-intensive work to run on a managed collection of virtual machines.</span></span> <span data-ttu-id="2369f-183">，而且可以自動調整計算資源。</span><span class="sxs-lookup"><span data-stu-id="2369f-183">It can automatically scale compute resources.</span></span>
* <span data-ttu-id="2369f-184">[**Azure Container Service**](#azure-container-service)。</span><span class="sxs-lookup"><span data-stu-id="2369f-184">[**Azure Container Service**](#azure-container-service).</span></span> <span data-ttu-id="2369f-185">Azure Container Service (ACS) 提供 Azure 上的容器裝載環境。</span><span class="sxs-lookup"><span data-stu-id="2369f-185">Azure Container Service provides a container hosting environment on Azure.</span></span> 
* <span data-ttu-id="2369f-186">[**Azure 雲端服務**](#azure-cloud-services)。</span><span class="sxs-lookup"><span data-stu-id="2369f-186">[**Azure Cloud Services**](#azure-cloud-services).</span></span> <span data-ttu-id="2369f-187">您可以在做為背景工作執行的角色內撰寫程式碼。</span><span class="sxs-lookup"><span data-stu-id="2369f-187">You can write code within a role that executes as a background task.</span></span>

<span data-ttu-id="2369f-188">下列各節更詳細描述其中每個選項，並包含可協助您選擇適當選項的注意事項。</span><span class="sxs-lookup"><span data-stu-id="2369f-188">The following sections describe each of these options in more detail, and include considerations to help you choose the appropriate option.</span></span>

### <a name="azure-web-apps-and-webjobs"></a><span data-ttu-id="2369f-189">Azure Web Apps 及 WebJobs</span><span class="sxs-lookup"><span data-stu-id="2369f-189">Azure Web Apps and WebJobs</span></span>

<span data-ttu-id="2369f-190">您可以使用 Azure WebJobs，把自訂工作當做 Azure Web 應用程式內的背景工作來執行。</span><span class="sxs-lookup"><span data-stu-id="2369f-190">You can use Azure WebJobs to execute custom jobs as background tasks within an Azure Web App.</span></span> <span data-ttu-id="2369f-191">Web 工作會在 Web 應用程式內容中作為連續處理序來執行。</span><span class="sxs-lookup"><span data-stu-id="2369f-191">WebJobs run within the context of your web app as a continuous process.</span></span> <span data-ttu-id="2369f-192">Web 工作也會為回應 Azure 排程器的觸發事件或外部因素 (例如變更儲存體 Blob 和訊息佇列) 而執行。</span><span class="sxs-lookup"><span data-stu-id="2369f-192">WebJobs also run in response to a trigger event from Azure Scheduler or external factors, such as changes to storage blobs and message queues.</span></span> <span data-ttu-id="2369f-193">工作可在要求時啟動和停止，及正常關機。</span><span class="sxs-lookup"><span data-stu-id="2369f-193">Jobs can be started and stopped on demand, and shut down gracefully.</span></span> <span data-ttu-id="2369f-194">如果連續執行 WebJob 失敗，會自動重新啟動。</span><span class="sxs-lookup"><span data-stu-id="2369f-194">If a continuously running WebJob fails, it is automatically restarted.</span></span> <span data-ttu-id="2369f-195">重試和錯誤動作皆可設定。</span><span class="sxs-lookup"><span data-stu-id="2369f-195">Retry and error actions are configurable.</span></span>

<span data-ttu-id="2369f-196">當您設定 Web 工作時︰</span><span class="sxs-lookup"><span data-stu-id="2369f-196">When you configure a WebJob:</span></span>

* <span data-ttu-id="2369f-197">如果您想要讓作業回應事件驅動觸發程序，應該將其設定為 [連續執行] 。</span><span class="sxs-lookup"><span data-stu-id="2369f-197">If you want the job to respond to an event-driven trigger, you should configure it as **Run continuously**.</span></span> <span data-ttu-id="2369f-198">指令碼或程式會儲存在名為 site/wwwroot/app_data/jobs/continuous 的資料夾中。</span><span class="sxs-lookup"><span data-stu-id="2369f-198">The script or program is stored in the folder named site/wwwroot/app_data/jobs/continuous.</span></span>
* <span data-ttu-id="2369f-199">如果您想要作業回應排程驅動觸發程序，您應該將其設定為 [依排程執行] 。</span><span class="sxs-lookup"><span data-stu-id="2369f-199">If you want the job to respond to a schedule-driven trigger, you should configure it as **Run on a schedule**.</span></span> <span data-ttu-id="2369f-200">指令碼或程式會儲存在名為 site/wwwroot/app_data/jobs/triggered 的資料夾中。</span><span class="sxs-lookup"><span data-stu-id="2369f-200">The script or program is stored in the folder named site/wwwroot/app_data/jobs/triggered.</span></span>
* <span data-ttu-id="2369f-201">如果在設定作業時選擇 [視需要執行] 選項，它會執行您在啟動它時，與 [依排程執行] 選項相同的程式碼。</span><span class="sxs-lookup"><span data-stu-id="2369f-201">If you choose the **Run on demand** option when you configure a job, it will execute the same code as the **Run on a schedule** option when you start it.</span></span>

<span data-ttu-id="2369f-202">Azure WebJobs 在 Web 應用程式的沙箱中執行。</span><span class="sxs-lookup"><span data-stu-id="2369f-202">Azure WebJobs run within the sandbox of the web app.</span></span> <span data-ttu-id="2369f-203">這代表它們可以存取環境變數，並且與 Web 應用程式分享資訊 (例如連接字串)。</span><span class="sxs-lookup"><span data-stu-id="2369f-203">This means that they can access environment variables and share information, such as connection strings, with the web app.</span></span> <span data-ttu-id="2369f-204">作業可存取執行工作之電腦的唯一識別碼。</span><span class="sxs-lookup"><span data-stu-id="2369f-204">The job has access to the unique identifier of the machine that is running the job.</span></span> <span data-ttu-id="2369f-205">名為 **AzureWebJobsStorage** 的連接字串為應用程式資料提供 Azure 儲存體佇列、Blob 和資料表的存取權，以及為傳訊和通訊提供服務匯流排的存取權。</span><span class="sxs-lookup"><span data-stu-id="2369f-205">The connection string named **AzureWebJobsStorage** provides access to Azure storage queues, blobs, and tables for application data, and access to Service Bus for messaging and communication.</span></span> <span data-ttu-id="2369f-206">名為 **AzureWebJobsDashboard** 的連接字串工作動作記錄檔的存取權。</span><span class="sxs-lookup"><span data-stu-id="2369f-206">The connection string named **AzureWebJobsDashboard** provides access to the job action log files.</span></span>

<span data-ttu-id="2369f-207">Azure WebJobs 具有下列特性：</span><span class="sxs-lookup"><span data-stu-id="2369f-207">Azure WebJobs have the following characteristics:</span></span>

* <span data-ttu-id="2369f-208">**安全性**：WebJobs 受到 Web 應用程式的部署認證所保護。</span><span class="sxs-lookup"><span data-stu-id="2369f-208">**Security**: WebJobs are protected by the deployment credentials of the web app.</span></span>
* <span data-ttu-id="2369f-209">**支援的檔案類型**：您可以使用命令指令碼 (.cmd)、批次檔 (.bat)、PowerShell 指令碼 (.ps1)、Bash 殼層指令碼 (.sh)、PHP 指令碼 (.php)、Python 指令碼 (.py)、JavaScript 程式碼 (.js) 和可執行程式 (.exe、.jar 等等) 定義 Web 工作。</span><span class="sxs-lookup"><span data-stu-id="2369f-209">**Supported file types**: You can define WebJobs by using command scripts (.cmd), batch files (.bat), PowerShell scripts (.ps1), bash shell scripts (.sh), PHP scripts (.php), Python scripts (.py), JavaScript code (.js), and executable programs (.exe, .jar, and more).</span></span>
* <span data-ttu-id="2369f-210">**部署**：您可以使用 [Azure 入口網站](/azure/app-service-web/web-sites-create-web-jobs)、使用 [Visual Studio](/azure/app-service-web/websites-dotnet-deploy-webjobs)、使用 [Azure WebJobs SDK](/azure/azure-webjobs-sdk)，或將它們直接複製到下列位置，來部署指令碼和可執行檔：</span><span class="sxs-lookup"><span data-stu-id="2369f-210">**Deployment**: You can deploy scripts and executables by using the [Azure portal](/azure/app-service-web/web-sites-create-web-jobs), by using [Visual Studio](/azure/app-service-web/websites-dotnet-deploy-webjobs), by using the [Azure WebJobs SDK](/azure/azure-webjobs-sdk), or by copying them directly to the following locations:</span></span>
  * <span data-ttu-id="2369f-211">針對觸發執行：site/wwwroot/app_data/jobs/triggered/{job name}</span><span class="sxs-lookup"><span data-stu-id="2369f-211">For triggered execution: site/wwwroot/app_data/jobs/triggered/{job name}</span></span>
  * <span data-ttu-id="2369f-212">針對連續執行：site/wwwroot/app_data/jobs/continuous/{job name}</span><span class="sxs-lookup"><span data-stu-id="2369f-212">For continuous execution: site/wwwroot/app_data/jobs/continuous/{job name}</span></span>
* <span data-ttu-id="2369f-213">**記錄**：Console.Out 會被視為 (標示為) INFO。</span><span class="sxs-lookup"><span data-stu-id="2369f-213">**Logging**: Console.Out is treated (marked) as INFO.</span></span> <span data-ttu-id="2369f-214">Console.Error 會被視為 ERROR。</span><span class="sxs-lookup"><span data-stu-id="2369f-214">Console.Error is treated as ERROR.</span></span> <span data-ttu-id="2369f-215">您可以使用 Azure 入口網站存取監視和診斷資訊。</span><span class="sxs-lookup"><span data-stu-id="2369f-215">You can access monitoring and diagnostics information by using the Azure portal.</span></span> <span data-ttu-id="2369f-216">您可以直接從網站下載記錄檔。</span><span class="sxs-lookup"><span data-stu-id="2369f-216">You can download log files directly from the site.</span></span> <span data-ttu-id="2369f-217">這些資訊會儲存在下列位置：</span><span class="sxs-lookup"><span data-stu-id="2369f-217">They are saved in the following locations:</span></span>
  * <span data-ttu-id="2369f-218">針對觸發執行：Vfs/data/jobs/triggered/jobName</span><span class="sxs-lookup"><span data-stu-id="2369f-218">For triggered execution: Vfs/data/jobs/triggered/jobName</span></span>
  * <span data-ttu-id="2369f-219">針對連續執行：Vfs/data/jobs/continuous/jobName</span><span class="sxs-lookup"><span data-stu-id="2369f-219">For continuous execution: Vfs/data/jobs/continuous/jobName</span></span>
* <span data-ttu-id="2369f-220">**設定**：您可以使用入口網站、REST API 和 PowerShell 對 Web 工作進行設定。</span><span class="sxs-lookup"><span data-stu-id="2369f-220">**Configuration**: You can configure WebJobs by using the portal, the REST API, and PowerShell.</span></span> <span data-ttu-id="2369f-221">您可以使用和工作指令碼位於相同根目錄的設定檔 (名為 settings.job) 來提供作業的設定資訊。</span><span class="sxs-lookup"><span data-stu-id="2369f-221">You can use a configuration file named settings.job in the same root directory as the job script to provide configuration information for a job.</span></span> <span data-ttu-id="2369f-222">例如︰</span><span class="sxs-lookup"><span data-stu-id="2369f-222">For example:</span></span>
  * <span data-ttu-id="2369f-223">{ "stopping_wait_time": 60 }</span><span class="sxs-lookup"><span data-stu-id="2369f-223">{ "stopping_wait_time": 60 }</span></span>
  * <span data-ttu-id="2369f-224">{ "is_singleton": true }</span><span class="sxs-lookup"><span data-stu-id="2369f-224">{ "is_singleton": true }</span></span>

#### <a name="considerations"></a><span data-ttu-id="2369f-225">注意事項</span><span class="sxs-lookup"><span data-stu-id="2369f-225">Considerations</span></span>

* <span data-ttu-id="2369f-226">根據預設，WebJobs 會跟據 Web 應用程式來調整自己。</span><span class="sxs-lookup"><span data-stu-id="2369f-226">By default, WebJobs scale with the web app.</span></span> <span data-ttu-id="2369f-227">不過，您可以藉由將 **is_singleton** 設定屬性設為 **true**，進而設定為在單一執行個體上執行作業。</span><span class="sxs-lookup"><span data-stu-id="2369f-227">However, you can configure jobs to run on single instance by setting the **is_singleton** configuration property to **true**.</span></span> <span data-ttu-id="2369f-228">單一執行個體 Web 工作可用於您不想要調整的工作，或作為同時進行的多重執行個體來執行，例如重新建立索引、資料分析和類似的工作。</span><span class="sxs-lookup"><span data-stu-id="2369f-228">Single instance WebJobs are useful for tasks that you do not want to scale or run as simultaneous multiple instances, such as reindexing, data analysis, and similar tasks.</span></span>
* <span data-ttu-id="2369f-229">若要將作業對 Web 應用程式效能的影響降到最低，請考慮在新的 App Service 方案中建立空的 Azure Web 應用程式執行個體，來裝載可能會長時間執行或耗用大量資源的 Web 工作。</span><span class="sxs-lookup"><span data-stu-id="2369f-229">To minimize the impact of jobs on the performance of the web app, consider creating an empty Azure Web App instance in a new App Service plan to host WebJobs that may be long running or resource intensive.</span></span>

### <a name="more-information"></a><span data-ttu-id="2369f-230">詳細資訊</span><span class="sxs-lookup"><span data-stu-id="2369f-230">More information</span></span>
* <span data-ttu-id="2369f-231">[Azure WebJobs recommended resources](/azure/app-service-web/websites-webjobs-resources) 列出 Web 工作的許多有用的資源、下載及範例。</span><span class="sxs-lookup"><span data-stu-id="2369f-231">[Azure WebJobs recommended resources](/azure/app-service-web/websites-webjobs-resources) lists the many useful resources, downloads, and samples for WebJobs.</span></span>

### <a name="azure-virtual-machines"></a><span data-ttu-id="2369f-232">Azure 虛擬機器</span><span class="sxs-lookup"><span data-stu-id="2369f-232">Azure Virtual Machines</span></span>
<span data-ttu-id="2369f-233">背景工作的實作方式可能會讓它們無法部署到 Azure Web 應用程式或雲端服務，或是這些選項都不可行。</span><span class="sxs-lookup"><span data-stu-id="2369f-233">Background tasks might be implemented in a way that prevents them from being deployed to Azure Web Apps or Cloud Services, or these options might not be convenient.</span></span> <span data-ttu-id="2369f-234">常見的範例有 Windows 服務、協力廠商公用程式和可執行程式。</span><span class="sxs-lookup"><span data-stu-id="2369f-234">Typical examples are Windows services, and third-party utilities and executable programs.</span></span> <span data-ttu-id="2369f-235">另一個例子是針對某個執行環境 (和裝載應用程式的環境不同) 所撰寫的程式。</span><span class="sxs-lookup"><span data-stu-id="2369f-235">Another example might be programs written for an execution environment that is different than that hosting the application.</span></span> <span data-ttu-id="2369f-236">比方說，它可能是您想要從 Windows 或 .NET 應用程式執行的 Unix 或 Linux 程式。</span><span class="sxs-lookup"><span data-stu-id="2369f-236">For example, it might be a Unix or Linux program that you want to execute from a Windows or .NET application.</span></span> <span data-ttu-id="2369f-237">您可以選擇各式各樣的 Azure 虛擬機器的作業系統，並在該虛擬機器上執行您的服務或可執行檔。</span><span class="sxs-lookup"><span data-stu-id="2369f-237">You can choose from a range of operating systems for an Azure virtual machine, and run your service or executable on that virtual machine.</span></span>

<span data-ttu-id="2369f-238">如要了解如何選擇使用虛擬機器的時機，請參閱 [Azure App Services、雲端服務與虛擬機器之比較](/azure/app-service-web/choose-web-site-cloud-service-vm/)。</span><span class="sxs-lookup"><span data-stu-id="2369f-238">To help you choose when to use Virtual Machines, see [Azure App Services, Cloud Services and Virtual Machines comparison](/azure/app-service-web/choose-web-site-cloud-service-vm/).</span></span> <span data-ttu-id="2369f-239">如需虛擬機器選項的相關資訊，請參閱 [Azure 的虛擬機器和雲端服務大小](http://msdn.microsoft.com/library/azure/dn197896.aspx)。</span><span class="sxs-lookup"><span data-stu-id="2369f-239">For information about the options for Virtual Machines, see [Virtual Machine and Cloud Service sizes for Azure](http://msdn.microsoft.com/library/azure/dn197896.aspx).</span></span> <span data-ttu-id="2369f-240">如需虛擬機器可用之作業系統和預先建立映像的詳細資訊，請參閱 [Azure 虛擬機器 Marketplace](https://azure.microsoft.com/gallery/virtual-machines/)。</span><span class="sxs-lookup"><span data-stu-id="2369f-240">For more information about the operating systems and prebuilt images that are available for Virtual Machines, see [Azure Virtual Machines Marketplace](https://azure.microsoft.com/gallery/virtual-machines/).</span></span>

<span data-ttu-id="2369f-241">若要在個別虛擬機器中起始背景工作，您有一系列的選項可選：</span><span class="sxs-lookup"><span data-stu-id="2369f-241">To initiate the background task in a separate virtual machine, you have a range of options:</span></span>

* <span data-ttu-id="2369f-242">您可以藉由將要求傳送至工作所公開的端點，以視需要直接從您的應用程式執行工作。</span><span class="sxs-lookup"><span data-stu-id="2369f-242">You can execute the task on demand directly from your application by sending a request to an endpoint that the task exposes.</span></span> <span data-ttu-id="2369f-243">這會傳入工作所需的任何資料。</span><span class="sxs-lookup"><span data-stu-id="2369f-243">This passes in any data that the task requires.</span></span> <span data-ttu-id="2369f-244">此端點會叫用工作。</span><span class="sxs-lookup"><span data-stu-id="2369f-244">This endpoint invokes the task.</span></span>
* <span data-ttu-id="2369f-245">您可以使用所選作業系統中的可用排程器或計時器，將工作設定為依據排程執行。</span><span class="sxs-lookup"><span data-stu-id="2369f-245">You can configure the task to run on a schedule by using a scheduler or timer that is available in your chosen operating system.</span></span> <span data-ttu-id="2369f-246">例如，在 Windows 上可以使用 Windows 工作排程器來執行指令碼和工作。</span><span class="sxs-lookup"><span data-stu-id="2369f-246">For example, on Windows you can use Windows Task Scheduler to execute scripts and tasks.</span></span> <span data-ttu-id="2369f-247">或者，如果您已在虛擬機器上安裝 SQL Server，您可以使用 SQL Server 代理程式來執行指令碼和工作。</span><span class="sxs-lookup"><span data-stu-id="2369f-247">Or, if you have SQL Server installed on the virtual machine, you can use the SQL Server Agent to execute scripts and tasks.</span></span>
* <span data-ttu-id="2369f-248">您可以使用 Azure 排程器來起始工作，方法是將訊息加入至工作接聽的佇列，或將要求傳送至工作所公開的 API。</span><span class="sxs-lookup"><span data-stu-id="2369f-248">You can use Azure Scheduler to initiate the task by adding a message to a queue that the task listens on, or by sending a request to an API that the task exposes.</span></span>

<span data-ttu-id="2369f-249">如需有關如何啟動背景工作的詳細資訊，請參閱先前的＜ [觸發程序](#triggers) ＞一節。</span><span class="sxs-lookup"><span data-stu-id="2369f-249">See the earlier section [Triggers](#triggers) for more information about how you can initiate background tasks.</span></span>  

#### <a name="considerations"></a><span data-ttu-id="2369f-250">注意事項</span><span class="sxs-lookup"><span data-stu-id="2369f-250">Considerations</span></span>
<span data-ttu-id="2369f-251">當您決定是否要在 Azure 虛擬機器中部署背景工作時，請考慮下列幾點：</span><span class="sxs-lookup"><span data-stu-id="2369f-251">Consider the following points when you are deciding whether to deploy background tasks in an Azure virtual machine:</span></span>

* <span data-ttu-id="2369f-252">在不同的 Azure 虛擬機器中裝載背景工作提供了彈性，並可透過起始、執行、排程及資源配置以精確控制。</span><span class="sxs-lookup"><span data-stu-id="2369f-252">Hosting background tasks in a separate Azure virtual machine provides flexibility and allows precise control over initiation, execution, scheduling, and resource allocation.</span></span> <span data-ttu-id="2369f-253">不過，如果必須部署虛擬機器，並只是為了執行背景工作，則會增加執行階段成本。</span><span class="sxs-lookup"><span data-stu-id="2369f-253">However, it will increase runtime cost if a virtual machine must be deployed just to run background tasks.</span></span>
* <span data-ttu-id="2369f-254">沒有任何設備可監視 Azure 入口網站中的工作，且沒有適用於失敗工作的自動重新啟動功能，但您可以監視虛擬機器的基本狀態，並使用 [Azure Resource Manager Cmdlet](https://msdn.microsoft.com/library/mt125356.aspx) 管理它。</span><span class="sxs-lookup"><span data-stu-id="2369f-254">There is no facility to monitor the tasks in the Azure portal and no automated restart capability for failed tasks--although you can monitor the basic status of the virtual machine and manage it by using the  [Azure Resource Manager Cmdlets](https://msdn.microsoft.com/library/mt125356.aspx).</span></span> <span data-ttu-id="2369f-255">不過，計算節點中沒有機制可用來控制程序和執行緒。</span><span class="sxs-lookup"><span data-stu-id="2369f-255">However, there are no facilities to control processes and threads in compute nodes.</span></span> <span data-ttu-id="2369f-256">通常，使用虛擬機器將會需要額外的工作，才能在工作中實作機制，以便從檢測中收集資料，並從虛擬機器中的作業系統收集資料。</span><span class="sxs-lookup"><span data-stu-id="2369f-256">Typically, using a virtual machine will require additional effort to implement a mechanism that collects data from instrumentation in the task, and from the operating system in the virtual machine.</span></span> <span data-ttu-id="2369f-257">一個可能適當的解決方案是使用 [System Center Management Pack for Azure](https://www.microsoft.com/download/details.aspx?id=50013)。</span><span class="sxs-lookup"><span data-stu-id="2369f-257">One solution that might be appropriate is to use the [System Center Management Pack for Azure](https://www.microsoft.com/download/details.aspx?id=50013).</span></span>
* <span data-ttu-id="2369f-258">您可以考慮建立透過 HTTP 端點公開的監視探查。</span><span class="sxs-lookup"><span data-stu-id="2369f-258">You might consider creating monitoring probes that are exposed through HTTP endpoints.</span></span> <span data-ttu-id="2369f-259">這些探查的程式碼可執行健康狀態檢查、收集操作資訊和統計資料，或自動分頁錯誤資訊，以及將它傳回給管理應用程式。</span><span class="sxs-lookup"><span data-stu-id="2369f-259">The code for these probes could perform health checks, collect operational information and statistics--or collate error information and return it to a management application.</span></span> <span data-ttu-id="2369f-260">如需詳細資訊，請參閱 [健康狀態端點監控模式](http://msdn.microsoft.com/library/dn589789.aspx)。</span><span class="sxs-lookup"><span data-stu-id="2369f-260">For more information, see [Health Endpoint Monitoring Pattern](http://msdn.microsoft.com/library/dn589789.aspx).</span></span>

#### <a name="more-information"></a><span data-ttu-id="2369f-261">詳細資訊</span><span class="sxs-lookup"><span data-stu-id="2369f-261">More information</span></span>
* <span data-ttu-id="2369f-262">[虛擬機器](https://azure.microsoft.com/services/virtual-machines/) </span><span class="sxs-lookup"><span data-stu-id="2369f-262">[Virtual Machines](https://azure.microsoft.com/services/virtual-machines/) on Azure</span></span>
* [<span data-ttu-id="2369f-263">Azure 虛擬機器常見問題集</span><span class="sxs-lookup"><span data-stu-id="2369f-263">Azure Virtual Machines FAQ</span></span>](/azure/virtual-machines/virtual-machines-linux-classic-faq?toc=%2fazure%2fvirtual-machines%2flinux%2fclassic%2ftoc.json)

### <a name="azure-batch"></a><span data-ttu-id="2369f-264">Azure Batch</span><span class="sxs-lookup"><span data-stu-id="2369f-264">Azure Batch</span></span> 

<span data-ttu-id="2369f-265">如果您需要跨數十、數百或數千個 VM 執行大型、平行的高效能計算 (HPC) 工作負載，請考慮 [Azure Batch](/azure/batch/)。</span><span class="sxs-lookup"><span data-stu-id="2369f-265">Consider [Azure Batch](/azure/batch/) if you need to run large, parallel high-performance computing (HPC) workloads across tens, hundreds, or thousands of VMs.</span></span>  

<span data-ttu-id="2369f-266">Batch 服務會佈建 VM、將工作指派給 VM、執行工作，並監視進度。</span><span class="sxs-lookup"><span data-stu-id="2369f-266">The Batch service provisions the VMs, assign tasks to the VMs, runs the tasks, and monitors the progress.</span></span> <span data-ttu-id="2369f-267">Batch 可以自動相應放大 VM 來反應工作負載。</span><span class="sxs-lookup"><span data-stu-id="2369f-267">Batch can automatically scale out the VMs in response to the workload.</span></span> <span data-ttu-id="2369f-268">Batch 也提供作業排程。</span><span class="sxs-lookup"><span data-stu-id="2369f-268">Batch also provides job scheduling.</span></span> <span data-ttu-id="2369f-269">Azure Batch 支援 Linux 和 Windows VM。</span><span class="sxs-lookup"><span data-stu-id="2369f-269">Azure Batch supports both Linux and Windows VMs.</span></span>

#### <a name="considerations"></a><span data-ttu-id="2369f-270">注意事項</span><span class="sxs-lookup"><span data-stu-id="2369f-270">Considerations</span></span> 

<span data-ttu-id="2369f-271">Batch 適合執行本質平行的工作負載。</span><span class="sxs-lookup"><span data-stu-id="2369f-271">Batch works well with intrinsically parallel workloads.</span></span> <span data-ttu-id="2369f-272">也可以執行最後有歸納步驟的平行計算，或是執行[訊息傳遞介面 (MPI) 應用程式](/azure/batch/batch-mpi) (用於需要在節點間傳遞訊息的平行工作)。</span><span class="sxs-lookup"><span data-stu-id="2369f-272">It can also perform parallel calculations with a reduce step at the end, or run [Message Passing Interface (MPI) applications](/azure/batch/batch-mpi) for parallel tasks that require message passing between nodes.</span></span> 

<span data-ttu-id="2369f-273">節點 (VM) 集區上執行的 Azure Batch 作業。</span><span class="sxs-lookup"><span data-stu-id="2369f-273">An Azure Batch job runs on a pool of nodes (VMs).</span></span> <span data-ttu-id="2369f-274">其中一個做法是只在需要的時候配置集區，且在作業完成後便刪除。</span><span class="sxs-lookup"><span data-stu-id="2369f-274">One approach is to allocate a pool only when needed and then delete it after the job completes.</span></span> <span data-ttu-id="2369f-275">這能將使用率最大化，因為節點不會閒置，但作業必須等候節點的配置。</span><span class="sxs-lookup"><span data-stu-id="2369f-275">This maximizes utilization, because nodes are not idle, but the job must wait for nodes to be allocated.</span></span> <span data-ttu-id="2369f-276">或者，您可以事先建立集區。</span><span class="sxs-lookup"><span data-stu-id="2369f-276">Alternatively, you can create a pool ahead of time.</span></span> <span data-ttu-id="2369f-277">這個做法可以降低作業開始所需的時間，但是會造成節點閒置。</span><span class="sxs-lookup"><span data-stu-id="2369f-277">That approach minimizes the time that it takes for a job to start, but can result in having nodes that sit idle.</span></span> <span data-ttu-id="2369f-278">如需詳細資訊，請參閱[集區和計算節點存留期](/azure/batch/batch-api-basics#pool-and-compute-node-lifetime)。</span><span class="sxs-lookup"><span data-stu-id="2369f-278">For more information, see [Pool and compute node lifetime](/azure/batch/batch-api-basics#pool-and-compute-node-lifetime).</span></span>

#### <a name="more-information"></a><span data-ttu-id="2369f-279">詳細資訊</span><span class="sxs-lookup"><span data-stu-id="2369f-279">More information</span></span> 

* [<span data-ttu-id="2369f-280">使用 Batch 執行本質平行的工作負載</span><span class="sxs-lookup"><span data-stu-id="2369f-280">Run intrinsically parallel workloads with Batch</span></span>](/azure/batch/batch-technical-overview) 
* [<span data-ttu-id="2369f-281">使用 Batch 開發大規模的平行運算解決方案</span><span class="sxs-lookup"><span data-stu-id="2369f-281">Develop large-scale parallel compute solutions with Batch</span></span>](/azure/batch/batch-api-basics) 
* [<span data-ttu-id="2369f-282">大規模運算工作負載的 Batch 和 HPC 解決方案</span><span class="sxs-lookup"><span data-stu-id="2369f-282">Batch and HPC solutions for large-scale computing workloads</span></span>](/azure/batch/batch-hpc-solutions)

### <a name="azure-container-service"></a><span data-ttu-id="2369f-283">Azure Container Service</span><span class="sxs-lookup"><span data-stu-id="2369f-283">Azure Container Service</span></span> 

<span data-ttu-id="2369f-284">Azure Container Service 可讓您設定和管理 Azure 中的 VM 叢集，以執行容器化的應用程式。</span><span class="sxs-lookup"><span data-stu-id="2369f-284">Azure Container Service lets you configure and manage a cluster of VMs in Azure to run containerized applications.</span></span> <span data-ttu-id="2369f-285">它提供協調流程的選擇：Docker Swarm 、DC/OS 或 Kubernetes。</span><span class="sxs-lookup"><span data-stu-id="2369f-285">It provides a choice of Docker Swarm, DC/OS, or Kubernetes for orchestration.</span></span> 

<span data-ttu-id="2369f-286">容器適合用於執行背景作業。</span><span class="sxs-lookup"><span data-stu-id="2369f-286">Containers can be useful for running background jobs.</span></span> <span data-ttu-id="2369f-287">以下是其中一些優點：</span><span class="sxs-lookup"><span data-stu-id="2369f-287">Some of the benefits include:</span></span> 

- <span data-ttu-id="2369f-288">容器支援高密度裝載。</span><span class="sxs-lookup"><span data-stu-id="2369f-288">Containers support high-density hosting.</span></span> <span data-ttu-id="2369f-289">您可以在容器中隔離背景工作，同時在每個 VM 中入放多個容器。</span><span class="sxs-lookup"><span data-stu-id="2369f-289">You can isolate a background task in a container, while placing multiple containers in each VM.</span></span>
- <span data-ttu-id="2369f-290">容器協調器會處理內部負載平衡、設定內部網路，以及其他設定工作。</span><span class="sxs-lookup"><span data-stu-id="2369f-290">The container orchestrator handles internal load balancing, configuring the internal network, and other configuration tasks.</span></span>
- <span data-ttu-id="2369f-291">視需要啟動或停止容器。</span><span class="sxs-lookup"><span data-stu-id="2369f-291">Containers can be started and stopped as needed.</span></span> 
- <span data-ttu-id="2369f-292">Azure Container Registry 可讓您註冊在 Azure 界限內註冊您的容器。</span><span class="sxs-lookup"><span data-stu-id="2369f-292">Azure Container Registry allows you to register your containers inside Azure boundaries.</span></span> <span data-ttu-id="2369f-293">這同時具有安全性、隱私權和相近的優點。</span><span class="sxs-lookup"><span data-stu-id="2369f-293">This comes with security, privacy, and proximity benefits.</span></span> 

#### <a name="considerations"></a><span data-ttu-id="2369f-294">注意事項</span><span class="sxs-lookup"><span data-stu-id="2369f-294">Considerations</span></span>

- <span data-ttu-id="2369f-295">必須了解如何使用容器協調器。</span><span class="sxs-lookup"><span data-stu-id="2369f-295">Requires an understanding of how to use a container orchestrator.</span></span> <span data-ttu-id="2369f-296">這會不會是個問題，取決於您的 DevOps 小組技能。</span><span class="sxs-lookup"><span data-stu-id="2369f-296">Depending on the skillset of your DevOps team, this may or may not be an issue.</span></span>  
- <span data-ttu-id="2369f-297">容器服務在 IaaS 環境中執行。</span><span class="sxs-lookup"><span data-stu-id="2369f-297">Container Service runs in an IaaS environment.</span></span> <span data-ttu-id="2369f-298">它會在專用 VNet 內佈建 VM 叢集。</span><span class="sxs-lookup"><span data-stu-id="2369f-298">It provisions a cluster of VMs inside a dedicated VNet.</span></span> 

#### <a name="more-information"></a><span data-ttu-id="2369f-299">詳細資訊</span><span class="sxs-lookup"><span data-stu-id="2369f-299">More information</span></span> 

* [<span data-ttu-id="2369f-300">使用 Azure Container Service 的 Docker 容器主控解決方案簡介</span><span class="sxs-lookup"><span data-stu-id="2369f-300">Introduction to Docker container hosting solutions with Azure Container Service</span></span>](/azure/container-service/container-service-intro) 
* [<span data-ttu-id="2369f-301">私人 Docker 容器登錄的簡介</span><span class="sxs-lookup"><span data-stu-id="2369f-301">Introduction to private Docker container registries</span></span>](/azure/container-registry/container-registry-intro) 

### <a name="azure-cloud-services"></a><span data-ttu-id="2369f-302">Azure 雲端服務</span><span class="sxs-lookup"><span data-stu-id="2369f-302">Azure Cloud Services</span></span> 
<span data-ttu-id="2369f-303">你可以在 Web 角色或另一個背景工作角色中，執行背景工作。</span><span class="sxs-lookup"><span data-stu-id="2369f-303">You can execute background tasks within a web role or in a separate worker role.</span></span> <span data-ttu-id="2369f-304">當您決定是否使用背景工作角色時，應該根據考量延展性和彈性需求、工作存留期、釋放頻率、安全性、容錯、爭用、複雜度和邏輯結構。</span><span class="sxs-lookup"><span data-stu-id="2369f-304">When you are deciding whether to use a worker role, consider scalability and elasticity requirements, task lifetime, release cadence, security, fault tolerance, contention, complexity, and the logical architecture.</span></span> <span data-ttu-id="2369f-305">如需詳細資訊，請參閱 [計算資源彙總模式](http://msdn.microsoft.com/library/dn589778.aspx)。</span><span class="sxs-lookup"><span data-stu-id="2369f-305">For more information, see [Compute Resource Consolidation Pattern](http://msdn.microsoft.com/library/dn589778.aspx).</span></span>

<span data-ttu-id="2369f-306">有數種方式來實作雲端服務角色中的背景工作：</span><span class="sxs-lookup"><span data-stu-id="2369f-306">There are several ways to implement background tasks within a Cloud Services role:</span></span>

* <span data-ttu-id="2369f-307">在角色中建立 **RoleEntryPoint** 類別的實作，並使用其方法來執行背景工作。</span><span class="sxs-lookup"><span data-stu-id="2369f-307">Create an implementation of the **RoleEntryPoint** class in the role and use its methods to execute background tasks.</span></span> <span data-ttu-id="2369f-308">這些工作會在 WaIISHost.exe 的內容中執行。</span><span class="sxs-lookup"><span data-stu-id="2369f-308">The tasks run in the context of WaIISHost.exe.</span></span> <span data-ttu-id="2369f-309">它們可以使用 **CloudConfigurationManager** 類別的 **GetSetting** 方法來載入組態設定。</span><span class="sxs-lookup"><span data-stu-id="2369f-309">They can use the **GetSetting** method of the **CloudConfigurationManager** class to load configuration settings.</span></span> <span data-ttu-id="2369f-310">如需詳細資訊，請參閱[生命週期](#lifecycle)。</span><span class="sxs-lookup"><span data-stu-id="2369f-310">For more information, see [Lifecycle](#lifecycle).</span></span>
* <span data-ttu-id="2369f-311">應用程式啟動時，使用啟動工作來執行背景工作。</span><span class="sxs-lookup"><span data-stu-id="2369f-311">Use startup tasks to execute background tasks when the application starts.</span></span> <span data-ttu-id="2369f-312">若要強制工作繼續在背景中執行，請將 **taskType** 屬性設為 **background** (如果不這麼做，應用程式啟動處理序將會停止並等待工作完成)。</span><span class="sxs-lookup"><span data-stu-id="2369f-312">To force the tasks to continue to run in the background, set the **taskType** property to **background** (if you do not do this, the application startup process will halt and wait for the task to finish).</span></span> <span data-ttu-id="2369f-313">如需詳細資訊，請參閱 [Run startup tasks in Azure (在 Azure 中執行啟動工作)](/azure/cloud-services/cloud-services-startup-tasks)。</span><span class="sxs-lookup"><span data-stu-id="2369f-313">For more information, see [Run startup tasks in Azure](/azure/cloud-services/cloud-services-startup-tasks).</span></span>
* <span data-ttu-id="2369f-314">您可以使用 WebJobs SDK，實作初始為啟動工作的背景工作 (如 Web 工作)。</span><span class="sxs-lookup"><span data-stu-id="2369f-314">Use the WebJobs SDK to implement background tasks such as WebJobs that are initiated as a startup task.</span></span> <span data-ttu-id="2369f-315">如需詳細資訊，請參閱 [在 Azure App Service 中建立 .NET WebJob](/azure/app-service-web/websites-dotnet-webjobs-sdk-get-started)。</span><span class="sxs-lookup"><span data-stu-id="2369f-315">For more information, see [Create a .NET WebJob in Azure App Service](/azure/app-service-web/websites-dotnet-webjobs-sdk-get-started).</span></span>
* <span data-ttu-id="2369f-316">您可以使用啟動工作，安裝執行一或多個背景工作的 Windows 服務。</span><span class="sxs-lookup"><span data-stu-id="2369f-316">Use a startup task to install a Windows service that executes one or more background tasks.</span></span> <span data-ttu-id="2369f-317">您必須將 **taskType** 屬性設為 **background**，以便在背景中執行服務。</span><span class="sxs-lookup"><span data-stu-id="2369f-317">You must set the **taskType** property to **background** so that the service executes in the background.</span></span> <span data-ttu-id="2369f-318">如需詳細資訊，請參閱 [Run startup tasks in Azure (在 Azure 中執行啟動工作)](/azure/cloud-services/cloud-services-startup-tasks)。</span><span class="sxs-lookup"><span data-stu-id="2369f-318">For more information, see [Run startup tasks in Azure](/azure/cloud-services/cloud-services-startup-tasks).</span></span>

<span data-ttu-id="2369f-319">在 Web 角色中執行背景工作的主要優點在於裝載儲存成本，因為沒有部署其他角色的需求。</span><span class="sxs-lookup"><span data-stu-id="2369f-319">The main advantage of running background tasks in the web role is the saving in hosting costs because there is no requirement to deploy additional roles.</span></span>

<span data-ttu-id="2369f-320">在背景工作角色中執行背景工作有下列優點：</span><span class="sxs-lookup"><span data-stu-id="2369f-320">Running background tasks in a worker role has several advantages:</span></span>

* <span data-ttu-id="2369f-321">它可讓您為每種類型的角色個別管理調整。</span><span class="sxs-lookup"><span data-stu-id="2369f-321">It allows you to manage scaling separately for each type of role.</span></span> <span data-ttu-id="2369f-322">例如，您可能需要 Web 角色的更多執行個體才能支援目前的負載，但僅需要較少執行背景工作的背景工作角色執行個體。</span><span class="sxs-lookup"><span data-stu-id="2369f-322">For example, you might need more instances of a web role to support the current load, but fewer instances of the worker role that executes background tasks.</span></span> <span data-ttu-id="2369f-323">從 UI 角色調整背景工作分別計算執行個體可以減少裝載成本，同時維持可接受的效能。</span><span class="sxs-lookup"><span data-stu-id="2369f-323">By scaling background task compute instances separately from the UI roles, you can reduce hosting costs, while maintaining acceptable performance.</span></span>
* <span data-ttu-id="2369f-324">它會卸載來自 Web 角色的背景工作的處理負擔。</span><span class="sxs-lookup"><span data-stu-id="2369f-324">It offloads the processing overhead for background tasks from the web role.</span></span> <span data-ttu-id="2369f-325">提供 UI 的 Web 角色可以保持回應性，而且也可能意味只需要較少的執行個體，即可支援指定使用者的給定要求數量。</span><span class="sxs-lookup"><span data-stu-id="2369f-325">The web role that provides the UI can remain responsive, and it may mean fewer instances are required to support a given volume of requests from users.</span></span>
* <span data-ttu-id="2369f-326">它可讓您實作關注的分離動作。</span><span class="sxs-lookup"><span data-stu-id="2369f-326">It allows you to implement separation of concerns.</span></span> <span data-ttu-id="2369f-327">每種角色類型可以實作一組明確定義和相關的特定工作。</span><span class="sxs-lookup"><span data-stu-id="2369f-327">Each role type can implement a specific set of clearly defined and related tasks.</span></span> <span data-ttu-id="2369f-328">這使得設計和維護程式碼更容易，因為每個角色之間的程式碼和功能會有較少的相依關係。</span><span class="sxs-lookup"><span data-stu-id="2369f-328">This makes designing and maintaining the code easier because there is less interdependence of code and functionality between each role.</span></span>
* <span data-ttu-id="2369f-329">它有助於隔離機密的程序和資料。</span><span class="sxs-lookup"><span data-stu-id="2369f-329">It can help to isolate sensitive processes and data.</span></span> <span data-ttu-id="2369f-330">比方說，實作 UI 的 Web 角色不需要存取背景工作角色所管理和控制的資料。</span><span class="sxs-lookup"><span data-stu-id="2369f-330">For example, web roles that implement the UI do not need to have access to data that is managed and controlled by a worker role.</span></span> <span data-ttu-id="2369f-331">這可以用來加強安全性，尤其是當您使用 [Gatekeeper Pattern (閘道管理員模式)](http://msdn.microsoft.com/library/dn589793.aspx)之類的模式時。</span><span class="sxs-lookup"><span data-stu-id="2369f-331">This can be useful in strengthening security, especially when you use a pattern such as the [Gatekeeper Pattern](http://msdn.microsoft.com/library/dn589793.aspx).</span></span>  

#### <a name="considerations"></a><span data-ttu-id="2369f-332">注意事項</span><span class="sxs-lookup"><span data-stu-id="2369f-332">Considerations</span></span>
<span data-ttu-id="2369f-333">如果使用雲端服務 Web 和背景工作角色，在選擇部署背景工作的方式和位置時，請考量下列重點：</span><span class="sxs-lookup"><span data-stu-id="2369f-333">Consider the following points when choosing how and where to deploy background tasks when using Cloud Services web and worker roles:</span></span>

* <span data-ttu-id="2369f-334">在現有 Web 角色中裝載背景工作，會比為了這些工作而執行不同背景工作角色的成本更低。</span><span class="sxs-lookup"><span data-stu-id="2369f-334">Hosting background tasks in an existing web role can save the cost of running a separate worker role just for these tasks.</span></span> <span data-ttu-id="2369f-335">不過，如果對處理順序和其他資源產生爭用的話，很可能會影響應用程式的效能和可用性。</span><span class="sxs-lookup"><span data-stu-id="2369f-335">However, it is likely to affect the performance and availability of the application if there is contention for processing and other resources.</span></span> <span data-ttu-id="2369f-336">使用不同的背景工作角色，可防止長時間執行或耗用大量資源的背景工作影響 Web 角色。</span><span class="sxs-lookup"><span data-stu-id="2369f-336">Using a separate worker role protects the web role from the impact of long-running or resource-intensive background tasks.</span></span>
* <span data-ttu-id="2369f-337">如果您使用 **RoleEntryPoint** 類別裝載背景工作，您可以輕鬆地將其移到另一個角色。</span><span class="sxs-lookup"><span data-stu-id="2369f-337">If you host background tasks by using the **RoleEntryPoint** class, you can easily move this to another role.</span></span> <span data-ttu-id="2369f-338">例如，如果您在 Web 角色中建立類別，並在稍後決定需要在背景工作角色中執行工作的話，您可以將 **RoleEntryPoint** 類別實作移入背景工作角色中。</span><span class="sxs-lookup"><span data-stu-id="2369f-338">For example, if you create the class in a web role and later decide that you need to run the tasks in a worker role, you can move the **RoleEntryPoint** class implementation into the worker role.</span></span>
* <span data-ttu-id="2369f-339">啟動工作是設計來執行程式或指令碼。</span><span class="sxs-lookup"><span data-stu-id="2369f-339">Startup tasks are designed to execute a program or a script.</span></span> <span data-ttu-id="2369f-340">將背景作業部署為可執行程式可能更困難，尤其是還需要部署相依組件時。</span><span class="sxs-lookup"><span data-stu-id="2369f-340">Deploying a background job as an executable program might be more difficult, especially if it also requires deployment of dependent assemblies.</span></span> <span data-ttu-id="2369f-341">在您使用啟動工作時，部署和使用指令碼來定義背景作業可能更容易。</span><span class="sxs-lookup"><span data-stu-id="2369f-341">It might be easier to deploy and use a script to define a background job when you use startup tasks.</span></span>
* <span data-ttu-id="2369f-342">造成背景工作失敗的例外狀況有不同的影響，視其裝載的方式而定：</span><span class="sxs-lookup"><span data-stu-id="2369f-342">Exceptions that cause a background task to fail have a different impact, depending on the way that they are hosted:</span></span>
  * <span data-ttu-id="2369f-343">如果使用 **RoleEntryPoint** 類別方法，失敗的工作會導致角色重新啟動，讓工作自動重新啟動。</span><span class="sxs-lookup"><span data-stu-id="2369f-343">If you use the **RoleEntryPoint** class approach, a failed task will cause the role to restart so that the task automatically restarts.</span></span> <span data-ttu-id="2369f-344">這可能會影響應用程式的可用性。</span><span class="sxs-lookup"><span data-stu-id="2369f-344">This can affect availability of the application.</span></span> <span data-ttu-id="2369f-345">若要避免這個問題，請確定在 **RoleEntryPoint** 類別及所有背景工作中加入強固的例外狀況處理。</span><span class="sxs-lookup"><span data-stu-id="2369f-345">To prevent this, ensure that you include robust exception handling within the **RoleEntryPoint** class and all the background tasks.</span></span> <span data-ttu-id="2369f-346">適用時，請使用程式碼來重新啟動失敗的工作，且只有當您無法正常地從程式碼失敗中復原時，才擲回例外狀況以重新啟動角色。</span><span class="sxs-lookup"><span data-stu-id="2369f-346">Use code to restart tasks that fail where this is appropriate, and throw the exception to restart the role only if you cannot gracefully recover from the failure within your code.</span></span>
  * <span data-ttu-id="2369f-347">如果您使用啟動工作，您必須負責管理工作執行，以及檢查失敗。</span><span class="sxs-lookup"><span data-stu-id="2369f-347">If you use startup tasks, you are responsible for managing the task execution and checking if it fails.</span></span>
* <span data-ttu-id="2369f-348">管理和監控啟動工作比使用 **RoleEntryPoint** 類別方法更困難。</span><span class="sxs-lookup"><span data-stu-id="2369f-348">Managing and monitoring startup tasks is more difficult than using the **RoleEntryPoint** class approach.</span></span> <span data-ttu-id="2369f-349">不過，Azure WebJobs SDK 包含儀表板，方便您更輕鬆管理透過啟動工作起始的 Web 工作。</span><span class="sxs-lookup"><span data-stu-id="2369f-349">However, the Azure WebJobs SDK includes a dashboard to make it easier to manage WebJobs that you initiate through startup tasks.</span></span>

#### <a name="lifecycle"></a><span data-ttu-id="2369f-350">生命週期</span><span class="sxs-lookup"><span data-stu-id="2369f-350">Lifecycle</span></span> 
 <span data-ttu-id="2369f-351">如果您決定使用 **RoleEntryPoint** 類別，為使用 Web 和背景工作角色的雲端服務應用程式實作背景工作，請務必瞭解這個類別的生命週期以正確使用。</span><span class="sxs-lookup"><span data-stu-id="2369f-351">If you decide to implement background jobs for Cloud Services applications that use web and worker roles by using the **RoleEntryPoint** class, it is important to understand the lifecycle of this class in order to use it correctly.</span></span>

<span data-ttu-id="2369f-352">Web 和背景工作角色在啟動、執行和停止時會經歷一組不同的階段。</span><span class="sxs-lookup"><span data-stu-id="2369f-352">Web and worker roles go through a set of distinct phases as they start, run, and stop.</span></span> <span data-ttu-id="2369f-353">**RoleEntryPoint** 類別會公開在發生這些階段時所指示的一系列事件。</span><span class="sxs-lookup"><span data-stu-id="2369f-353">The **RoleEntryPoint** class exposes a series of events that indicate when these stages are occurring.</span></span> <span data-ttu-id="2369f-354">您使用這些來初始化、執行並停止您的自訂背景工作。</span><span class="sxs-lookup"><span data-stu-id="2369f-354">You use these to initialize, run, and stop your custom background tasks.</span></span> <span data-ttu-id="2369f-355">完整的週期是：</span><span class="sxs-lookup"><span data-stu-id="2369f-355">The complete cycle is:</span></span>

* <span data-ttu-id="2369f-356">Azure 會載入角色組件，並搜尋它來找出衍生自 **RoleEntryPoint**的類別。</span><span class="sxs-lookup"><span data-stu-id="2369f-356">Azure loads the role assembly and searches it for a class that derives from **RoleEntryPoint**.</span></span>
* <span data-ttu-id="2369f-357">如果找到此類別，它會呼叫 **RoleEntryPoint.OnStart()**。</span><span class="sxs-lookup"><span data-stu-id="2369f-357">If it finds this class, it calls **RoleEntryPoint.OnStart()**.</span></span> <span data-ttu-id="2369f-358">您覆寫此方法以初始化背景工作。</span><span class="sxs-lookup"><span data-stu-id="2369f-358">You override this method to initialize your background tasks.</span></span>
* <span data-ttu-id="2369f-359">在 **OnStart** 方法完成後，若存在應用程式的通用檔案，則 Azure 會在其中呼叫 **Application_Start()** (例如，在執行 ASP.NET 的 Web 角色中的 Global.asax)。</span><span class="sxs-lookup"><span data-stu-id="2369f-359">After the **OnStart** method has completed, Azure calls **Application_Start()** in the application’s Global file if this is present (for example, Global.asax in a web role running ASP.NET).</span></span>
* <span data-ttu-id="2369f-360">Azure 在與 **OnStart()** 平行執行的新前景執行緒上呼叫 **RoleEntryPoint.Run()**。</span><span class="sxs-lookup"><span data-stu-id="2369f-360">Azure calls **RoleEntryPoint.Run()** on a new foreground thread that executes in parallel with **OnStart()**.</span></span> <span data-ttu-id="2369f-361">您覆寫此方法以啟動背景工作。</span><span class="sxs-lookup"><span data-stu-id="2369f-361">You override this method to start your background tasks.</span></span>
* <span data-ttu-id="2369f-362">Run 方法結束時，Azure 會先在應用程式的全域檔案 (若存在) 中呼叫 **Application_End()**，然後呼叫 **RoleEntryPoint.OnStop()**。</span><span class="sxs-lookup"><span data-stu-id="2369f-362">When the Run method ends, Azure first calls **Application_End()** in the application’s Global file if this is present, and then calls **RoleEntryPoint.OnStop()**.</span></span> <span data-ttu-id="2369f-363">您覆寫 **OnStop** 方法停止您的背景工作、清除資源、處置物件，並關閉工作可能已經使用的連接。</span><span class="sxs-lookup"><span data-stu-id="2369f-363">You override the **OnStop** method to stop your background tasks, clean up resources, dispose of objects, and close connections that the tasks may have used.</span></span>
* <span data-ttu-id="2369f-364">Azure 背景工作角色主機程序已停止。</span><span class="sxs-lookup"><span data-stu-id="2369f-364">The Azure worker role host process is stopped.</span></span> <span data-ttu-id="2369f-365">此時，角色會被回收並將重新啟動。</span><span class="sxs-lookup"><span data-stu-id="2369f-365">At this point, the role will be recycled and will restart.</span></span>

<span data-ttu-id="2369f-366">如需 **RoleEntryPoint** 類別的使用方法詳細資訊和範例，請參閱 [計算資源彙總模式](http://msdn.microsoft.com/library/dn589778.aspx)(英文)。</span><span class="sxs-lookup"><span data-stu-id="2369f-366">For more details and an example of using the methods of the **RoleEntryPoint** class, see [Compute Resource Consolidation Pattern](http://msdn.microsoft.com/library/dn589778.aspx).</span></span>

#### <a name="implementation-considerations"></a><span data-ttu-id="2369f-367">實作考量</span><span class="sxs-lookup"><span data-stu-id="2369f-367">Implementation considerations</span></span>

<span data-ttu-id="2369f-368">如果您是以 Web 或背景工作角色實作背景工作，請考慮下列幾點：</span><span class="sxs-lookup"><span data-stu-id="2369f-368">Consider the following points if you are implementing background tasks in a web or worker role:</span></span>

* <span data-ttu-id="2369f-369">**RoleEntryPoint** 類別中的預設 **Run** 方法實作包含呼叫 **Thread.Sleep(Timeout.Infinite)**，可保持角色無限期運作。</span><span class="sxs-lookup"><span data-stu-id="2369f-369">The default **Run** method implementation in the **RoleEntryPoint** class contains a call to **Thread.Sleep(Timeout.Infinite)** that keeps the role alive indefinitely.</span></span> <span data-ttu-id="2369f-370">如果您覆寫 **Run** 方法 (這通常是執行背景工作所需要) 的話，除非您想要回收角色執行個體，否則不得允許程式碼從方法中結束。</span><span class="sxs-lookup"><span data-stu-id="2369f-370">If you override the **Run** method (which is typically necessary to execute background tasks), you must not allow your code to exit from the method unless you want to recycle the role instance.</span></span>
* <span data-ttu-id="2369f-371">**Run** 方法的典型實作包含用來啟動每一個背景工作的程式碼，以及定期檢查所有背景工作狀態的迴圈建構。</span><span class="sxs-lookup"><span data-stu-id="2369f-371">A typical implementation of the **Run** method includes code to start each of the background tasks and a loop construct that periodically checks the state of all the background tasks.</span></span> <span data-ttu-id="2369f-372">它可以重新啟動任何失敗，或監視指出作業已完成的取消權杖。</span><span class="sxs-lookup"><span data-stu-id="2369f-372">It can restart any that fail or monitor for cancellation tokens that indicate that jobs have completed.</span></span>
* <span data-ttu-id="2369f-373">如果背景工作擲回未處理的例外狀況，應該回收該工作，同時允許角色中的任何其他背景工作繼續執行。</span><span class="sxs-lookup"><span data-stu-id="2369f-373">If a background task throws an unhandled exception, that task should be recycled while allowing any other background tasks in the role to continue running.</span></span> <span data-ttu-id="2369f-374">不過，如果例外狀況由工作的外部物件損毀所造成，例如共用儲存體，則必須由 **RoleEntryPoint** 類別處理例外狀況，且應該取消所有工作，並允許 **Run** 方法結束。</span><span class="sxs-lookup"><span data-stu-id="2369f-374">However, if the exception is caused by corruption of objects outside the task, such as shared storage, the exception should be handled by your **RoleEntryPoint** class, all tasks should be cancelled, and the **Run** method should be allowed to end.</span></span> <span data-ttu-id="2369f-375">Azure 接著會重新啟動角色。</span><span class="sxs-lookup"><span data-stu-id="2369f-375">Azure will then restart the role.</span></span>
* <span data-ttu-id="2369f-376">使用 **OnStop** 方法來暫停或終止背景工作並清除資源。</span><span class="sxs-lookup"><span data-stu-id="2369f-376">Use the **OnStop** method to pause or kill background tasks and clean up resources.</span></span> <span data-ttu-id="2369f-377">這可能需要停止長時間執行或多步驟的工作。</span><span class="sxs-lookup"><span data-stu-id="2369f-377">This might involve stopping long-running or multistep tasks.</span></span> <span data-ttu-id="2369f-378">請務必考慮如何完成這項動作來避免資料不一致。</span><span class="sxs-lookup"><span data-stu-id="2369f-378">It is vital to consider how this can be done to avoid data inconsistencies.</span></span> <span data-ttu-id="2369f-379">如果角色執行個體因任何使用者起始關機以外的原因停止的話， **OnStop** 方法中執行的程式碼必須在五分鐘內完成，否則它將會強制終止。</span><span class="sxs-lookup"><span data-stu-id="2369f-379">If a role instance stops for any reason other than a user-initiated shutdown, the code running in the **OnStop** method must be completed within five minutes before it is forcibly terminated.</span></span> <span data-ttu-id="2369f-380">請確定您的程式碼可以在這段期間內完成，或是可以容忍執行不完成。</span><span class="sxs-lookup"><span data-stu-id="2369f-380">Ensure that your code can be completed in that time or can tolerate not running to completion.</span></span>  
* <span data-ttu-id="2369f-381">當 **RoleEntryPoint.OnStart** 方法傳回 **true** 時，Azure Load Balancer 會開始將流量導向至角色執行個體。</span><span class="sxs-lookup"><span data-stu-id="2369f-381">The Azure load balancer starts directing traffic to the role instance when the **RoleEntryPoint.OnStart** method returns the value **true**.</span></span> <span data-ttu-id="2369f-382">因此，請考慮將所有初始化程式碼置於 **OnStart** 方法中，讓未成功初始化的角色執行個體不會收到任何流量。</span><span class="sxs-lookup"><span data-stu-id="2369f-382">Therefore, consider putting all your initialization code in the **OnStart** method so that role instances that do not successfully initialize will not receive any traffic.</span></span>
* <span data-ttu-id="2369f-383">除了 **RoleEntryPoint** 類別的方法外，您還可以使用啟動工作。</span><span class="sxs-lookup"><span data-stu-id="2369f-383">You can use startup tasks in addition to the methods of the **RoleEntryPoint** class.</span></span> <span data-ttu-id="2369f-384">您應該使用啟動工作來初始化任何需要在 Azure 負載平衡器中變更的設定，因為這些工作會在角色接收任何要求前執行。</span><span class="sxs-lookup"><span data-stu-id="2369f-384">You should use startup tasks to initialize any settings that you need to change in the Azure load balancer because these tasks will execute before the role receives any requests.</span></span> <span data-ttu-id="2369f-385">如需詳細資訊，請參閱 [Run startup tasks in Azure (在 Azure 中執行啟動工作)](/azure/cloud-services/cloud-services-startup-tasks/)。</span><span class="sxs-lookup"><span data-stu-id="2369f-385">For more information, see [Run startup tasks in Azure](/azure/cloud-services/cloud-services-startup-tasks/).</span></span>
* <span data-ttu-id="2369f-386">如果啟動工作中發生錯誤，它可能會強制角色持續地重新啟動。</span><span class="sxs-lookup"><span data-stu-id="2369f-386">If there is an error in a startup task, it might force the role to continually restart.</span></span> <span data-ttu-id="2369f-387">這可能會防止您執行虛擬 IP (VIP) 位址交換回到先前預備的版本，因為交換需要角色的獨佔存取權。</span><span class="sxs-lookup"><span data-stu-id="2369f-387">This can prevent you from performing a virtual IP (VIP) address swap back to a previously staged version because the swap requires exclusive access to the role.</span></span> <span data-ttu-id="2369f-388">這獨佔存取權無法在角色重新啟動時取得。</span><span class="sxs-lookup"><span data-stu-id="2369f-388">This cannot be obtained while the role is restarting.</span></span> <span data-ttu-id="2369f-389">若要解決這個問題：</span><span class="sxs-lookup"><span data-stu-id="2369f-389">To resolve this:</span></span>
  
  * <span data-ttu-id="2369f-390">在您的角色中，將下列程式碼新增至 **OnStart** 和 **Run** 方法的開頭：</span><span class="sxs-lookup"><span data-stu-id="2369f-390">Add the following code to the beginning of the **OnStart** and **Run** methods in your role:</span></span>
    
    ```C#
    var freeze = CloudConfigurationManager.GetSetting("Freeze");
    if (freeze != null)
    {
     if (Boolean.Parse(freeze))
       {
         Thread.Sleep(System.Threading.Timeout.Infinite);
     }
    }
    ```
    
    * <span data-ttu-id="2369f-391">針對角色，將 **Freeze** 設定的定義做為布林值新增至 ServiceDefinition.csdef 和 ServiceConfiguration.\*.cscfg 檔案，並將它設定為 **false**。</span><span class="sxs-lookup"><span data-stu-id="2369f-391">Add the definition of the **Freeze** setting as a Boolean value to the ServiceDefinition.csdef and ServiceConfiguration.\*.cscfg files for the role and set it to **false**.</span></span> <span data-ttu-id="2369f-392">如果角色進入重複的重新啟動模式，您可以將設定變更為 **true** 以凍結角色執行，並允許它交換先前版本。</span><span class="sxs-lookup"><span data-stu-id="2369f-392">If the role goes into a repeated restart mode, you can change the setting to **true** to freeze role execution and allow it to be swapped with a previous version.</span></span>

#### <a name="more-information"></a><span data-ttu-id="2369f-393">詳細資訊</span><span class="sxs-lookup"><span data-stu-id="2369f-393">More information</span></span>
* [<span data-ttu-id="2369f-394">計算資源彙總模式 (英文)</span><span class="sxs-lookup"><span data-stu-id="2369f-394">Compute Resource Consolidation Pattern</span></span>](http://msdn.microsoft.com/library/dn589778.aspx)
* [<span data-ttu-id="2369f-395">Get started with the Azure WebJobs SDK (開始使用 Azure WebJobs SDK)</span><span class="sxs-lookup"><span data-stu-id="2369f-395">Get started with the Azure WebJobs SDK</span></span>](/azure/app-service-web/websites-dotnet-webjobs-sdk-get-started/)


## <a name="partitioning"></a><span data-ttu-id="2369f-396">分割</span><span class="sxs-lookup"><span data-stu-id="2369f-396">Partitioning</span></span>
<span data-ttu-id="2369f-397">如果您決定讓背景工作加入現有的計算執行個體 (例如 Web 應用程式、Web 角色、現有的背景工作角色，或虛擬機器)，您必須考慮這對計算執行個體的品質屬性和背景工作本身的影響。</span><span class="sxs-lookup"><span data-stu-id="2369f-397">If you decide to include background tasks within an existing compute instance (such as a web app, web role, existing worker role, or virtual machine), you must consider how this will affect the quality attributes of the compute instance and the background task itself.</span></span> <span data-ttu-id="2369f-398">這些因素會幫助您決定是否要以現有的計算執行個體共置工作，或將它們分成不同的計算執行個體：</span><span class="sxs-lookup"><span data-stu-id="2369f-398">These factors will help you to decide whether to colocate the tasks with the existing compute instance or separate them out into a separate compute instance:</span></span>

* <span data-ttu-id="2369f-399">**可用性**：背景工作可能不需要具有應用程式的其他部分所擁有的相同可用性層級，特別是直接參與使用者互動的 UI 和其他部分。</span><span class="sxs-lookup"><span data-stu-id="2369f-399">**Availability**: Background tasks might not need to have the same level of availability as other parts of the application, in particular the UI and other parts that are directly involved in user interaction.</span></span> <span data-ttu-id="2369f-400">由於可將作業排入佇列，背景工作可能更容許延遲、重試的連線失敗，及影響可用性的其他因素。</span><span class="sxs-lookup"><span data-stu-id="2369f-400">Background tasks might be more tolerant of latency, retried connection failures, and other factors that affect availability because the operations can be queued.</span></span> <span data-ttu-id="2369f-401">不過，必須有足夠的容量以防止備份可能會封鎖佇列及影響整個應用程式的要求。</span><span class="sxs-lookup"><span data-stu-id="2369f-401">However, there must be sufficient capacity to prevent the backup of requests that could block queues and affect the application as a whole.</span></span>
* <span data-ttu-id="2369f-402">**延展性**：背景工作對 UI 和應用程式的互動部分，可能有不同的延展性需求。</span><span class="sxs-lookup"><span data-stu-id="2369f-402">**Scalability**: Background tasks are likely to have a different scalability requirement than the UI and the interactive parts of the application.</span></span> <span data-ttu-id="2369f-403">可能需要調整 UI 以符合要求的尖峰期，而未完成的背景工作可在較空閒的時間，由較少的計算執行個體數目完成。</span><span class="sxs-lookup"><span data-stu-id="2369f-403">Scaling the UI might be necessary to meet peaks in demand, while outstanding background tasks might be completed during less busy times by a fewer number of compute instances.</span></span>
* <span data-ttu-id="2369f-404">**恢復功能**：如果僅裝載背景工作的要求可以直到工作再次可用為止，先排入佇列或延遲，則這些工作的計算執行個體失敗可能不會嚴重影響整體應用程式。</span><span class="sxs-lookup"><span data-stu-id="2369f-404">**Resiliency**: Failure of a compute instance that just hosts background tasks might not fatally affect the application as a whole if the requests for these tasks can be queued or postponed until the task is available again.</span></span> <span data-ttu-id="2369f-405">如果計算執行個體及/或工作可以在適當的間隔內重新啟動，可能不會影響應用程式的使用者。</span><span class="sxs-lookup"><span data-stu-id="2369f-405">If the compute instance and/or tasks can be restarted within an appropriate interval, users of the application might not be affected.</span></span>
* <span data-ttu-id="2369f-406">**安全性**：相較於 UI 或應用程式的其他部分，背景工作可能會有不同的安全性需求或限制。</span><span class="sxs-lookup"><span data-stu-id="2369f-406">**Security**: Background tasks might have different security requirements or restrictions than the UI or other parts of the application.</span></span> <span data-ttu-id="2369f-407">藉由使用不同的計算執行個體，您可以為工作指定不同的安全性環境。</span><span class="sxs-lookup"><span data-stu-id="2369f-407">By using a separate compute instance, you can specify a different security environment for the tasks.</span></span> <span data-ttu-id="2369f-408">您也可以使用模式 (例如閘道管理員)，將背景計算執行個體與 UI 隔離，以提供最大的安全性和區隔。</span><span class="sxs-lookup"><span data-stu-id="2369f-408">You can also use patterns such as Gatekeeper to isolate the background compute instances from the UI in order to maximize security and separation.</span></span>
* <span data-ttu-id="2369f-409">**效能**：您可以選擇背景工作的計算執行個體類型，以符合工作的效能特定需求。</span><span class="sxs-lookup"><span data-stu-id="2369f-409">**Performance**: You can choose the type of compute instance for background tasks to specifically match the performance requirements of the tasks.</span></span> <span data-ttu-id="2369f-410">這可能代表當工作不需要與 UI 具有相同的處理能力的話，可使用較便宜的計算選項；或如果他們需要額外的容量和資源的話，則需要更大的執行個體。</span><span class="sxs-lookup"><span data-stu-id="2369f-410">This might mean using a less expensive compute option if the tasks do not require the same processing capabilities as the UI, or a larger instance if they require additional capacity and resources.</span></span>
* <span data-ttu-id="2369f-411">**可管理性**：相較於主應用程式程式碼或 UI，背景工作可能有不同的開發和部署節奏。</span><span class="sxs-lookup"><span data-stu-id="2369f-411">**Manageability**: Background tasks might have a different development and deployment rhythm from the main application code or the UI.</span></span> <span data-ttu-id="2369f-412">將它們部署到不同的計算執行個體可簡化更新與版本控制。</span><span class="sxs-lookup"><span data-stu-id="2369f-412">Deploying them to a separate compute instance can simplify updates and versioning.</span></span>
* <span data-ttu-id="2369f-413">**成本**：加入計算執行個體來執行背景工作會增加裝載成本。</span><span class="sxs-lookup"><span data-stu-id="2369f-413">**Cost**: Adding compute instances to execute background tasks increases hosting costs.</span></span> <span data-ttu-id="2369f-414">您應該仔細考量額外的容量與這些額外的成本之間的取捨。</span><span class="sxs-lookup"><span data-stu-id="2369f-414">You should carefully consider the trade-off between additional capacity and these extra costs.</span></span>

<span data-ttu-id="2369f-415">如需詳細資訊，請參閱 [Leader Election Pattern (前置選擇模式)](http://msdn.microsoft.com/library/dn568104.aspx) 和 [Competing Consumers Pattern (競爭取用者模式)](http://msdn.microsoft.com/library/dn568101.aspx)。</span><span class="sxs-lookup"><span data-stu-id="2369f-415">For more information, see [Leader Election Pattern](http://msdn.microsoft.com/library/dn568104.aspx) and [Competing Consumers Pattern](http://msdn.microsoft.com/library/dn568101.aspx).</span></span>

## <a name="conflicts"></a><span data-ttu-id="2369f-416">衝突</span><span class="sxs-lookup"><span data-stu-id="2369f-416">Conflicts</span></span>
<span data-ttu-id="2369f-417">如果您有背景作業的多個執行個體，它們就可能爭用資源和服務的存取權，例如資料庫和儲存體。</span><span class="sxs-lookup"><span data-stu-id="2369f-417">If you have multiple instances of a background job, it is possible that they will compete for access to resources and services, such as databases and storage.</span></span> <span data-ttu-id="2369f-418">這個並行存取可能會導致資源爭用情況，其可能會造成服務可用性及儲存體中資料完整性衝突。</span><span class="sxs-lookup"><span data-stu-id="2369f-418">This concurrent access can result in resource contention, which might cause conflicts in availability of the services and in the integrity of data in storage.</span></span> <span data-ttu-id="2369f-419">您可以使用悲觀鎖定方法來解決資源爭用的情況。</span><span class="sxs-lookup"><span data-stu-id="2369f-419">You can resolve resource contention by using a pessimistic locking approach.</span></span> <span data-ttu-id="2369f-420">這可避免相互競爭的工作執行個體同時存取服務或損毀資料。</span><span class="sxs-lookup"><span data-stu-id="2369f-420">This prevents competing instances of a task from concurrently accessing a service or corrupting data.</span></span>

<span data-ttu-id="2369f-421">另一種解決衝突的方法是將背景工作定義為單一性，如此只有一個執行中的執行個體。</span><span class="sxs-lookup"><span data-stu-id="2369f-421">Another approach to resolve conflicts is to define background tasks as a singleton, so that there is only ever one instance running.</span></span> <span data-ttu-id="2369f-422">不過，這會排除多個執行個體設定可提供的可靠性和效能權益。</span><span class="sxs-lookup"><span data-stu-id="2369f-422">However, this eliminates the reliability and performance benefits that a multiple-instance configuration can provide.</span></span> <span data-ttu-id="2369f-423">若 UI 可以提供足夠的工作，以讓多個背景工作保持忙碌時更是如此。</span><span class="sxs-lookup"><span data-stu-id="2369f-423">This is especially true if the UI can supply sufficient work to keep more than one background task busy.</span></span>

<span data-ttu-id="2369f-424">請務必確定背景工作可以自動重新啟動，而且它有足夠的容量來應付需求的尖峰期。</span><span class="sxs-lookup"><span data-stu-id="2369f-424">It is vital to ensure that the background task can automatically restart and that it has sufficient capacity to cope with peaks in demand.</span></span> <span data-ttu-id="2369f-425">您可配置給計算執行個體足夠的資源、實作可儲存要求的佇列機制，供稍後需求降低時執行；或使用這些技術組合，藉此完成這個工作。</span><span class="sxs-lookup"><span data-stu-id="2369f-425">You can achieve this by allocating a compute instance with sufficient resources, by implementing a queueing mechanism that can store requests for later execution when demand decreases, or by using a combination of these techniques.</span></span>

## <a name="coordination"></a><span data-ttu-id="2369f-426">協調</span><span class="sxs-lookup"><span data-stu-id="2369f-426">Coordination</span></span>
<span data-ttu-id="2369f-427">背景工作可能很複雜，而且可能需要執行多個個別的工作以產生結果或滿足所有需求。</span><span class="sxs-lookup"><span data-stu-id="2369f-427">The background tasks might be complex and might require multiple individual tasks to execute to produce a result or to fulfil all the requirements.</span></span> <span data-ttu-id="2369f-428">通常在這些案例中可將工作分成較小的步驟或子工作，並由多個取用者執行。</span><span class="sxs-lookup"><span data-stu-id="2369f-428">It is common in these scenarios to divide the task into smaller discreet steps or subtasks that can be executed by multiple consumers.</span></span> <span data-ttu-id="2369f-429">多步驟作業可以更有效率且更具彈性，因為個別步驟可能可在多個作業中重複使用。</span><span class="sxs-lookup"><span data-stu-id="2369f-429">Multistep jobs can be more efficient and more flexible because individual steps might be reusable in multiple jobs.</span></span> <span data-ttu-id="2369f-430">它也能輕鬆地新增、移除或修改步驟的順序。</span><span class="sxs-lookup"><span data-stu-id="2369f-430">It is also easy to add, remove, or modify the order of the steps.</span></span>

<span data-ttu-id="2369f-431">協調多個工作和步驟可能相當困難，但是有三種常見的模式可用來引導您的實作方案：</span><span class="sxs-lookup"><span data-stu-id="2369f-431">Coordinating multiple tasks and steps can be challenging, but there are three common patterns that you can use to guide your implementation of a solution:</span></span>

* <span data-ttu-id="2369f-432">**將一個工作分解成多個可重複使用的步驟**。</span><span class="sxs-lookup"><span data-stu-id="2369f-432">**Decomposing a task into multiple reusable steps**.</span></span> <span data-ttu-id="2369f-433">應用程式可能需要在其處理的資訊上，執行具有不同複雜度的各種工作。</span><span class="sxs-lookup"><span data-stu-id="2369f-433">An application might be required to perform a variety of tasks of varying complexity on the information that it processes.</span></span> <span data-ttu-id="2369f-434">有一項實作此應用程式簡單但具彈性的方法，此方法為將這項處理序作為整合模組執行。</span><span class="sxs-lookup"><span data-stu-id="2369f-434">A straightforward but inflexible approach to implementing this application might be to perform this processing as a monolithic module.</span></span> <span data-ttu-id="2369f-435">不過，這種方法可能會降低重構程式碼、最佳化它，或在應用程式的其他位置需要相同處理程序的部分時，重複使用它的機會。</span><span class="sxs-lookup"><span data-stu-id="2369f-435">However, this approach is likely to reduce the opportunities for refactoring the code, optimizing it, or reusing it if parts of the same processing are required elsewhere within the application.</span></span> <span data-ttu-id="2369f-436">如需詳細資訊，請參閱 [管道與篩選模式](http://msdn.microsoft.com/library/dn568100.aspx)(英文)。</span><span class="sxs-lookup"><span data-stu-id="2369f-436">For more information, see [Pipes and Filters Pattern](http://msdn.microsoft.com/library/dn568100.aspx).</span></span>
* <span data-ttu-id="2369f-437">**管理工作的步驟執行**。</span><span class="sxs-lookup"><span data-stu-id="2369f-437">**Managing execution of the steps for a task**.</span></span> <span data-ttu-id="2369f-438">應用程式可能會執行包含數個步驟 (其中有些可能會叫用遠端服務或存取遠端資源) 的工作。</span><span class="sxs-lookup"><span data-stu-id="2369f-438">An application might perform tasks that comprise a number of steps (some of which might invoke remote services or access remote resources).</span></span> <span data-ttu-id="2369f-439">個別的步驟可能會彼此獨立，但是它們會由實作工作的應用程式邏輯進行協調。</span><span class="sxs-lookup"><span data-stu-id="2369f-439">The individual steps might be independent of each other, but they are orchestrated by the application logic that implements the task.</span></span> <span data-ttu-id="2369f-440">如需詳細資訊，請參閱 [排程器代理程式監督員模式](http://msdn.microsoft.com/library/dn589780.aspx)(英文)。</span><span class="sxs-lookup"><span data-stu-id="2369f-440">For more information, see [Scheduler Agent Supervisor Pattern](http://msdn.microsoft.com/library/dn589780.aspx).</span></span>
* <span data-ttu-id="2369f-441">**管理失敗工作步驟的復原**。</span><span class="sxs-lookup"><span data-stu-id="2369f-441">**Managing recovery for task steps that fail**.</span></span> <span data-ttu-id="2369f-442">如果一個或多個步驟失敗，應用程式可能需要對執行一系列步驟的工作進行復原 (它們會共同定義最終的一致作業)。</span><span class="sxs-lookup"><span data-stu-id="2369f-442">An application might need to undo the work that is performed by a series of steps (which together define an eventually consistent operation) if one or more of the steps fail.</span></span> <span data-ttu-id="2369f-443">如需詳細資訊，請參閱 [補償交易模式](http://msdn.microsoft.com/library/dn589804.aspx)(英文)。</span><span class="sxs-lookup"><span data-stu-id="2369f-443">For more information, see [Compensating Transaction Pattern](http://msdn.microsoft.com/library/dn589804.aspx).</span></span>


## <a name="resiliency-considerations"></a><span data-ttu-id="2369f-444">恢復功能考量</span><span class="sxs-lookup"><span data-stu-id="2369f-444">Resiliency considerations</span></span>
<span data-ttu-id="2369f-445">背景工作必須具有恢復功能，以便為應用程式提供可靠的服務。</span><span class="sxs-lookup"><span data-stu-id="2369f-445">Background tasks must be resilient in order to provide reliable services to the application.</span></span> <span data-ttu-id="2369f-446">當您規劃和設計背景工作時，請考慮下列幾點：</span><span class="sxs-lookup"><span data-stu-id="2369f-446">When you are planning and designing background tasks, consider the following points:</span></span>

* <span data-ttu-id="2369f-447">背景工作必須能正常處理角色或服務重新啟動，而不會損毀資料或導致應用程式不一致。</span><span class="sxs-lookup"><span data-stu-id="2369f-447">Background tasks must be able to gracefully handle role or service restarts without corrupting data or introducing inconsistency into the application.</span></span> <span data-ttu-id="2369f-448">對於長時間執行或多步驟的工作，請考慮使用「檢查指出」  ，方法是在永續性儲存體中儲存作業狀態，或在佇列中作為訊息儲存 (如果這是適當的)。</span><span class="sxs-lookup"><span data-stu-id="2369f-448">For long-running or multistep tasks, consider using *check pointing* by saving the state of jobs in persistent storage, or as messages in a queue if this is appropriate.</span></span> <span data-ttu-id="2369f-449">例如，您可以在佇列的訊息中永久保存狀態資訊，並使用工作進度累加地更新此狀態資訊，以便從上次已知的良好檢查點處理工作，而不是從頭重新啟動。</span><span class="sxs-lookup"><span data-stu-id="2369f-449">For example, you can persist state information in a message in a queue and incrementally update this state information with the task progress so that the task can be processed from the last known good checkpoint--instead of restarting from the beginning.</span></span> <span data-ttu-id="2369f-450">使用 Azure 服務匯流排佇列時，您可以使用訊息工作階段來啟用相同的案例。</span><span class="sxs-lookup"><span data-stu-id="2369f-450">When using Azure Service Bus queues, you can use message sessions to enable the same scenario.</span></span> <span data-ttu-id="2369f-451">工作階段可讓您使用 [SetState](https://docs.microsoft.com/dotnet/api/microsoft.servicebus.messaging.messagesession.setstate?view=azureservicebus-4.0.0) 和 [GetState](https://docs.microsoft.com/dotnet/api/microsoft.servicebus.messaging.messagesession.getstate?view=azureservicebus-4.0.0) 方法來儲存和擷取應用程式處理狀態。</span><span class="sxs-lookup"><span data-stu-id="2369f-451">Sessions allow you to save and retrieve the application processing state by using the [SetState](https://docs.microsoft.com/dotnet/api/microsoft.servicebus.messaging.messagesession.setstate?view=azureservicebus-4.0.0) and [GetState](https://docs.microsoft.com/dotnet/api/microsoft.servicebus.messaging.messagesession.getstate?view=azureservicebus-4.0.0) methods.</span></span> <span data-ttu-id="2369f-452">如需設計可靠的多步驟處理序和工作流程詳細資訊，請參閱 [Scheduler Agent Supervisor Pattern (排程器代理程式監督員模式)](http://msdn.microsoft.com/library/dn589780.aspx)。</span><span class="sxs-lookup"><span data-stu-id="2369f-452">For more information about designing reliable multistep processes and workflows, see [Scheduler Agent Supervisor Pattern](http://msdn.microsoft.com/library/dn589780.aspx).</span></span>
* <span data-ttu-id="2369f-453">使用 Web 或背景工作角色來裝載多個背景工作時，請設計 **Run** 方法的覆寫來監視失敗或已停止的工作，並重新啟動它們。</span><span class="sxs-lookup"><span data-stu-id="2369f-453">When you use web or worker roles to host multiple background tasks, design your override of the **Run** method to monitor for failed or stalled tasks, and restart them.</span></span> <span data-ttu-id="2369f-454">若不實用，而且您正在使用背景工作角色，請從 **Run** 方法退出，以強制重新啟動背景工作角色。</span><span class="sxs-lookup"><span data-stu-id="2369f-454">Where this is not practical, and you are using a worker role, force the worker role to restart by exiting from the **Run** method.</span></span>
* <span data-ttu-id="2369f-455">當您使用佇列與背景工作通訊時，佇列可在應用程式高於一般負載時，作為緩衝區來儲存傳送給工作的要求。</span><span class="sxs-lookup"><span data-stu-id="2369f-455">When you use queues to communicate with background tasks, the queues can act as a buffer to store requests that are sent to the tasks while the application is under higher than usual load.</span></span> <span data-ttu-id="2369f-456">如此能讓工作在較空閒期間使用 UI。</span><span class="sxs-lookup"><span data-stu-id="2369f-456">This allows the tasks to catch up with the UI during less busy periods.</span></span> <span data-ttu-id="2369f-457">這也表示回收角色不會封鎖 UI。</span><span class="sxs-lookup"><span data-stu-id="2369f-457">It also means that recycling the role will not block the UI.</span></span> <span data-ttu-id="2369f-458">如需詳細資訊，請參閱 [佇列型負載調節模式](http://msdn.microsoft.com/library/dn589783.aspx)(英文)。</span><span class="sxs-lookup"><span data-stu-id="2369f-458">For more information, see [Queue-Based Load Leveling Pattern](http://msdn.microsoft.com/library/dn589783.aspx).</span></span> <span data-ttu-id="2369f-459">如果某些工作比其他工作更重要，請考慮實作 [優先順序佇列模式](http://msdn.microsoft.com/library/dn589794.aspx) (英文)，確保這些工作在較不重要的工作之前執行。</span><span class="sxs-lookup"><span data-stu-id="2369f-459">If some tasks are more important than others, consider implementing the [Priority Queue Pattern](http://msdn.microsoft.com/library/dn589794.aspx) to ensure that these tasks run before less important ones.</span></span>
* <span data-ttu-id="2369f-460">必須將由訊息或處理訊息初始化的背景工作設計為能夠處理不一致情況，例如以錯誤順序到達的訊息、重複導致錯誤的訊息 (通常稱為「有害訊息」 )，以及多次傳遞的訊息。</span><span class="sxs-lookup"><span data-stu-id="2369f-460">Background tasks that are initiated by messages or process messages must be designed to handle inconsistencies, such as messages arriving out of order, messages that repeatedly cause an error (often referred to as *poison messages*), and messages that are delivered more than once.</span></span> <span data-ttu-id="2369f-461">請考慮下列：</span><span class="sxs-lookup"><span data-stu-id="2369f-461">Consider the following:</span></span>
  * <span data-ttu-id="2369f-462">必須依特定順序處理訊息，像是根據其現有值變更資料的訊息 (例如，將值加入至現有值)，可能不會以其原始的傳送順序到達。</span><span class="sxs-lookup"><span data-stu-id="2369f-462">Messages that must be processed in a specific order, such as those that change data based on the existing data value (for example, adding a value to an existing value), might not arrive in the original order in which they were sent.</span></span> <span data-ttu-id="2369f-463">或者，可能因每個執行個體上變動的負載，而依不同順序由背景工作的不同執行個體處理。</span><span class="sxs-lookup"><span data-stu-id="2369f-463">Alternatively, they might be handled by different instances of a background task in a different order due to varying loads on each instance.</span></span> <span data-ttu-id="2369f-464">必須依特定順序處理的訊息應該包含序號、金鑰或其他某些指標，好讓背景工作使用以確保能依正確的順序處理這些訊息。</span><span class="sxs-lookup"><span data-stu-id="2369f-464">Messages that must be processed in a specific order should include a sequence number, key, or some other indicator that background tasks can use to ensure that they are processed in the correct order.</span></span> <span data-ttu-id="2369f-465">如果您使用 Azure 服務匯流排，您可以使用訊息工作階段來保證傳遞順序。</span><span class="sxs-lookup"><span data-stu-id="2369f-465">If you are using Azure Service Bus, you can use message sessions to guarantee the order of delivery.</span></span> <span data-ttu-id="2369f-466">不過，盡可能設計處理序以讓訊息順序變得不重要，通常會更有效率。</span><span class="sxs-lookup"><span data-stu-id="2369f-466">However, it is usually more efficient, where possible, to design the process so that the message order is not important.</span></span>
  * <span data-ttu-id="2369f-467">一般而言，背景工作會在佇列中查看訊息，這會暫時對其他訊息取用者隱藏這些訊息。</span><span class="sxs-lookup"><span data-stu-id="2369f-467">Typically, a background task will peek at messages in the queue, which temporarily hides them from other message consumers.</span></span> <span data-ttu-id="2369f-468">然後它會在成功處理完畢後刪除訊息。</span><span class="sxs-lookup"><span data-stu-id="2369f-468">Then it deletes the messages after they have been successfully processed.</span></span> <span data-ttu-id="2369f-469">如果背景工作在處理訊息時失敗，該訊息將會在查看逾時到期之後重新出現在佇列上。</span><span class="sxs-lookup"><span data-stu-id="2369f-469">If a background task fails when processing a message, that message will reappear on the queue after the peek time-out expires.</span></span> <span data-ttu-id="2369f-470">它將會由工作的另一個執行個體進行處理，或在此執行個體的下一個處理週期進行處理。</span><span class="sxs-lookup"><span data-stu-id="2369f-470">It will be processed by another instance of the task or during the next processing cycle of this instance.</span></span> <span data-ttu-id="2369f-471">如果訊息在取用者中發生相同的錯誤，它會封鎖工作、佇列，最終在佇列已滿時封鎖應用程式本身。</span><span class="sxs-lookup"><span data-stu-id="2369f-471">If the message consistently causes an error in the consumer, it will block the task, the queue, and eventually the application itself when the queue becomes full.</span></span> <span data-ttu-id="2369f-472">因此，請務必從佇列偵測並移除有害訊息。</span><span class="sxs-lookup"><span data-stu-id="2369f-472">Therefore, it is vital to detect and remove poison messages from the queue.</span></span> <span data-ttu-id="2369f-473">如果您使用 Azure 服務匯流排，造成錯誤的訊息可能會被自動或手動地移至相關聯的無效信件佇列。</span><span class="sxs-lookup"><span data-stu-id="2369f-473">If you are using Azure Service Bus, messages that cause an error can be moved automatically or manually to an associated dead letter queue.</span></span>
  * <span data-ttu-id="2369f-474">佇列會保證「至少一次」  使用傳遞機制，但它們可能會傳遞相同的訊息多次。</span><span class="sxs-lookup"><span data-stu-id="2369f-474">Queues are guaranteed at *least once* delivery mechanisms, but they might deliver the same message more than once.</span></span> <span data-ttu-id="2369f-475">此外，如果背景工作在處理訊息後、但在從佇列刪除前失敗，訊息將會變成可再次處理。</span><span class="sxs-lookup"><span data-stu-id="2369f-475">In addition, if a background task fails after processing a message but before deleting it from the queue, the message will become available for processing again.</span></span> <span data-ttu-id="2369f-476">背景工作應該具有等冪性，這表示超過一次處理相同的訊息不會造成錯誤，或使應用程式的資料不一致。</span><span class="sxs-lookup"><span data-stu-id="2369f-476">Background tasks should be idempotent, which means that processing the same message more than once does not cause an error or inconsistency in the application’s data.</span></span> <span data-ttu-id="2369f-477">某些作業自然是等冪，例如將儲存的值設為特定的新值。</span><span class="sxs-lookup"><span data-stu-id="2369f-477">Some operations are naturally idempotent, such as setting a stored value to a specific new value.</span></span> <span data-ttu-id="2369f-478">不過，將值加入到現有的儲存值，而不檢查儲存值是否仍然與原先傳送的訊息相同之類的作業，可能會導致不一致情況。</span><span class="sxs-lookup"><span data-stu-id="2369f-478">However, operations such as adding a value to an existing stored value without checking that the stored value is still the same as when the message was originally sent will cause inconsistencies.</span></span> <span data-ttu-id="2369f-479">Azure 服務匯流排佇列可以設定為自動移除重複的訊息。</span><span class="sxs-lookup"><span data-stu-id="2369f-479">Azure Service Bus queues can be configured to automatically remove duplicated messages.</span></span>
  * <span data-ttu-id="2369f-480">某些傳訊系統 (例如 Azure 儲存體佇列和 Azure 服務匯流排佇列) 支援 de-queue count 屬性，指出已從佇列讀取訊息的次數。</span><span class="sxs-lookup"><span data-stu-id="2369f-480">Some messaging systems, such as Azure storage queues and Azure Service Bus queues, support a de-queue count property that indicates the number of times a message has been read from the queue.</span></span> <span data-ttu-id="2369f-481">這在處理重複及有害訊息時很有用。</span><span class="sxs-lookup"><span data-stu-id="2369f-481">This can be useful in handling repeated and poison messages.</span></span> <span data-ttu-id="2369f-482">如需詳細資訊，請參閱[非同步傳訊入門](http://msdn.microsoft.com/library/dn589781.aspx)和[等冪性模式](http://blog.jonathanoliver.com/2010/04/idempotency-patterns/)。</span><span class="sxs-lookup"><span data-stu-id="2369f-482">For more information, see [Asynchronous Messaging Primer](http://msdn.microsoft.com/library/dn589781.aspx) and [Idempotency Patterns](http://blog.jonathanoliver.com/2010/04/idempotency-patterns/).</span></span>

## <a name="scaling-and-performance-considerations"></a><span data-ttu-id="2369f-483">調整和效能考量</span><span class="sxs-lookup"><span data-stu-id="2369f-483">Scaling and performance considerations</span></span>
<span data-ttu-id="2369f-484">背景工作必須提供足夠的效能，確保它們不會封鎖應用程式，或不會因系統負載不足而延遲作業時導致不一致。</span><span class="sxs-lookup"><span data-stu-id="2369f-484">Background tasks must offer sufficient performance to ensure they do not block the application, or cause inconsistencies due to delayed operation when the system is under load.</span></span> <span data-ttu-id="2369f-485">一般而言，藉由調整裝載背景工作的計算執行個體可提升效能。</span><span class="sxs-lookup"><span data-stu-id="2369f-485">Typically, performance is improved by scaling the compute instances that host the background tasks.</span></span> <span data-ttu-id="2369f-486">當您規劃和設計背景工作時，請考慮下列有關延展性和效能的重點：</span><span class="sxs-lookup"><span data-stu-id="2369f-486">When you are planning and designing background tasks, consider the following points around scalability and performance:</span></span>

* <span data-ttu-id="2369f-487">Azure 會根據目前的需求和負載，或預先定義的排程，來支援 Web 應用程式、雲端服務 Web 和背景工作角色，及虛擬機器裝載部署的自動調整 (向外及往內延展都支援)。</span><span class="sxs-lookup"><span data-stu-id="2369f-487">Azure supports autoscaling (both scaling out and scaling back in) based on current demand and load--or on a predefined schedule, for Web Apps, Cloud Services web and worker roles, and Virtual Machines hosted deployments.</span></span> <span data-ttu-id="2369f-488">使用此功能可確保整體應用程式具備足夠的效能，同時將執行階段成本降到最低。</span><span class="sxs-lookup"><span data-stu-id="2369f-488">Use this feature to ensure that the application as a whole has sufficient performance capabilities while minimizing runtime costs.</span></span>
* <span data-ttu-id="2369f-489">當背景工作具有雲端服務應用程式的其他部分的不同效能時 (例如，UI 或元件，如資料存取層)，可將不同背景工作角色的背景工作裝載在一起，讓 UI 和背景工作角色進行調整而不理會負載管理。</span><span class="sxs-lookup"><span data-stu-id="2369f-489">Where background tasks have a different performance capability from the other parts of a Cloud Services application (for example, the UI or components such as the data access layer), hosting the background tasks together in a separate worker role allows the UI and background task roles to scale independently to manage the load.</span></span> <span data-ttu-id="2369f-490">如果多個背景工作彼此有明顯不同的效能，請考慮將它們分成不同的背景工作角色並單獨調整每個角色類型。</span><span class="sxs-lookup"><span data-stu-id="2369f-490">If multiple background tasks have significantly different performance capabilities from each other, consider dividing them into separate worker roles and scaling each role type independently.</span></span> <span data-ttu-id="2369f-491">但請注意，相較於將所有工作結合成較少的角色，這可能會增加執行階段成本。</span><span class="sxs-lookup"><span data-stu-id="2369f-491">However, note that this might increase runtime costs compared to combining all the tasks into fewer roles.</span></span>
* <span data-ttu-id="2369f-492">只是調整角色可能不足以防止在高負載下損失效能。</span><span class="sxs-lookup"><span data-stu-id="2369f-492">Simply scaling the roles might not be sufficient to prevent loss of performance under load.</span></span> <span data-ttu-id="2369f-493">您也可能需要調整儲存體佇列和其他資源，以避免整體處理鏈的單一點成為瓶頸。</span><span class="sxs-lookup"><span data-stu-id="2369f-493">You might also need to scale storage queues and other resources to prevent a single point of the overall processing chain from becoming a bottleneck.</span></span> <span data-ttu-id="2369f-494">另外，請考慮其他限制，例如儲存體的最大輸送量，和應用程式和背景工作依賴的其他服務。</span><span class="sxs-lookup"><span data-stu-id="2369f-494">Also, consider other limitations, such as the maximum throughput of storage and other services that the application and the background tasks rely on.</span></span>
* <span data-ttu-id="2369f-495">您必須針對調整設計背景工作。</span><span class="sxs-lookup"><span data-stu-id="2369f-495">Background tasks must be designed for scaling.</span></span> <span data-ttu-id="2369f-496">比方說，他們必須能夠以動態方式偵測正在使用的儲存體佇列數目，以接聽或傳送訊息給適當的佇列。</span><span class="sxs-lookup"><span data-stu-id="2369f-496">For example, they must be able to dynamically detect the number of storage queues in use in order to listen on or send messages to the appropriate queue.</span></span>
* <span data-ttu-id="2369f-497">根據預設，WebJobs 會根據相關聯的 Azure Web 應用程式執行個體來調整。</span><span class="sxs-lookup"><span data-stu-id="2369f-497">By default, WebJobs scale with their associated Azure Web Apps instance.</span></span> <span data-ttu-id="2369f-498">不過，如果您只想要將 WebJob 當作單一執行個體來執行，您可以建立包含 JSON 資料 **{ "is_singleton": true }** 的 Settings.job 檔案。</span><span class="sxs-lookup"><span data-stu-id="2369f-498">However, if you want a WebJob to run as only a single instance, you can create a Settings.job file that contains the JSON data **{ "is_singleton": true }**.</span></span> <span data-ttu-id="2369f-499">這會強制 Azure 只能執行單一 Web 工作的執行個體，即使有多個相關聯的 Web 應用程式執行個體也一樣。</span><span class="sxs-lookup"><span data-stu-id="2369f-499">This forces Azure to only run one instance of the WebJob, even if there are multiple instances of the associated web app.</span></span> <span data-ttu-id="2369f-500">這可能是針對必須執行為單一執行個體之排程作業的有用技巧。</span><span class="sxs-lookup"><span data-stu-id="2369f-500">This can be a useful technique for scheduled jobs that must run as only a single instance.</span></span>

## <a name="related-patterns"></a><span data-ttu-id="2369f-501">相關的模式</span><span class="sxs-lookup"><span data-stu-id="2369f-501">Related patterns</span></span>
* [<span data-ttu-id="2369f-502">非同步傳訊入門 (英文)</span><span class="sxs-lookup"><span data-stu-id="2369f-502">Asynchronous Messaging Primer</span></span>](http://msdn.microsoft.com/library/dn589781.aspx)
* [<span data-ttu-id="2369f-503">自動調整指引 (英文)</span><span class="sxs-lookup"><span data-stu-id="2369f-503">Autoscaling Guidance</span></span>](http://msdn.microsoft.com/library/dn589774.aspx)
* [<span data-ttu-id="2369f-504">補償交易模式 (英文)</span><span class="sxs-lookup"><span data-stu-id="2369f-504">Compensating Transaction Pattern</span></span>](http://msdn.microsoft.com/library/dn589804.aspx)
* [<span data-ttu-id="2369f-505">競爭取用者模式 (英文)</span><span class="sxs-lookup"><span data-stu-id="2369f-505">Competing Consumers Pattern</span></span>](http://msdn.microsoft.com/library/dn568101.aspx)
* [<span data-ttu-id="2369f-506">計算分割指引 (英文)</span><span class="sxs-lookup"><span data-stu-id="2369f-506">Compute Partitioning Guidance</span></span>](http://msdn.microsoft.com/library/dn589773.aspx)
* [<span data-ttu-id="2369f-507">計算資源彙總模式 (英文)</span><span class="sxs-lookup"><span data-stu-id="2369f-507">Compute Resource Consolidation Pattern</span></span>](http://msdn.microsoft.com/library/dn589778.aspx)
* [<span data-ttu-id="2369f-508">閘道管理員模式 (英文)</span><span class="sxs-lookup"><span data-stu-id="2369f-508">Gatekeeper Pattern</span></span>](http://msdn.microsoft.com/library/dn589793.aspx)
* [<span data-ttu-id="2369f-509">選出領導者模式 (英文)</span><span class="sxs-lookup"><span data-stu-id="2369f-509">Leader Election Pattern</span></span>](http://msdn.microsoft.com/library/dn568104.aspx)
* [<span data-ttu-id="2369f-510">管道與篩選器 (英文)</span><span class="sxs-lookup"><span data-stu-id="2369f-510">Pipes and Filters Pattern</span></span>](http://msdn.microsoft.com/library/dn568100.aspx)
* [<span data-ttu-id="2369f-511">優先順序佇列模式 (英文)</span><span class="sxs-lookup"><span data-stu-id="2369f-511">Priority Queue Pattern</span></span>](http://msdn.microsoft.com/library/dn589794.aspx)
* [<span data-ttu-id="2369f-512">Queue-based Load Leveling Pattern (佇列型負載調節模式)</span><span class="sxs-lookup"><span data-stu-id="2369f-512">Queue-based Load Leveling Pattern</span></span>](http://msdn.microsoft.com/library/dn589783.aspx)
* [<span data-ttu-id="2369f-513">排程器代理程式監督員模式 (英文)</span><span class="sxs-lookup"><span data-stu-id="2369f-513">Scheduler Agent Supervisor Pattern</span></span>](http://msdn.microsoft.com/library/dn589780.aspx)

## <a name="more-information"></a><span data-ttu-id="2369f-514">詳細資訊</span><span class="sxs-lookup"><span data-stu-id="2369f-514">More information</span></span>
* [<span data-ttu-id="2369f-515">調整使用背景工作角色的 Azure 應用程式 (英文)</span><span class="sxs-lookup"><span data-stu-id="2369f-515">Scaling Azure Applications with Worker Roles</span></span>](http://msdn.microsoft.com/library/hh534484.aspx#sec8)
* [<span data-ttu-id="2369f-516">執行背景工作 (英文)</span><span class="sxs-lookup"><span data-stu-id="2369f-516">Executing Background Tasks</span></span>](http://msdn.microsoft.com/library/ff803365.aspx)
* <span data-ttu-id="2369f-517">[Azure 角色啟動生命週期](http://blog.syntaxc4.net/post/2011/04/13/windows-azure-role-startup-life-cycle.aspx) (英文) (部落格文章)</span><span class="sxs-lookup"><span data-stu-id="2369f-517">[Azure Role Startup Life Cycle](http://blog.syntaxc4.net/post/2011/04/13/windows-azure-role-startup-life-cycle.aspx) (blog post)</span></span>
* <span data-ttu-id="2369f-518">[Azure 雲端服務角色生命週期](http://channel9.msdn.com/Series/Windows-Azure-Cloud-Services-Tutorials/Windows-Azure-Cloud-Services-Role-Lifecycle) (英文) (影片)</span><span class="sxs-lookup"><span data-stu-id="2369f-518">[Azure Cloud Services Role Lifecycle](http://channel9.msdn.com/Series/Windows-Azure-Cloud-Services-Tutorials/Windows-Azure-Cloud-Services-Role-Lifecycle) (video)</span></span>
* [<span data-ttu-id="2369f-519">什麼是 Azure WebJob SDK</span><span class="sxs-lookup"><span data-stu-id="2369f-519">What is the Azure WebJobs SDK</span></span>](https://docs.microsoft.com/azure/app-service-web/websites-dotnet-webjobs-sdk)
* [<span data-ttu-id="2369f-520">使用 WebJob 執行背景工作</span><span class="sxs-lookup"><span data-stu-id="2369f-520">Run Background tasks with WebJobs</span></span>](https://docs.microsoft.com/azure/app-service-web/web-sites-create-web-jobs)
* [<span data-ttu-id="2369f-521">Azure 佇列和服務匯流排佇列 - 異同比較 (英文)</span><span class="sxs-lookup"><span data-stu-id="2369f-521">Azure Queues and Service Bus Queues - Compared and Contrasted</span></span>](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-azure-and-service-bus-queues-compared-contrasted)
* [<span data-ttu-id="2369f-522">如何在雲端服務中啟用診斷</span><span class="sxs-lookup"><span data-stu-id="2369f-522">How to Enable Diagnostics in a Cloud Service</span></span>](https://docs.microsoft.com/azure/cloud-services/cloud-services-dotnet-diagnostics)

