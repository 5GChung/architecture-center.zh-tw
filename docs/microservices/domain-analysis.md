---
title: 微服務的領域分析
description: 微服務的領域分析
author: MikeWasson
ms.date: 12/08/2017
ms.openlocfilehash: c3c353a6b30507369357af4b520a51f8afc2fb8d
ms.sourcegitcommit: 3d6dba524cc7661740bdbaf43870de7728d60a01
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/11/2018
ms.locfileid: "27765981"
---
# <a name="designing-microservices-domain-analysis"></a><span data-ttu-id="6cae4-103">設計微服務：領域分析</span><span class="sxs-lookup"><span data-stu-id="6cae4-103">Designing microservices: Domain analysis</span></span> 

<span data-ttu-id="6cae4-104">微服務最大的挑戰之一是如何定義個別服務之間的界限。</span><span class="sxs-lookup"><span data-stu-id="6cae4-104">One of the biggest challenges of microservices is to define the boundaries of individual services.</span></span> <span data-ttu-id="6cae4-105">一般來說，一種服務應該「只做一件事」，但實際情況下這未必適用。</span><span class="sxs-lookup"><span data-stu-id="6cae4-105">The general rule is that a service should do "one thing" &mdash; but putting that rule into practice requires careful thought.</span></span> <span data-ttu-id="6cae4-106">並沒有機械化的流程可以產生「正確的」設計。</span><span class="sxs-lookup"><span data-stu-id="6cae4-106">There is no mechanical process that will produce the "right" design.</span></span> <span data-ttu-id="6cae4-107">您必須深入思考您的業務領域、需求和目標。</span><span class="sxs-lookup"><span data-stu-id="6cae4-107">You have to think deeply about your business domain, requirements, and goals.</span></span> <span data-ttu-id="6cae4-108">否則，您的設計可能會變成一場災難，表現出某些不理想的特性，例如在服務之間存有隱藏的相依性、彼此密不可分，或介面的設計不良。</span><span class="sxs-lookup"><span data-stu-id="6cae4-108">Otherwise, you can end up with a haphazard design that exhibits some undesirable characteristics, such as hidden dependencies between services, tight coupling, or poorly designed interfaces.</span></span> <span data-ttu-id="6cae4-109">在本章中，我們會以領域導向的方法來設計微服務。</span><span class="sxs-lookup"><span data-stu-id="6cae4-109">In this chapter, we take a domain-driven approach to designing microservices.</span></span> 

<span data-ttu-id="6cae4-110">微服務應該依照商務功能來設計，而非依照水平層 (例如資料存取或傳訊)。</span><span class="sxs-lookup"><span data-stu-id="6cae4-110">Microservices should be designed around business capabilities, not horizontal layers such as data access or messaging.</span></span> <span data-ttu-id="6cae4-111">此外，微服務應該具有鬆散地結合和高度功能一致性的特性。</span><span class="sxs-lookup"><span data-stu-id="6cae4-111">In addition, they should have loose coupling and high functional cohesion.</span></span> <span data-ttu-id="6cae4-112">若您可以變更一項服務，而不需要同時更新其他服務，就表示微服務是「鬆散地結合」。</span><span class="sxs-lookup"><span data-stu-id="6cae4-112">Microservices are *loosely coupled* if you can change one service without requiring other services to be updated at the same time.</span></span> <span data-ttu-id="6cae4-113">若微服務具有單一、明確定義的用途 (例如管理使用者帳戶或追蹤遞送記錄)，就表示微服務具有「一致性」。</span><span class="sxs-lookup"><span data-stu-id="6cae4-113">A microservice is *cohesive* if it has a single, well-defined purpose, such as managing user accounts or tracking delivery history.</span></span> <span data-ttu-id="6cae4-114">服務應納入領域知識，並從用戶端摘錄該知識。</span><span class="sxs-lookup"><span data-stu-id="6cae4-114">A service should encapsulate domain knowledge and abstract that knowledge from clients.</span></span> <span data-ttu-id="6cae4-115">例如，即使用戶端不知道排程演算法的詳細資訊或管理無人機大隊的方式，也應該能夠排程無人機。</span><span class="sxs-lookup"><span data-stu-id="6cae4-115">For example, a client should be able to schedule a drone without knowing the details of the scheduling algorithm or how the drone fleet is managed.</span></span>

<span data-ttu-id="6cae4-116">領域導向的設計 (DDD) 可提供一套架構，讓您設計良好的微服務。</span><span class="sxs-lookup"><span data-stu-id="6cae4-116">Domain-driven design (DDD) provides a framework that can get you most of the way to a set of well-designed microservices.</span></span> <span data-ttu-id="6cae4-117">DDD 有兩個不同的階段：策略階段和戰術階段。</span><span class="sxs-lookup"><span data-stu-id="6cae4-117">DDD has two distinct phases, strategic and tactical.</span></span> <span data-ttu-id="6cae4-118">在策略性 DDD 中，您會定義系統的大規模結構。</span><span class="sxs-lookup"><span data-stu-id="6cae4-118">In strategic DDD, you are defining the large-scale structure of the system.</span></span> <span data-ttu-id="6cae4-119">策略性 DDD 有助於確保您的架構持續聚焦在商務功能上。</span><span class="sxs-lookup"><span data-stu-id="6cae4-119">Strategic DDD helps to ensure that your architecture remains focused on business capabilities.</span></span> <span data-ttu-id="6cae4-120">戰術性 DDD 會提供一套可用來建立領域模型的設計模式。</span><span class="sxs-lookup"><span data-stu-id="6cae4-120">Tactical DDD provides a set of design patterns that you can use to create the domain model.</span></span> <span data-ttu-id="6cae4-121">這些模式包括實體、彙總和領域服務。</span><span class="sxs-lookup"><span data-stu-id="6cae4-121">These patterns include entities, aggregates, and domain services.</span></span> <span data-ttu-id="6cae4-122">這些戰術性模式可協助您設計既是鬆散地結合，又具有一致性的微服務。</span><span class="sxs-lookup"><span data-stu-id="6cae4-122">These tactical patterns will help you to design microservices that are both loosely coupled and cohesive.</span></span>

![](./images/ddd-process.png)

<span data-ttu-id="6cae4-123">在這一章和下一章中，我們將逐步進行下列步驟，將其套用到無人機遞送應用程式：</span><span class="sxs-lookup"><span data-stu-id="6cae4-123">In this chapter and the next, we'll walk through the following steps, applying them to the Drone Delivery application:</span></span> 

1. <span data-ttu-id="6cae4-124">先從分析業務領域開始，以了解應用程式的功能需求。</span><span class="sxs-lookup"><span data-stu-id="6cae4-124">Start by analyzing the business domain to understand the application's functional requirements.</span></span> <span data-ttu-id="6cae4-125">此步驟的結果是領域的非正式描述，可以精簡成更加正式的一套領域模型。</span><span class="sxs-lookup"><span data-stu-id="6cae4-125">The output of this step is an informal description of the domain, which can be refined into a more formal set of domain models.</span></span> 

2. <span data-ttu-id="6cae4-126">接下來，定義領域的「限界內容」。</span><span class="sxs-lookup"><span data-stu-id="6cae4-126">Next, define the *bounded contexts* of the domain.</span></span> <span data-ttu-id="6cae4-127">每個限界內容都會包含領域模型，後者代表較大應用程式的特定子領域。</span><span class="sxs-lookup"><span data-stu-id="6cae4-127">Each bounded context contains a domain model that represents a particular subdomain of the larger application.</span></span> 

3. <span data-ttu-id="6cae4-128">在限界內容中，套用戰術性 DDD 模式來定義實體、彙總和領域服務。</span><span class="sxs-lookup"><span data-stu-id="6cae4-128">Within a bounded context, apply tactical DDD patterns to define entities, aggregates, and domain services.</span></span> 
 
4. <span data-ttu-id="6cae4-129">使用來自上一個步驟的結果，以識別應用程式中的微服務。</span><span class="sxs-lookup"><span data-stu-id="6cae4-129">Use the results from the previous step to identify the microservices in your application.</span></span>

<span data-ttu-id="6cae4-130">在本章中，我們會涵蓋最前面三個步驟，主要是針對 DDD。</span><span class="sxs-lookup"><span data-stu-id="6cae4-130">In this chapter, we cover the first three steps, which are primarily concerned with DDD.</span></span> <span data-ttu-id="6cae4-131">在下一章中，我們會識別微服務。</span><span class="sxs-lookup"><span data-stu-id="6cae4-131">In the next chapter, we will identify the microservices.</span></span> <span data-ttu-id="6cae4-132">不過，請務必記住 DDD 是種反覆且持續進行的流程。</span><span class="sxs-lookup"><span data-stu-id="6cae4-132">However, it's important to remember that DDD is an iterative, ongoing process.</span></span> <span data-ttu-id="6cae4-133">服務界限並非一成不變的。</span><span class="sxs-lookup"><span data-stu-id="6cae4-133">Service boundaries aren't fixed in stone.</span></span> <span data-ttu-id="6cae4-134">隨著應用程式的發展，您可能會決定將服務分割成數個較小的服務。</span><span class="sxs-lookup"><span data-stu-id="6cae4-134">As an application evolves, you may decide to break apart a service into several smaller services.</span></span>

> [!NOTE]
> <span data-ttu-id="6cae4-135">本章的用意不是要顯示完整而全面的領域分析。</span><span class="sxs-lookup"><span data-stu-id="6cae4-135">This chapter is not meant to show a complete and comprehensive domain analysis.</span></span> <span data-ttu-id="6cae4-136">我們特意讓範例保持簡短以說明重點。</span><span class="sxs-lookup"><span data-stu-id="6cae4-136">We deliberately kept the example brief, in order to illustrate the main points.</span></span> <span data-ttu-id="6cae4-137">如需有關 DDD 的詳細背景資訊，我們推薦由 Eric Evans 所著、首先介紹 DDD 一詞的《Domain-Driven Design (領域導向的設計)》一書。</span><span class="sxs-lookup"><span data-stu-id="6cae4-137">For more background on DDD, we recommend Eric Evans' *Domain-Driven Design*, the book that first introduced the term.</span></span> <span data-ttu-id="6cae4-138">另一本良好的參考是 Vaughn Vernon 所著的《Implementing Domain-Driven Design (實作領域導向的設計)》。</span><span class="sxs-lookup"><span data-stu-id="6cae4-138">Another good reference is *Implementing Domain-Driven Design* by Vaughn Vernon.</span></span> 

## <a name="analyze-the-domain"></a><span data-ttu-id="6cae4-139">分析領域</span><span class="sxs-lookup"><span data-stu-id="6cae4-139">Analyze the domain</span></span>

<span data-ttu-id="6cae4-140">使用 DDD 方法可協助您設計微服務，讓每個服務都能自然地貼近功能上的業務需求。</span><span class="sxs-lookup"><span data-stu-id="6cae4-140">Using a DDD approach will help you to design microservices so that every service forms a natural fit to a functional business requirement.</span></span> <span data-ttu-id="6cae4-141">它可以協助您避開陷阱，讓您的設計不會受到組織界限或技術選擇的擺佈。</span><span class="sxs-lookup"><span data-stu-id="6cae4-141">It can help you to avoid the trap of letting organizational boundaries or technology choices dictate your design.</span></span>

<span data-ttu-id="6cae4-142">在撰寫任何程式碼之前，您需要以鳥瞰視野來檢視正在建立的系統。</span><span class="sxs-lookup"><span data-stu-id="6cae4-142">Before writing any code, you need a bird's eye view of the system that you are creating.</span></span> <span data-ttu-id="6cae4-143">DDD 一開始會先將業務領域模型化，並建立「領域模型」。</span><span class="sxs-lookup"><span data-stu-id="6cae4-143">DDD starts by modeling the business domain and creating a *domain model*.</span></span> <span data-ttu-id="6cae4-144">領域模型是業務領域的抽象模型。</span><span class="sxs-lookup"><span data-stu-id="6cae4-144">The domain model is an abstract model of the business domain.</span></span> <span data-ttu-id="6cae4-145">它抽取並組織了領域知識，然後提供共通語言給開發人員和領域專家。</span><span class="sxs-lookup"><span data-stu-id="6cae4-145">It distills and organizes domain knowledge, and provides a common language for developers and domain experts.</span></span> 

<span data-ttu-id="6cae4-146">先從對應所有商務功能及其連線開始。</span><span class="sxs-lookup"><span data-stu-id="6cae4-146">Start by mapping all of the business functions and their connections.</span></span> <span data-ttu-id="6cae4-147">這可能會是涉及領域專家、軟體架構設計人員和其他專案關係人的共同工作。</span><span class="sxs-lookup"><span data-stu-id="6cae4-147">This will likely be a collaborative effort that involves domain experts, software architects, and other stakeholders.</span></span> <span data-ttu-id="6cae4-148">您無須使用任何特定的形式。</span><span class="sxs-lookup"><span data-stu-id="6cae4-148">You don't need to use any particular formalism.</span></span>  <span data-ttu-id="6cae4-149">只需草繪圖表或在白板上繪圖即可。</span><span class="sxs-lookup"><span data-stu-id="6cae4-149">Sketch a diagram or draw on whiteboard.</span></span>

<span data-ttu-id="6cae4-150">繪出圖表後，您就可以開始識別不同的子領域。</span><span class="sxs-lookup"><span data-stu-id="6cae4-150">As you fill in the diagram, you may start to identify discrete subdomains.</span></span> <span data-ttu-id="6cae4-151">有哪些功能是密切相關的？</span><span class="sxs-lookup"><span data-stu-id="6cae4-151">Which functions are closely related?</span></span> <span data-ttu-id="6cae4-152">哪些功能是業務核心？又有哪些功能會提供附屬服務？</span><span class="sxs-lookup"><span data-stu-id="6cae4-152">Which functions are core to the business, and which provide ancillary services?</span></span> <span data-ttu-id="6cae4-153">什麼是相依性關係圖？</span><span class="sxs-lookup"><span data-stu-id="6cae4-153">What is the dependency graph?</span></span> <span data-ttu-id="6cae4-154">在此初始階段，您不必擔心技術或實作細節。</span><span class="sxs-lookup"><span data-stu-id="6cae4-154">During this initial phase, you aren't concerned with technologies or implementation details.</span></span> <span data-ttu-id="6cae4-155">話雖如此，您仍應注意應用程式需要在何處與外部系統 (例如 CRM、付款處理或計費系統) 整合。</span><span class="sxs-lookup"><span data-stu-id="6cae4-155">That said, you should note the place where the application will need to integrate with external systems, such as CRM, payment processing, or billing systems.</span></span> 

## <a name="drone-delivery-analyzing-the-business-domain"></a><span data-ttu-id="6cae4-156">無人機遞送：分析業務領域。</span><span class="sxs-lookup"><span data-stu-id="6cae4-156">Drone Delivery: Analyzing the business domain.</span></span>

<span data-ttu-id="6cae4-157">Fabrikam 小組在進行一些初始領域分析後，提出了用以說明無人機遞送領域的概略草圖。</span><span class="sxs-lookup"><span data-stu-id="6cae4-157">After some initial domain analysis, the Fabrikam team came up with a rough sketch that depicts the Drone Delivery domain.</span></span>

![](./images/ddd1.svg) 

- <span data-ttu-id="6cae4-158">由於**出貨**是業務的核心，因此位於圖表的中央。</span><span class="sxs-lookup"><span data-stu-id="6cae4-158">**Shipping** is placed in the center of the diagram, because it's core to the business.</span></span> <span data-ttu-id="6cae4-159">在圖表中的所有其他項目，都是為了達成這項功能而存在。</span><span class="sxs-lookup"><span data-stu-id="6cae4-159">Everything else in the diagram exists to enable this functionality.</span></span>
- <span data-ttu-id="6cae4-160">**無人機管理**也是業務的核心。</span><span class="sxs-lookup"><span data-stu-id="6cae4-160">**Drone management** is also core to the business.</span></span> <span data-ttu-id="6cae4-161">與無人機管理密切相關的功能包括**無人機修復**，以及使用**預測性分析**來預測無人機何時需要維護和維修。</span><span class="sxs-lookup"><span data-stu-id="6cae4-161">Functionality that is closely related to drone management includes **drone repair** and using **predictive analysis** to predict when drones need servicing and maintenance.</span></span> 
- <span data-ttu-id="6cae4-162">**預計到達時間分析**可提供預估的收件和遞送時間。</span><span class="sxs-lookup"><span data-stu-id="6cae4-162">**ETA analysis** provides time estimates for pickup and delivery.</span></span> 
- <span data-ttu-id="6cae4-163">若包裹無法完全交由無人機運送，**第三方運輸**會讓應用程式能夠排程替代運輸方式。</span><span class="sxs-lookup"><span data-stu-id="6cae4-163">**Third-party transportation** will enable the application to schedule alternative transportation methods if a package cannot be shipped entirely by drone.</span></span>
- <span data-ttu-id="6cae4-164">**無人機共用**是核心業務可能的擴充功能。</span><span class="sxs-lookup"><span data-stu-id="6cae4-164">**Drone sharing** is a possible extension of the core business.</span></span> <span data-ttu-id="6cae4-165">公司在特定時段可能會有過剩的無人機，若不將其出租便會閒置。</span><span class="sxs-lookup"><span data-stu-id="6cae4-165">The company may have excess drone capacity during certain hours, and could rent out drones that would otherwise be idle.</span></span> <span data-ttu-id="6cae4-166">在初始版本中不會有這項功能。</span><span class="sxs-lookup"><span data-stu-id="6cae4-166">This feature will not be in the initial release.</span></span>
- <span data-ttu-id="6cae4-167">**視訊監視**是公司稍後可能會擴及的另一個領域。</span><span class="sxs-lookup"><span data-stu-id="6cae4-167">**Video surveillance** is another area that the company might expand into later.</span></span>
- <span data-ttu-id="6cae4-168">**使用者帳戶**、**發票開立**和**話務中心**都是支援核心業務的子領域。</span><span class="sxs-lookup"><span data-stu-id="6cae4-168">**User accounts**, **Invoicing**, and **Call center** are subdomains that support the core business.</span></span>
 
<span data-ttu-id="6cae4-169">請注意，截至流程中的這個階段為止，我們尚未做出任何關於實作或技術的決策。</span><span class="sxs-lookup"><span data-stu-id="6cae4-169">Notice that at this point in the process, we haven't made any decisions about implementation or technologies.</span></span> <span data-ttu-id="6cae4-170">部分子系統可能會涉及外部軟體系統或第三方服務。</span><span class="sxs-lookup"><span data-stu-id="6cae4-170">Some of the subsystems may involve external software systems or third-party services.</span></span> <span data-ttu-id="6cae4-171">即便如此，應用程式仍需要與這些系統和服務互動，因此請務必將後兩者包含在領域模型中。</span><span class="sxs-lookup"><span data-stu-id="6cae4-171">Even so, the application needs to interact with these systems and services, so it's important to include them in the domain model.</span></span> 

> [!NOTE]
> <span data-ttu-id="6cae4-172">應用程式要依存外部系統時，會有外部系統的資料結構描述或 API 洩露到您應用程式中的風險，最後可能會導致架構設計受到危害。</span><span class="sxs-lookup"><span data-stu-id="6cae4-172">When an application depends on an external system, there is a risk that the external system's data schema or API will leak into your application, ultimately compromising the architectural design.</span></span> <span data-ttu-id="6cae4-173">對可能未遵照新式最佳做法，以及可能是使用複雜曲折的資料結構描述或過時 API 的繼承系統來說，風險尤其大。</span><span class="sxs-lookup"><span data-stu-id="6cae4-173">This is particularly true with legacy systems that may not follow modern best practices, and may use convoluted data schemas or obsolete APIs.</span></span> <span data-ttu-id="6cae4-174">在此情況下，請務必要在這些外部系統與應用程式之間，妥善定義出界限。</span><span class="sxs-lookup"><span data-stu-id="6cae4-174">In that case, it's important to have a well-defined boundary between these external systems and the application.</span></span> <span data-ttu-id="6cae4-175">針對此目的，請考慮使用[扼制模式](../patterns/strangler.md)或[防損毀層模式](../patterns/anti-corruption-layer.md)。</span><span class="sxs-lookup"><span data-stu-id="6cae4-175">Consider using the [Strangler Pattern](../patterns/strangler.md) or the [Anti-Corruption Layer Pattern](../patterns/anti-corruption-layer.md) for this purpose.</span></span>

## <a name="define-bounded-contexts"></a><span data-ttu-id="6cae4-176">定義限界內容</span><span class="sxs-lookup"><span data-stu-id="6cae4-176">Define bounded contexts</span></span>

<span data-ttu-id="6cae4-177">領域模型會包括真實世界中事物的代表 &mdash; 使用者、無人機、包裹等等。</span><span class="sxs-lookup"><span data-stu-id="6cae4-177">The domain model will include representations of real things in the world &mdash; users, drones, packages, and so forth.</span></span> <span data-ttu-id="6cae4-178">但這並不表示針對相同的事物，系統的每個部分都需要使用相同的代表。</span><span class="sxs-lookup"><span data-stu-id="6cae4-178">But that doesn't mean that every part of the system needs to use the same representations for the same things.</span></span> 

<span data-ttu-id="6cae4-179">例如，處理無人機修復和預測性分析的子系統會需要表示許多具有實體特性 (例如維修記錄、使用里程、壽命、型號、效能特性等等) 的無人機。</span><span class="sxs-lookup"><span data-stu-id="6cae4-179">For example, subsystems that handle drone repair and predictive analysis will need to represent many physical characteristics drones, such as their maintenance history, mileage, age, model number, performance characteristics, and so on.</span></span> <span data-ttu-id="6cae4-180">但在排程遞送時，我們不會在意這些特性。</span><span class="sxs-lookup"><span data-stu-id="6cae4-180">But when it's time to schedule a delivery, we don't care about those things.</span></span> <span data-ttu-id="6cae4-181">正在排程的子系統只需要知道無人機是否可用，以及收件和遞送的預計到達時間。</span><span class="sxs-lookup"><span data-stu-id="6cae4-181">The scheduling subsystem only needs to know whether a drone is available, and the ETA for pickup and delivery.</span></span> 

<span data-ttu-id="6cae4-182">若我們嘗試針對這兩個子系統建立單一模型，該模型會過於複雜。</span><span class="sxs-lookup"><span data-stu-id="6cae4-182">If we tried to create a single model for both of these subsystems, it would be unnecessarily complex.</span></span> <span data-ttu-id="6cae4-183">這也會讓模型難以隨著時間而進化，因為任何變更都需要能夠讓在不同子系統上工作的多個小組滿意。</span><span class="sxs-lookup"><span data-stu-id="6cae4-183">It would also become harder for the model to evolve over time, because any changes will need to satisfy multiple teams working on separate subsystems.</span></span> <span data-ttu-id="6cae4-184">因此，設計不同的模型，來代表兩個不同內容中的同一個真實世界實體 (在此案例中是無人機)，通常是較好的方式。</span><span class="sxs-lookup"><span data-stu-id="6cae4-184">Therefore, it's often better to design separate models that represent the same real-world entity (in this case, a drone) in two different contexts.</span></span> <span data-ttu-id="6cae4-185">每一個模型都只包含在其特定內容中相關的功能和屬性。</span><span class="sxs-lookup"><span data-stu-id="6cae4-185">Each model contains only the features and attributes that are relevant within its particular context.</span></span>

<span data-ttu-id="6cae4-186">此時 DDD 的「限界內容」概念就可派上用場。</span><span class="sxs-lookup"><span data-stu-id="6cae4-186">This is where the DDD concept of *bounded contexts* comes into play.</span></span> <span data-ttu-id="6cae4-187">限界內容只是領域內的界限，系統會在此套用特定的領域模型。</span><span class="sxs-lookup"><span data-stu-id="6cae4-187">A bounded context is simply the boundary within a domain where a particular domain model applies.</span></span> <span data-ttu-id="6cae4-188">對照先前的圖表，我們可以根據各種功能是否會共用單一的領域模型，來將功能分組。</span><span class="sxs-lookup"><span data-stu-id="6cae4-188">Looking at the previous diagram, we can group functionality according to whether various functions will share a single domain model.</span></span> 

![](./images/ddd2.svg) 
 
<span data-ttu-id="6cae4-189">限界內容之間不一定彼此獨立。</span><span class="sxs-lookup"><span data-stu-id="6cae4-189">Bounded contexts are not necessarily isolated from one another.</span></span> <span data-ttu-id="6cae4-190">在此圖中，連接限界內容的實心線條，代表兩個限界內容彼此互動的位置。</span><span class="sxs-lookup"><span data-stu-id="6cae4-190">In this diagram, the solid lines connecting the bounded contexts represent places where two bounded contexts interact.</span></span> <span data-ttu-id="6cae4-191">例如，「出貨」會依賴「使用者帳戶」來取得關於客戶的資訊，並依賴「無人機管理」對無人機大隊中的無人機進行排程。</span><span class="sxs-lookup"><span data-stu-id="6cae4-191">For example, Shipping depends on User Accounts to get information about customers, and on Drone Management to schedule drones from the fleet.</span></span>

<span data-ttu-id="6cae4-192">在《Domain Driven Design (領域導向的設計)》一書中，Eric Evans 描述了在與其他限界內容互動時，數種維護領域模型完整性的模式。</span><span class="sxs-lookup"><span data-stu-id="6cae4-192">In the book *Domain Driven Design*, Eric Evans describes several patterns for maintaining the integrity of a domain model when it interacts with another bounded context.</span></span> <span data-ttu-id="6cae4-193">其中一個微服務的主要原則是，服務會透過妥善定義的 API 進行通訊。</span><span class="sxs-lookup"><span data-stu-id="6cae4-193">One of the main principles of microservices is that services communicate through well-defined APIs.</span></span> <span data-ttu-id="6cae4-194">此方法可對應到 Evans 稱為「開放主機服務」和「發行的語言」的兩種模式。</span><span class="sxs-lookup"><span data-stu-id="6cae4-194">This approach corresponds to two patterns that Evans calls Open Host Service and Published Language.</span></span> <span data-ttu-id="6cae4-195">開放主機服務的概念是子系統會為了與其通訊的其他子系統，定義正式的通訊協定 (API)。</span><span class="sxs-lookup"><span data-stu-id="6cae4-195">The idea of Open Host Service is that a subsystem defines a formal protocol (API) for other subsystems to communicate with it.</span></span> <span data-ttu-id="6cae4-196">發行的語言則延伸了此概念，以其他小組可用以寫入用戶端的形式來發行 API。</span><span class="sxs-lookup"><span data-stu-id="6cae4-196">Published Language extends this idea by publishing the API in a form that other teams can use to write clients.</span></span> <span data-ttu-id="6cae4-197">在 [API 設計](./api-design.md)一章中，我們討論了使用 [OpenAPI 規格](https://www.openapis.org/specification/repo) (先前稱為 Swagger)，針對 REST API 定義適用於各種語言的介面描述，並以 JSON 或 YAML 格式表示。</span><span class="sxs-lookup"><span data-stu-id="6cae4-197">In the chapter on [API Design](./api-design.md), we discuss using [OpenAPI Specification](https://www.openapis.org/specification/repo) (formerly known as Swagger) to define language-agnostic interface descriptions for REST APIs, expressed in JSON or YAML format.</span></span>

<span data-ttu-id="6cae4-198">在本章的其餘部分，我們將著重在「出貨」限界內容。</span><span class="sxs-lookup"><span data-stu-id="6cae4-198">For the rest of this journey, we will focus on the Shipping bounded context.</span></span> 

## <a name="tactical-ddd"></a><span data-ttu-id="6cae4-199">戰術性 DDD</span><span class="sxs-lookup"><span data-stu-id="6cae4-199">Tactical DDD</span></span>

<span data-ttu-id="6cae4-200">在 DDD 的策略性階段期間，您會對應業務領域並為領域模型定義限界內容。</span><span class="sxs-lookup"><span data-stu-id="6cae4-200">During the strategic phase of DDD, you are mapping out the business domain and defining bounded contexts for your domain models.</span></span> <span data-ttu-id="6cae4-201">在戰術性 DDD 中則會更加精確地定義領域模型。</span><span class="sxs-lookup"><span data-stu-id="6cae4-201">Tactical DDD is when you define your domain models with more precision.</span></span> <span data-ttu-id="6cae4-202">戰術性模式會在單一限界內容中套用。</span><span class="sxs-lookup"><span data-stu-id="6cae4-202">The tactical patterns are applied within a single bounded context.</span></span> <span data-ttu-id="6cae4-203">在微服務架構中，我們對實體和彙總模式特別感興趣。</span><span class="sxs-lookup"><span data-stu-id="6cae4-203">In a microservices architecture, we are particularly interested in the entity and aggregate patterns.</span></span> <span data-ttu-id="6cae4-204">套用這些模式可協助我們識別應用程式中服務的自然界限 (請參閱[下一章](./microservice-boundaries.md))。</span><span class="sxs-lookup"><span data-stu-id="6cae4-204">Applying these patterns will help us to identify natural boundaries for the services in our application (see [next chapter](./microservice-boundaries.md)).</span></span> <span data-ttu-id="6cae4-205">一般來說，微服務應大於彙總，且小於限界內容。</span><span class="sxs-lookup"><span data-stu-id="6cae4-205">As a general principle, a microservice should be no smaller than an aggregate, and no larger than a bounded context.</span></span> <span data-ttu-id="6cae4-206">首先，我們會檢閱戰術性模式。</span><span class="sxs-lookup"><span data-stu-id="6cae4-206">First, we'll review the tactical patterns.</span></span> <span data-ttu-id="6cae4-207">然後我們會將其套用到無人機遞送應用程式中的「出貨」限界內容。</span><span class="sxs-lookup"><span data-stu-id="6cae4-207">Then we'll apply them to the Shipping bounded context in the Drone Delivery application.</span></span> 

### <a name="overview-of-the-tactical-patterns"></a><span data-ttu-id="6cae4-208">戰術性模式概觀</span><span class="sxs-lookup"><span data-stu-id="6cae4-208">Overview of the tactical patterns</span></span>

<span data-ttu-id="6cae4-209">本節提供了戰術性 DDD 模式的簡短摘要，因此若您已很熟悉 DDD，可以略過本節。</span><span class="sxs-lookup"><span data-stu-id="6cae4-209">This section provides a brief summary of the tactical DDD patterns, so if you are already familiar with DDD, you can probably skip this section.</span></span> <span data-ttu-id="6cae4-210">模式在 Eric Evan 書中的第 5 &ndash; 6 章中，以及 Vaughn Vernon 所著的《Implementing Domain-Driven Design (實作領域導向的設計)》一書中會詳加說明。</span><span class="sxs-lookup"><span data-stu-id="6cae4-210">The patterns are described in more detail in chapters 5 &ndash; 6 of Eric Evans' book, and in *Implementing Domain-Driven Design* by Vaughn Vernon.</span></span> 

![](./images/ddd-patterns.png)

<span data-ttu-id="6cae4-211">**實體**。</span><span class="sxs-lookup"><span data-stu-id="6cae4-211">**Entities**.</span></span> <span data-ttu-id="6cae4-212">實體是具有唯一的身分識別，且會持續一段時間的物件。</span><span class="sxs-lookup"><span data-stu-id="6cae4-212">An entity is an object with a unique identity that persists over time.</span></span> <span data-ttu-id="6cae4-213">例如，在銀行應用程式中，客戶和帳戶會是實體。</span><span class="sxs-lookup"><span data-stu-id="6cae4-213">For example, in a banking application, customers and accounts would be entities.</span></span> 

- <span data-ttu-id="6cae4-214">實體在系統中具有唯一識別碼 (可用來查看或擷取實體)。</span><span class="sxs-lookup"><span data-stu-id="6cae4-214">An entity has a unique identifier in the system, which can be used to look up or retrieve the entity.</span></span> <span data-ttu-id="6cae4-215">這並不表示識別碼一律會直接公開給使用者。</span><span class="sxs-lookup"><span data-stu-id="6cae4-215">That doesn't mean the identifier is always exposed directly to users.</span></span> <span data-ttu-id="6cae4-216">而可能是資料庫中的 GUID 或主索引鍵。</span><span class="sxs-lookup"><span data-stu-id="6cae4-216">It could be a GUID or a primary key in a database.</span></span> 
- <span data-ttu-id="6cae4-217">身分識別可能會跨越多個限界內容，且持續時間可能會超過應用程式的存留期。</span><span class="sxs-lookup"><span data-stu-id="6cae4-217">An identity may span multiple bounded contexts, and may endure beyond the lifetime of the application.</span></span> <span data-ttu-id="6cae4-218">例如，銀行帳戶號碼或政府所發行的 ID 就不會繫結到特定應用程式的存留期。</span><span class="sxs-lookup"><span data-stu-id="6cae4-218">For example, bank account numbers or government-issued IDs are not tied to the lifetime of a particular application.</span></span>
- <span data-ttu-id="6cae4-219">實體的屬性可能會隨著時間變更。</span><span class="sxs-lookup"><span data-stu-id="6cae4-219">The attributes of an entity may change over time.</span></span> <span data-ttu-id="6cae4-220">例如，某人的姓名或地址可能會變更，但他仍是同一個人。</span><span class="sxs-lookup"><span data-stu-id="6cae4-220">For example, a person's name or address might change, but they are still the same person.</span></span> 
- <span data-ttu-id="6cae4-221">實體可以擁有其他實體的參考。</span><span class="sxs-lookup"><span data-stu-id="6cae4-221">An entity can hold references to other entities.</span></span>
 
<span data-ttu-id="6cae4-222">**值物件**。</span><span class="sxs-lookup"><span data-stu-id="6cae4-222">**Value objects**.</span></span> <span data-ttu-id="6cae4-223">值物件沒有任何身分識別。</span><span class="sxs-lookup"><span data-stu-id="6cae4-223">A value object has no identity.</span></span> <span data-ttu-id="6cae4-224">其只會由其屬性的值所定義。</span><span class="sxs-lookup"><span data-stu-id="6cae4-224">It is defined only by the values of its attributes.</span></span> <span data-ttu-id="6cae4-225">值物件也是不可變的。</span><span class="sxs-lookup"><span data-stu-id="6cae4-225">Value objects are also immutable.</span></span> <span data-ttu-id="6cae4-226">若要更新值物件，請一律要建立新執行個體來取代舊執行個體。</span><span class="sxs-lookup"><span data-stu-id="6cae4-226">To update a value object, you always create a new instance to replace the old one.</span></span> <span data-ttu-id="6cae4-227">值物件可以具有封裝領域邏輯的方法，但這些方法對物件狀態必須沒有副作用。</span><span class="sxs-lookup"><span data-stu-id="6cae4-227">Value objects can have methods that encapsulate domain logic, but those methods should have no side-effects on the object's state.</span></span> <span data-ttu-id="6cae4-228">值物件的典型範例包括色彩、日期和時間，以及貨幣值。</span><span class="sxs-lookup"><span data-stu-id="6cae4-228">Typical examples of value objects include colors, dates and times, and currency values.</span></span> 

<span data-ttu-id="6cae4-229">**彙總**。</span><span class="sxs-lookup"><span data-stu-id="6cae4-229">**Aggregates**.</span></span> <span data-ttu-id="6cae4-230">彙總定義了一或多個實體周圍的一致性界限。</span><span class="sxs-lookup"><span data-stu-id="6cae4-230">An aggregate defines a consistency boundary around one or more entities.</span></span> <span data-ttu-id="6cae4-231">彙總中只有一個的實體是根目錄。</span><span class="sxs-lookup"><span data-stu-id="6cae4-231">Exactly one entity in an aggregate is the root.</span></span> <span data-ttu-id="6cae4-232">使用根目錄實體的識別碼即可查看。</span><span class="sxs-lookup"><span data-stu-id="6cae4-232">Lookup is done using the root entity's identifier.</span></span> <span data-ttu-id="6cae4-233">彙總內的任何其他實體都是根目錄的子項目，並可透過追隨根目錄的指標加以參考。</span><span class="sxs-lookup"><span data-stu-id="6cae4-233">Any other entities in the aggregate are children of the root, and are referenced by following pointers from the root.</span></span> 

<span data-ttu-id="6cae4-234">彙總的目的是將交易的不變項目模型化。</span><span class="sxs-lookup"><span data-stu-id="6cae4-234">The purpose of an aggregate is to model transactional invariants.</span></span> <span data-ttu-id="6cae4-235">真實世界中的事物關係錯綜複雜。</span><span class="sxs-lookup"><span data-stu-id="6cae4-235">Things in the real world have complex webs of relationships.</span></span> <span data-ttu-id="6cae4-236">客戶會建立訂單、訂單會包含產品、產品會有供應商，依此類推。</span><span class="sxs-lookup"><span data-stu-id="6cae4-236">Customers create orders, orders contain products, products have suppliers, and so on.</span></span> <span data-ttu-id="6cae4-237">若應用程式修改了數個相關的物件，要如何保證一致性？</span><span class="sxs-lookup"><span data-stu-id="6cae4-237">If the application modifies several related objects, how does it guarantee consistency?</span></span> <span data-ttu-id="6cae4-238">我們要如何追蹤不變項目並加以強制執行？</span><span class="sxs-lookup"><span data-stu-id="6cae4-238">How do we keep track of invariants and enforce them?</span></span>  

<span data-ttu-id="6cae4-239">以前傳統應用程式通常會使用資料庫交易來強制確保一致性。</span><span class="sxs-lookup"><span data-stu-id="6cae4-239">Traditional applications have often used database transactions to enforce consistency.</span></span> <span data-ttu-id="6cae4-240">然而，在分散式應用程式中，這通常不可行。</span><span class="sxs-lookup"><span data-stu-id="6cae4-240">In a distributed application, however, that's often not feasible.</span></span> <span data-ttu-id="6cae4-241">單一商業交易可能會跨越多個資料存放區、可能會長時間執行，或可能涉及第三方服務。</span><span class="sxs-lookup"><span data-stu-id="6cae4-241">A single business transaction may span multiple data stores, or may be long running, or may involve third-party services.</span></span> <span data-ttu-id="6cae4-242">最後是取決於應用程式 (而非資料層) 來強制執行領域所需的不變項目。</span><span class="sxs-lookup"><span data-stu-id="6cae4-242">Ultimately it's up to the application, not the data layer, to enforce the invariants required for the domain.</span></span> <span data-ttu-id="6cae4-243">這就是彙總要模型化的項目。</span><span class="sxs-lookup"><span data-stu-id="6cae4-243">That's what aggregates are meant to model.</span></span>

> [!NOTE]
> <span data-ttu-id="6cae4-244">彙總可能會由單一實體所組成，而不包含子實體。</span><span class="sxs-lookup"><span data-stu-id="6cae4-244">An aggregate might consist of a single entity, without child entities.</span></span> <span data-ttu-id="6cae4-245">是因為交易的界限才使其成為彙總。</span><span class="sxs-lookup"><span data-stu-id="6cae4-245">What makes it an aggregate is the transactional boundary.</span></span>

<span data-ttu-id="6cae4-246">**領域和應用程式服務**。</span><span class="sxs-lookup"><span data-stu-id="6cae4-246">**Domain and application services**.</span></span> <span data-ttu-id="6cae4-247">在 DDD 術語中，服務是指會實作某些邏輯，而不保留任何狀態的物件。</span><span class="sxs-lookup"><span data-stu-id="6cae4-247">In DDD terminology, a service is an object that implements some logic without holding any state.</span></span> <span data-ttu-id="6cae4-248">Evans 將「領域服務」(會封裝領域邏輯) 和「應用程式服務」(會提供技術功能，例如使用者驗證或傳送簡訊) 兩者加以區分。</span><span class="sxs-lookup"><span data-stu-id="6cae4-248">Evans distinguishes between *domain services*, which encapsulate domain logic, and *application services*, which provide technical functionality, such as user authentication or sending an SMS message.</span></span> <span data-ttu-id="6cae4-249">領域服務通常會用以將跨越多個實體的行為模型化。</span><span class="sxs-lookup"><span data-stu-id="6cae4-249">Domain services are often used to model behavior that spans multiple entities.</span></span> 

> [!NOTE]
> <span data-ttu-id="6cae4-250">「服務」一詞在軟體開發中已過度使用。</span><span class="sxs-lookup"><span data-stu-id="6cae4-250">The term *service* is overloaded in software development.</span></span> <span data-ttu-id="6cae4-251">在此的定義與微服務並無直接關聯。</span><span class="sxs-lookup"><span data-stu-id="6cae4-251">The definition here is not directly related to microservices.</span></span>

<span data-ttu-id="6cae4-252">**領域事件**。</span><span class="sxs-lookup"><span data-stu-id="6cae4-252">**Domain events**.</span></span> <span data-ttu-id="6cae4-253">領域事件可用以通知系統的其他部分有情況發生。</span><span class="sxs-lookup"><span data-stu-id="6cae4-253">Domain events can be used to notify other parts of the system when something happens.</span></span> <span data-ttu-id="6cae4-254">正如其名，領域事件應代表領域中所發生的事物。</span><span class="sxs-lookup"><span data-stu-id="6cae4-254">As the name suggests, domain events should mean something within the domain.</span></span> <span data-ttu-id="6cae4-255">例如，「已將記錄插入資料表中」就不是領域事件。</span><span class="sxs-lookup"><span data-stu-id="6cae4-255">For example, "a record was inserted into a table" is not a domain event.</span></span> <span data-ttu-id="6cae4-256">「已取消遞送」則是領域事件。</span><span class="sxs-lookup"><span data-stu-id="6cae4-256">"A delivery was cancelled" is a domain event.</span></span> <span data-ttu-id="6cae4-257">領域事件在微服務架構中特別具有關聯性。</span><span class="sxs-lookup"><span data-stu-id="6cae4-257">Domain events are especially relevant in a microservices architecture.</span></span> <span data-ttu-id="6cae4-258">因為微服務是分散式的且不會共用資料存放區，因此領域事件可提供方式讓微服務相互協調。</span><span class="sxs-lookup"><span data-stu-id="6cae4-258">Because microservices are distributed and don't share data stores, domain events provide a way for microservices to coordinate with each other.</span></span> <span data-ttu-id="6cae4-259">在[服務間通訊](./interservice-communication.md)一章中會詳加討論非同步傳訊。</span><span class="sxs-lookup"><span data-stu-id="6cae4-259">The chapter [Interservice communication](./interservice-communication.md) discusses asynchronous messaging in more detail.</span></span>
 
<span data-ttu-id="6cae4-260">有幾種其他 DDD 模式未在此處列出，包括處理站、存放庫和模組。</span><span class="sxs-lookup"><span data-stu-id="6cae4-260">There are a few other DDD patterns not listed here, including factories, repositories, and modules.</span></span> <span data-ttu-id="6cae4-261">在實作微服務時這些會是很有用的模式，但在設計微服務之間的界限時則較不相關。</span><span class="sxs-lookup"><span data-stu-id="6cae4-261">These can be useful patterns for when you are implementing a microservice, but they are less relevant when designing the boundaries between microservice.</span></span>

## <a name="drone-delivery-applying-the-patterns"></a><span data-ttu-id="6cae4-262">無人機遞送：套用模式</span><span class="sxs-lookup"><span data-stu-id="6cae4-262">Drone delivery: Applying the patterns</span></span>

<span data-ttu-id="6cae4-263">我們先從「出貨」限界內容必須處理的案例開始。</span><span class="sxs-lookup"><span data-stu-id="6cae4-263">We start with the scenarios that the Shipping bounded context must handle.</span></span>

- <span data-ttu-id="6cae4-264">客戶可以要求無人機從已向無人機遞送服務註冊的企業收件。</span><span class="sxs-lookup"><span data-stu-id="6cae4-264">A customer can request a drone to pick up goods from a business that is registered with the drone delivery service.</span></span>
- <span data-ttu-id="6cae4-265">寄件者可產生要放在包裹上的標籤 (條碼或 RFID)。</span><span class="sxs-lookup"><span data-stu-id="6cae4-265">The sender generates a tag (barcode or RFID) to put on the package.</span></span> 
- <span data-ttu-id="6cae4-266">無人機會從來源位置收取包裹，並遞送到目的地位置。</span><span class="sxs-lookup"><span data-stu-id="6cae4-266">A drone will pick up and deliver a package from the source location to the destination location.</span></span>
- <span data-ttu-id="6cae4-267">客戶在排程遞送時，系統會根據路線資訊、天氣狀況和歷史資料，來提供預計的到達時間。</span><span class="sxs-lookup"><span data-stu-id="6cae4-267">When a customer schedules a delivery, the system provides an ETA based on route information, weather conditions, and historical data.</span></span> 
- <span data-ttu-id="6cae4-268">無人機在飛行時，使用者可以追蹤其目前位置和最新的預計到達時間。</span><span class="sxs-lookup"><span data-stu-id="6cae4-268">When the drone is in flight, a user can track the current location and the latest ETA.</span></span> 
- <span data-ttu-id="6cae4-269">到無人機收取包裹之前，客戶都可以取消遞送。</span><span class="sxs-lookup"><span data-stu-id="6cae4-269">Until a drone has picked up the package, the customer can cancel a delivery.</span></span>
- <span data-ttu-id="6cae4-270">遞送完成時會通知客戶。</span><span class="sxs-lookup"><span data-stu-id="6cae4-270">The customer is notified when the delivery is completed.</span></span>
- <span data-ttu-id="6cae4-271">寄件者能以簽章或指紋形式，向客戶要求遞送確認。</span><span class="sxs-lookup"><span data-stu-id="6cae4-271">The sender can request delivery confirmation from the customer, in the form of a signature or finger print.</span></span>
- <span data-ttu-id="6cae4-272">使用者可以查看已完成之遞送的記錄。</span><span class="sxs-lookup"><span data-stu-id="6cae4-272">Users can look up the history of a completed delivery.</span></span>

<span data-ttu-id="6cae4-273">開發小組從上述案例中，識別出下列**實體**。</span><span class="sxs-lookup"><span data-stu-id="6cae4-273">From these scenarios, the development team identified the following **entities**.</span></span>

- <span data-ttu-id="6cae4-274">遞送</span><span class="sxs-lookup"><span data-stu-id="6cae4-274">Delivery</span></span>
- <span data-ttu-id="6cae4-275">Package</span><span class="sxs-lookup"><span data-stu-id="6cae4-275">Package</span></span>
- <span data-ttu-id="6cae4-276">無人機</span><span class="sxs-lookup"><span data-stu-id="6cae4-276">Drone</span></span>
- <span data-ttu-id="6cae4-277">帳戶</span><span class="sxs-lookup"><span data-stu-id="6cae4-277">Account</span></span>
- <span data-ttu-id="6cae4-278">確認</span><span class="sxs-lookup"><span data-stu-id="6cae4-278">Confirmation</span></span>
- <span data-ttu-id="6cae4-279">通知</span><span class="sxs-lookup"><span data-stu-id="6cae4-279">Notification</span></span>
- <span data-ttu-id="6cae4-280">Tag</span><span class="sxs-lookup"><span data-stu-id="6cae4-280">Tag</span></span>

<span data-ttu-id="6cae4-281">前四個實體：遞送、包裹、無人機和帳戶，全都是代表交易一致性界限的**彙總**。</span><span class="sxs-lookup"><span data-stu-id="6cae4-281">The first four, Delivery, Package, Drone, and Account, are all **aggregates** that represent transactional consistency boundaries.</span></span> <span data-ttu-id="6cae4-282">「確認」和「通知」是「遞送」的子實體，而「標籤」則是「包裹」的子實體。</span><span class="sxs-lookup"><span data-stu-id="6cae4-282">Confirmations and Notifications are child entities of Deliveries, and Tags are child entities of Packages.</span></span> 

<span data-ttu-id="6cae4-283">在此設計中的**值物件**包括 Location、ETA、PackageWeight 和 PackageSize。</span><span class="sxs-lookup"><span data-stu-id="6cae4-283">The **value objects** in this design include Location, ETA, PackageWeight, and PackageSize.</span></span> 

<span data-ttu-id="6cae4-284">為了說明，以下是「遞送」彙總的 UML 圖表。</span><span class="sxs-lookup"><span data-stu-id="6cae4-284">To illustrate, here is a UML diagram of the Delivery aggregate.</span></span> <span data-ttu-id="6cae4-285">請注意，「遞送」保留了其他彙總 (包括「帳戶」、「包裹」和「無人機」) 的參考。</span><span class="sxs-lookup"><span data-stu-id="6cae4-285">Notice that it holds references to other aggregates, including Account, Package, and Drone.</span></span>

![](./images/delivery-entity.png)

<span data-ttu-id="6cae4-286">有兩個領域事件：</span><span class="sxs-lookup"><span data-stu-id="6cae4-286">There are two domain events:</span></span>

- <span data-ttu-id="6cae4-287">無人機在飛行時，「無人機」實體會傳送描述無人機位置和狀態 (飛行中、已著陸) 的 DroneStatus 事件。</span><span class="sxs-lookup"><span data-stu-id="6cae4-287">While a drone is in flight, the Drone entity sends DroneStatus events that describe the drone's location and status (in-flight, landed).</span></span>

- <span data-ttu-id="6cae4-288">只要遞送階段有所變更，「遞送」實體就會隨時傳送 DeliveryTracking 事件。</span><span class="sxs-lookup"><span data-stu-id="6cae4-288">The Delivery entity sends DeliveryTracking events whenever the stage of a delivery changes.</span></span> <span data-ttu-id="6cae4-289">包括有 DeliveryCreated、DeliveryRescheduled、DeliveryHeadedToDropoff 和 DeliveryCompleted。</span><span class="sxs-lookup"><span data-stu-id="6cae4-289">These include DeliveryCreated, DeliveryRescheduled, DeliveryHeadedToDropoff, and DeliveryCompleted.</span></span> 

<span data-ttu-id="6cae4-290">請注意，這些事件會描述領域模型中有意義的事物。</span><span class="sxs-lookup"><span data-stu-id="6cae4-290">Notice that these events describe things that are meaningful within the domain model.</span></span> <span data-ttu-id="6cae4-291">這些事件會描述關於領域的事物，且不會繫結到特定的程式設計語言建構。</span><span class="sxs-lookup"><span data-stu-id="6cae4-291">They describe something about the domain, and aren't tied to a particular programming language construct.</span></span>

<span data-ttu-id="6cae4-292">開發小組還識別出另一個功能領域，但無法明確歸類為目前為止所描述的任何實體。</span><span class="sxs-lookup"><span data-stu-id="6cae4-292">The development team identified one more area of functionality, which doesn't fit neatly into any of the entities described so far.</span></span> <span data-ttu-id="6cae4-293">系統的某些部分必須協調排程或更新遞送時所涉及的所有步驟。</span><span class="sxs-lookup"><span data-stu-id="6cae4-293">Some part of the system must coordinate all of the steps involved in scheduling or updating a delivery.</span></span> <span data-ttu-id="6cae4-294">因此，開發小組已在設計中新增兩個**領域服務**：用以協調步驟的「排程器」，以及用以監視每個步驟狀態的「監督員」；以便偵測是否有任何步驟失敗或逾時。這是[排程器代理程式監督員模式](../patterns/scheduler-agent-supervisor.md)的變化情形。</span><span class="sxs-lookup"><span data-stu-id="6cae4-294">Therefore, the development team added two **domain services** to the design: a *Scheduler* that coordinates the steps, and a *Supervisor* that monitors the status of each step, in order to detect whether any steps have failed or timed out. This is a variation of the [Scheduler Agent Supervisor pattern](../patterns/scheduler-agent-supervisor.md).</span></span>

![](./images/drone-ddd.png)

> [!div class="nextstepaction"]
> [<span data-ttu-id="6cae4-295">識別微服務界限</span><span class="sxs-lookup"><span data-stu-id="6cae4-295">Identifying microservice boundaries</span></span>](./microservice-boundaries.md)
