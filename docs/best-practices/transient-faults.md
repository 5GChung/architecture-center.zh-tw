---
title: 一般重試方針
titleSuffix: Best practices for cloud applications
description: 暫時性錯誤處理重試指引。
author: dragon119
ms.date: 07/13/2016
ms.custom: seodec18
ms.openlocfilehash: fe07364e1a6846f9b7b47b2b79ce8031122edbbd
ms.sourcegitcommit: 4ba3304eebaa8c493c3e5307bdd9d723cd90b655
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 12/12/2018
ms.locfileid: "53307107"
---
# <a name="transient-fault-handling"></a><span data-ttu-id="d62fd-103">暫時性錯誤處理</span><span class="sxs-lookup"><span data-stu-id="d62fd-103">Transient fault handling</span></span>

<span data-ttu-id="d62fd-104">與遠端服務和資源進行通訊的所有應用程式必須能感應暫時性錯誤。</span><span class="sxs-lookup"><span data-stu-id="d62fd-104">All applications that communicate with remote services and resources must be sensitive to transient faults.</span></span> <span data-ttu-id="d62fd-105">尤其是執行雲端的應用程式，因為其環境與透過網際網路連線的本質，代表著可能更常碰到暫時性錯誤。</span><span class="sxs-lookup"><span data-stu-id="d62fd-105">This is especially the case for applications that run in the cloud, where the nature of the environment and connectivity over the Internet means these types of faults are likely to be encountered more often.</span></span> <span data-ttu-id="d62fd-106">暫時性錯誤包括瞬間失去元件和服務的網路連線、暫時無法使用服務，或當服務忙碌時逾時。</span><span class="sxs-lookup"><span data-stu-id="d62fd-106">Transient faults include the momentary loss of network connectivity to components and services, the temporary unavailability of a service, or timeouts that arise when a service is busy.</span></span> <span data-ttu-id="d62fd-107">這些錯誤通常會自行修正，如果在適當的延遲後再重複此動作，可能會成功。</span><span class="sxs-lookup"><span data-stu-id="d62fd-107">These faults are often self-correcting, and if the action is repeated after a suitable delay it is likely succeed.</span></span>

<span data-ttu-id="d62fd-108">本文件涵蓋處理暫時性錯誤的一般指引。</span><span class="sxs-lookup"><span data-stu-id="d62fd-108">This document covers general guidance for transient fault handling.</span></span> <span data-ttu-id="d62fd-109">如需處理使用 Microsoft Azure 服務時所發生暫時錯誤的相關資訊，請參閱＜ [Azure 服務特定重試方針](./retry-service-specific.md)＞。</span><span class="sxs-lookup"><span data-stu-id="d62fd-109">For information about handling transient faults when using Microsoft Azure services, see [Azure service-specific retry guidelines](./retry-service-specific.md).</span></span>

<!-- markdownlint-disable MD026 -->

## <a name="why-do-transient-faults-occur-in-the-cloud"></a><span data-ttu-id="d62fd-110">為什麼雲端會發生暫時性錯誤？</span><span class="sxs-lookup"><span data-stu-id="d62fd-110">Why do transient faults occur in the cloud?</span></span>

<!-- markdownlint-enable MD026 -->

<span data-ttu-id="d62fd-111">任何的環境、任何的平台或作業系統，及任何一種應用程式中，都會發生暫時性錯誤。</span><span class="sxs-lookup"><span data-stu-id="d62fd-111">Transient faults can occur in any environment, on any platform or operating system, and in any kind of application.</span></span> <span data-ttu-id="d62fd-112">在本機內部部署的基礎結構上執行的解決方案中，應用程式及其元件的效能與可用性通常是透過昂貴但通常很少使用的硬體備援來維持，且元件與資源的位置互相靠近。</span><span class="sxs-lookup"><span data-stu-id="d62fd-112">In solutions that run on local, on-premises infrastructure, performance and availability of the application and its components is typically maintained through expensive and often under-used hardware redundancy, and components and resources are located close to each another.</span></span> <span data-ttu-id="d62fd-113">雖然這比較不可能失敗，它可能仍會導致暫時性失敗，甚至透過不可預見的事件，例如外部電源供應器或網路問題或其他嚴重損壞狀況中斷。</span><span class="sxs-lookup"><span data-stu-id="d62fd-113">While this makes a failure less likely, it can still result in transient faults - and even an outage through unforeseen events such as external power supply or network issues, or other disaster scenarios.</span></span>

<span data-ttu-id="d62fd-114">雲端託管 (包括私人雲端系統) 使用共用的資源、備援、自動容錯移轉，以及動態地在大量的商業計算節點之間分配資源，以提高整體的可用性。</span><span class="sxs-lookup"><span data-stu-id="d62fd-114">Cloud hosting, including private cloud systems, can offer a higher overall availability by using shared resources, redundancy, automatic failover, and dynamic resource allocation across a huge number of commodity compute nodes.</span></span> <span data-ttu-id="d62fd-115">不過，這些環境的本質意味著更可能發生暫時性錯誤。</span><span class="sxs-lookup"><span data-stu-id="d62fd-115">However, the nature of these environments can mean that transient faults are more likely to occur.</span></span> <span data-ttu-id="d62fd-116">原因包括：</span><span class="sxs-lookup"><span data-stu-id="d62fd-116">There are several reasons for this:</span></span>

- <span data-ttu-id="d62fd-117">雲端環境中有許多共用的資源，為了保護這些資源，會節流存取資源。</span><span class="sxs-lookup"><span data-stu-id="d62fd-117">Many resources in a cloud environment are shared, and access to these resources is subject to throttling in order to protect the resource.</span></span> <span data-ttu-id="d62fd-118">某些服務在負載上升到特定的層級時，或到達輸送量速率上限時，會拒絕連線以允許處理現有的要求，並維護所有使用者的服務效能。</span><span class="sxs-lookup"><span data-stu-id="d62fd-118">Some services will refuse connections when the load rises to a specific level, or a maximum throughput rate is reached, in order to allow processing of existing requests and to maintain performance of the service for all users.</span></span> <span data-ttu-id="d62fd-119">節流有助於維護使用共用資源之芳鄰與其他租用戶的服務品質。</span><span class="sxs-lookup"><span data-stu-id="d62fd-119">Throttling helps to maintain the quality of service for neighbors and other tenants using the shared resource.</span></span>

- <span data-ttu-id="d62fd-120">雲端環境是使用大量的商用硬體單位建置而成。</span><span class="sxs-lookup"><span data-stu-id="d62fd-120">Cloud environments are built using vast numbers of commodity hardware units.</span></span> <span data-ttu-id="d62fd-121">雲端環境會將負載動態地分散到多個運算單位與基礎結構元件之間，以提供效能，並藉由自動回收或更換錯誤的單位，以提供可靠性。</span><span class="sxs-lookup"><span data-stu-id="d62fd-121">They deliver performance by dynamically distributing the load across multiple computing units and infrastructure components, and deliver reliability by automatically recycling or replacing failed units.</span></span> <span data-ttu-id="d62fd-122">此動態本質意味著可能偶爾會發生暫時性錯誤和暫時連線失敗。</span><span class="sxs-lookup"><span data-stu-id="d62fd-122">This dynamic nature means that transient faults and temporary connection failures may occasionally occur.</span></span>

- <span data-ttu-id="d62fd-123">在應用程式與資源及其使用的服務之間，通常會有多個硬體元件，包括網路基礎結構，例如路由器和負載平衡器。</span><span class="sxs-lookup"><span data-stu-id="d62fd-123">There are often more hardware components, including network infrastructure such as routers and load balancers, between the application and the resources and services it uses.</span></span> <span data-ttu-id="d62fd-124">此額外的基礎結構偶爾會導致額外的延遲與暫時性連線錯誤。</span><span class="sxs-lookup"><span data-stu-id="d62fd-124">This additional infrastructure can occasionally introduce additional connection latency and transient connection faults.</span></span>

- <span data-ttu-id="d62fd-125">用戶端與伺服器之間的網路狀況會不時改變，尤其是當橫跨網際網路通訊時。</span><span class="sxs-lookup"><span data-stu-id="d62fd-125">Network conditions between the client and the server may be variable, especially when communication crosses the Internet.</span></span> <span data-ttu-id="d62fd-126">即使是在內部部署的位置中，非常繁重的流量負載都可能使得通訊變慢，造成連線間歇性故障。</span><span class="sxs-lookup"><span data-stu-id="d62fd-126">Even in on-premises locations, very heavy traffic loads may slow communication and cause intermittent connection failures.</span></span>

## <a name="challenges"></a><span data-ttu-id="d62fd-127">挑戰</span><span class="sxs-lookup"><span data-stu-id="d62fd-127">Challenges</span></span>

<span data-ttu-id="d62fd-128">暫時性故障會對應用程式的感知可用性造成重大影響，即使應用程式已在所有可預測的狀況下經過徹底的檢查。</span><span class="sxs-lookup"><span data-stu-id="d62fd-128">Transient faults can have a huge impact on the perceived availability of an application, even if it has been thoroughly tested under all foreseeable circumstances.</span></span> <span data-ttu-id="d62fd-129">若要確保雲端託管的應用程式能可靠地作業，應用程式必須能夠回應下列的挑戰：</span><span class="sxs-lookup"><span data-stu-id="d62fd-129">To ensure that cloud-hosted applications operate reliably, they must be able to respond to the following challenges:</span></span>

- <span data-ttu-id="d62fd-130">應用程式必須能夠偵測錯誤發生，並判斷這些錯誤可能是暫時性、持久性，或是終端機故障。</span><span class="sxs-lookup"><span data-stu-id="d62fd-130">The application must be able to detect faults when they occur, and determine if these faults are likely to be transient, more long-lasting, or are terminal failures.</span></span> <span data-ttu-id="d62fd-131">當發生錯誤時，不同的資源可能傳回不同的回應，而且這些回應可能會視作業的內容而所不同，例如對於從儲存體讀取時所發生的錯誤回應，與寫入儲存體時所發生的回應不同。</span><span class="sxs-lookup"><span data-stu-id="d62fd-131">Different resources are likely to return different responses when a fault occurs, and these responses may also vary depending on the context of the operation; for example, the response for an error when reading from storage may be different from response for an error when writing to storage.</span></span> <span data-ttu-id="d62fd-132">許多資源和服務都有完善記載的暫時性錯誤合約。</span><span class="sxs-lookup"><span data-stu-id="d62fd-132">Many resources and services have well-documented transient failure contracts.</span></span> <span data-ttu-id="d62fd-133">但若未提供這類資訊，則很難發現錯誤的本質，以及其是否可能是暫時性。</span><span class="sxs-lookup"><span data-stu-id="d62fd-133">However, where such information is not available, it may be difficult to discover the nature of the fault and whether it is likely to be transient.</span></span>

- <span data-ttu-id="d62fd-134">如果經判定錯誤可能是暫時性，應用程式必須能夠重試作業，並追蹤作業重試的次數。</span><span class="sxs-lookup"><span data-stu-id="d62fd-134">The application must be able to retry the operation if it determines that the fault is likely to be transient and keep track of the number of times the operation was retried.</span></span>

- <span data-ttu-id="d62fd-135">應用程式必須使用適當的重試策略。</span><span class="sxs-lookup"><span data-stu-id="d62fd-135">The application must use an appropriate strategy for the retries.</span></span> <span data-ttu-id="d62fd-136">此策略會指定它應該重試的次數、每次嘗試之間延遲的時間，以及嘗試失敗後採取的動作。</span><span class="sxs-lookup"><span data-stu-id="d62fd-136">This strategy specifies the number of times it should retry, the delay between each attempt, and the actions to take after a failed attempt.</span></span> <span data-ttu-id="d62fd-137">適當的嘗試次數以及每個嘗試之間的延遲時間通常難以決定，而且會視資源和應用程式本身的目前作業狀況而改變。</span><span class="sxs-lookup"><span data-stu-id="d62fd-137">The appropriate number of attempts and the delay between each one are often difficult to determine, and vary based on the type of resource as well as the current operating conditions of the resource and the application itself.</span></span>

## <a name="general-guidelines"></a><span data-ttu-id="d62fd-138">一般方針</span><span class="sxs-lookup"><span data-stu-id="d62fd-138">General guidelines</span></span>

<span data-ttu-id="d62fd-139">下列指導方針可協助您設計合適的應用程式暫時性錯誤處理機制：</span><span class="sxs-lookup"><span data-stu-id="d62fd-139">The following guidelines will help you to design a suitable transient fault handing mechanism for your applications:</span></span>

- <span data-ttu-id="d62fd-140">**判斷是否有內建的重試機制：**</span><span class="sxs-lookup"><span data-stu-id="d62fd-140">**Determine if there is a built-in retry mechanism:**</span></span>

  - <span data-ttu-id="d62fd-141">許多服務提供 SDK 或包含暫時性錯誤處理機制的用戶端程式庫。</span><span class="sxs-lookup"><span data-stu-id="d62fd-141">Many services provide an SDK or client library that contains a transient fault handling mechanism.</span></span> <span data-ttu-id="d62fd-142">其使用的重試原則通常是針對目標服務的本質與需求量身訂做。</span><span class="sxs-lookup"><span data-stu-id="d62fd-142">The retry policy it uses is typically tailored to the nature and requirements of the target service.</span></span> <span data-ttu-id="d62fd-143">或者，對於判斷重試是否適當，以及在下一次嘗試重試之前要等待多久的時間方面，服務的 REST 介面可能會傳回很有幫助的資訊。</span><span class="sxs-lookup"><span data-stu-id="d62fd-143">Alternatively, REST interfaces for services may return information that is useful in determining whether a retry is appropriate, and how long to wait before the next retry attempt.</span></span>

  - <span data-ttu-id="d62fd-144">除非您有具體且明確的需求，需要其他更適當的重試行為，否則請使用可用的內建重試機制。</span><span class="sxs-lookup"><span data-stu-id="d62fd-144">Use the built-in retry mechanism where one is available unless you have specific and well-understood requirements that mean a different retry behavior is more appropriate.</span></span>

- <span data-ttu-id="d62fd-145">**判定作業是否適合重試**：</span><span class="sxs-lookup"><span data-stu-id="d62fd-145">**Determine if the operation is suitable for retrying**:</span></span>

  - <span data-ttu-id="d62fd-146">只在錯誤是暫時性 (通常可由錯誤的本質來判定)，以及在重新嘗試後作業至少有一些成功的可能性時，您才應重試作業。</span><span class="sxs-lookup"><span data-stu-id="d62fd-146">You should only retry operations where the faults are transient (typically indicated by the nature of the error), and if there is at least some likelihood that the operation will succeed when reattempted.</span></span> <span data-ttu-id="d62fd-147">若作業是無效的作業，例如資料庫所更新的項目不存在，或者要求的服務或資源發生嚴重錯誤，重新嘗試是沒有意義的。</span><span class="sxs-lookup"><span data-stu-id="d62fd-147">There is no point in reattempting operations that indicate an invalid operation such as a database update to an item that does not exist, or requests to a service or resource that has suffered a fatal error</span></span>

  - <span data-ttu-id="d62fd-148">一般而言，只要在能夠判斷作業的完整影響，且狀況已獲充分瞭解並可驗證時，您才應實作重試。</span><span class="sxs-lookup"><span data-stu-id="d62fd-148">In general, you should implement retries only where the full impact of this can be determined, and the conditions are well understood and can be validated.</span></span> <span data-ttu-id="d62fd-149">如果不是，則將它留給呼叫程式碼來實作重試。</span><span class="sxs-lookup"><span data-stu-id="d62fd-149">If not, leave it to the calling code to implement retries.</span></span> <span data-ttu-id="d62fd-150">請記住，從您無法控制的資源與服務傳回的錯誤可能會隨著時間而演進，您可能需要重新檢視您的暫時性錯誤偵測邏輯。</span><span class="sxs-lookup"><span data-stu-id="d62fd-150">Remember that the errors returned from resources and services outside your control may evolve over time, and you may need to revisit your transient fault detection logic.</span></span>

  - <span data-ttu-id="d62fd-151">當您建立服務或元件時，請考慮實作錯誤碼和訊息，來協助用戶端判斷它們是否應重試失敗的作業。</span><span class="sxs-lookup"><span data-stu-id="d62fd-151">When you create services or components, consider implementing error codes and messages that will help clients determine whether they should retry failed operations.</span></span> <span data-ttu-id="d62fd-152">特別是，指出用戶端是否應該重試作業 (或許是藉由傳回 **isTransient** 值)，並建議在下一次重試之前適當的延遲時間。</span><span class="sxs-lookup"><span data-stu-id="d62fd-152">In particular, indicate if the client should retry the operation (perhaps by returning an **isTransient** value) and suggest a suitable delay before the next retry attempt.</span></span> <span data-ttu-id="d62fd-153">如果您建立 Web 服務，請考慮傳回在您的服務合約中定義的自訂錯誤。</span><span class="sxs-lookup"><span data-stu-id="d62fd-153">If you build a web service, consider returning custom errors defined within your service contracts.</span></span> <span data-ttu-id="d62fd-154">即使一般用戶端可能無法讀取這些錯誤，但在建置自訂用戶端時，自訂錯誤很有幫助。</span><span class="sxs-lookup"><span data-stu-id="d62fd-154">Even though generic clients may not be able to read these, they will be useful when building custom clients.</span></span>

- <span data-ttu-id="d62fd-155">**決定適當的重試計數與間隔：**</span><span class="sxs-lookup"><span data-stu-id="d62fd-155">**Determine an appropriate retry count and interval:**</span></span>

  - <span data-ttu-id="d62fd-156">請務必最佳化重試計數和使用案例類型的間隔。</span><span class="sxs-lookup"><span data-stu-id="d62fd-156">It is vital to optimize the retry count and the interval to the type of use case.</span></span> <span data-ttu-id="d62fd-157">如果您重試的次數不足，應用程式將無法完成作業，並可能會遭遇失敗。</span><span class="sxs-lookup"><span data-stu-id="d62fd-157">If you do not retry a sufficient number of times, the application will be unable to complete the operation and is likely to experience a failure.</span></span> <span data-ttu-id="d62fd-158">如果重試次數太多或間隔太短，應用程式可能會長期保留資源，例如執行緒、連線和記憶體，這對於應用程式的健全狀況有不利的影響。</span><span class="sxs-lookup"><span data-stu-id="d62fd-158">If you retry too many times, or with too short an interval between tries, the application can potentially hold resources such as threads, connections, and memory for long periods, which will adversely affect the health of the application.</span></span>

  - <span data-ttu-id="d62fd-159">適當的重試嘗試時間間隔與次數，取決於正在嘗試的作業類型。</span><span class="sxs-lookup"><span data-stu-id="d62fd-159">The appropriate values for the time interval and the number of retry attempts depend on the type of operation being attempted.</span></span> <span data-ttu-id="d62fd-160">例如，如果作業是使用者互動的一部分，則間隔應短，且只需要重試幾次，以避免讓使用者等候回應 (這會讓連線保持開啟，並減少其他使用者的可用性)。</span><span class="sxs-lookup"><span data-stu-id="d62fd-160">For example, if the operation is part of a user interaction, the interval should be short and only a few retries attempted to avoid making users wait for a response (which holds open connections and can reduce availability for other users).</span></span> <span data-ttu-id="d62fd-161">如果作業是長期執行或重要工作流程的一部分，要取消並重新啟動工作流程的處理程序是昂貴或耗時的，則嘗試之間的等待時間應較長，並重試更多次。</span><span class="sxs-lookup"><span data-stu-id="d62fd-161">If the operation is part of a long running or critical workflow, where cancelling and restarting the process is expensive or time-consuming, it is appropriate to wait longer between attempts and retry more times.</span></span>

  - <span data-ttu-id="d62fd-162">設計一個成功的策略時，決定適當的重試間隔是最困難的一部分。</span><span class="sxs-lookup"><span data-stu-id="d62fd-162">Determining the appropriate intervals between retries is the most difficult part of designing a successful strategy.</span></span> <span data-ttu-id="d62fd-163">一般的策略會使用下列幾類的重試間隔：</span><span class="sxs-lookup"><span data-stu-id="d62fd-163">Typical strategies use the following types of retry interval:</span></span>

    - <span data-ttu-id="d62fd-164">**指數退避法**。</span><span class="sxs-lookup"><span data-stu-id="d62fd-164">**Exponential back-off**.</span></span> <span data-ttu-id="d62fd-165">應用程式在第一次重試之前短暫地等待，然後每個後續重試的間隔時間呈指數增加。</span><span class="sxs-lookup"><span data-stu-id="d62fd-165">The application waits a short time before the first retry, and then exponentially increasing times between each subsequent retry.</span></span> <span data-ttu-id="d62fd-166">例如，會在 3 秒、12 秒、30 秒後重試作業。</span><span class="sxs-lookup"><span data-stu-id="d62fd-166">For example, it may retry the operation after 3 seconds, 12 seconds, 30 seconds, and so on.</span></span>

    - <span data-ttu-id="d62fd-167">**累加間隔**。</span><span class="sxs-lookup"><span data-stu-id="d62fd-167">**Incremental intervals**.</span></span> <span data-ttu-id="d62fd-168">應用程式在第一次重試之前短暫地等待，然後每個後續重試的間隔時間呈累加增加。</span><span class="sxs-lookup"><span data-stu-id="d62fd-168">The application waits a short time before the first retry, and then incrementally increasing times between each subsequent retry.</span></span> <span data-ttu-id="d62fd-169">例如，會在 3 秒、7 秒、13 秒後重試作業。</span><span class="sxs-lookup"><span data-stu-id="d62fd-169">For example, it may retry the operation after 3 seconds, 7 seconds, 13 seconds, and so on.</span></span>

    - <span data-ttu-id="d62fd-170">**固定間隔**。</span><span class="sxs-lookup"><span data-stu-id="d62fd-170">**Regular intervals**.</span></span> <span data-ttu-id="d62fd-171">應用程式每次嘗試的間隔時間相同。</span><span class="sxs-lookup"><span data-stu-id="d62fd-171">The application waits for the same period of time between each attempt.</span></span> <span data-ttu-id="d62fd-172">例如，固定每 3 秒重試作業。</span><span class="sxs-lookup"><span data-stu-id="d62fd-172">For example, it may retry the operation every 3 seconds.</span></span>

    - <span data-ttu-id="d62fd-173">**立即重試**。</span><span class="sxs-lookup"><span data-stu-id="d62fd-173">**Immediate retry**.</span></span> <span data-ttu-id="d62fd-174">有時候暫時性錯誤極短，可能是因網路封包衝突或硬體元件流量突增等事件造成的。</span><span class="sxs-lookup"><span data-stu-id="d62fd-174">Sometimes a transient fault is extremely short, perhaps caused by an event such as a network packet collision or a spike in a hardware component.</span></span> <span data-ttu-id="d62fd-175">在此情況下，適合立即重試作業，因為如果錯誤在作業讓應用程式組合並傳送下一個要求時已清除，則作業可能會成功。</span><span class="sxs-lookup"><span data-stu-id="d62fd-175">In this case, retrying the operation immediately is appropriate because it may succeed if the fault has cleared in the time it takes the application to assemble and send the next request.</span></span> <span data-ttu-id="d62fd-176">不過，立即重試嘗試次數不得超過一次，如果立即重試失敗，應改換備用策略，例如指數退避法或後援動作。</span><span class="sxs-lookup"><span data-stu-id="d62fd-176">However, there should never be more than one immediate retry attempt, and you should switch to alternative strategies, such as such as exponential back-off or fallback actions, if the immediate retry fails.</span></span>

    - <span data-ttu-id="d62fd-177">**隨機**。</span><span class="sxs-lookup"><span data-stu-id="d62fd-177">**Randomization**.</span></span> <span data-ttu-id="d62fd-178">任何上述的重試策略都可包含隨機，以防止用戶端的多個執行個體同時傳送後續的重試嘗試。</span><span class="sxs-lookup"><span data-stu-id="d62fd-178">Any of the retry strategies listed above may include a randomization to prevent multiple instances of the client sending subsequent retry attempts at the same time.</span></span> <span data-ttu-id="d62fd-179">例如，一個執行個體可能會在 3 秒、11 秒、28 秒後重試作業，而另一個執行個體則在 4 秒、12 秒、26 秒後重試作業。</span><span class="sxs-lookup"><span data-stu-id="d62fd-179">For example, one instance may retry the operation after 3 seconds, 11 seconds, 28 seconds, and so on while another instance may retry the operation after 4 seconds, 12 seconds, 26 seconds, and so on.</span></span> <span data-ttu-id="d62fd-180">隨機是很有用的技巧，可搭配其他策略使用。</span><span class="sxs-lookup"><span data-stu-id="d62fd-180">Randomization is a useful technique that may be combined with other strategies.</span></span>

  - <span data-ttu-id="d62fd-181">一般來說，會為背景作業採用指數退避法策略，為互動式作業採用立即或固定間隔重試策略。</span><span class="sxs-lookup"><span data-stu-id="d62fd-181">As a general guideline, use an exponential back-off strategy for background operations, and immediate or regular interval retry strategies for interactive operations.</span></span> <span data-ttu-id="d62fd-182">在上述這兩種狀況中，您應該選擇延遲與重試計數，讓所有重試嘗試的延遲上限都會在所需的端對端延遲需求之內。</span><span class="sxs-lookup"><span data-stu-id="d62fd-182">In both cases, you should choose the delay and the retry count so that the maximum latency for all retry attempts is within the required end-to-end latency requirement.</span></span>

  - <span data-ttu-id="d62fd-183">請考量到所有會對重試作業的整體逾時上限造成影響的因素組合。</span><span class="sxs-lookup"><span data-stu-id="d62fd-183">Take into account the combination of all the factors that contribute to the overall maximum timeout for a retried operation.</span></span> <span data-ttu-id="d62fd-184">這些因素包括失敗連線產生回應所花費的時間 (通常是由用戶端的逾時值所設定)，以及重試嘗試之間的延遲和重試次數上限。</span><span class="sxs-lookup"><span data-stu-id="d62fd-184">These factors include the time taken for a failed connection to produce a response (typically set by a timeout value in the client) as well as the delay between retry attempts and the maximum number of retries.</span></span> <span data-ttu-id="d62fd-185">所有這些時間的總和會導致整體作業非常長，尤其是在使用指數退避法策略時，因為每次錯誤後重試的間隔會快速成長。</span><span class="sxs-lookup"><span data-stu-id="d62fd-185">The total of all these times can result in very large overall operation times, especially when using an exponential delay strategy where the interval between retries grows rapidly after each failure.</span></span> <span data-ttu-id="d62fd-186">如果處理程序必須符合特定的服務等級協定 (SLA)，則整體的作業時間，包括所有的逾時和延遲，必須在 SLA 所定義的作業時間之內。</span><span class="sxs-lookup"><span data-stu-id="d62fd-186">If a process must meet a specific service level agreement (SLA), the overall operation time, including all timeouts and delays, must be within that defined in the SLA.</span></span>

  - <span data-ttu-id="d62fd-187">過度積極的重試策略，例如間隔太短或重試次數過多，會對目標資源或服務造成不利的影響。</span><span class="sxs-lookup"><span data-stu-id="d62fd-187">Over-aggressive retry strategies, which have too short intervals or too may retries, can have an adverse effect on the target resource or service.</span></span> <span data-ttu-id="d62fd-188">這可能會讓資源或服務無法從過載的狀態復原，而且它將會繼續封鎖或拒絕要求。</span><span class="sxs-lookup"><span data-stu-id="d62fd-188">This may prevent the resource or service from recovering from its overloaded state, and it will continue to block or refuse requests.</span></span> <span data-ttu-id="d62fd-189">這會造成惡性循環，越來越多的要求傳送到資源或服務，因而造成其復原能力進一步降低。</span><span class="sxs-lookup"><span data-stu-id="d62fd-189">This results in a vicious circle where more and more requests are sent to the resource or service, and consequently its ability to recover is further reduced.</span></span>

  - <span data-ttu-id="d62fd-190">選擇重試間隔時請考量作業的逾時，以避免立即啟動後續的嘗試 (例如當逾時期間與重試間隔類似時)。</span><span class="sxs-lookup"><span data-stu-id="d62fd-190">Take into account the timeout of the operations when choosing the retry intervals to avoid launching a subsequent attempt immediately (for example, if the timeout period is similar to the retry interval).</span></span> <span data-ttu-id="d62fd-191">也請考慮您是否需要讓可能期間的總和 (逾時值加上重試間隔) 短於特定的時間總和。</span><span class="sxs-lookup"><span data-stu-id="d62fd-191">Also consider if you need to keep the total possible period (the timeout plus the retry intervals) to below a specific total time.</span></span> <span data-ttu-id="d62fd-192">逾時設定非常短或非常長的的作業可能會影響等候的時間，以及重試作業的頻率。</span><span class="sxs-lookup"><span data-stu-id="d62fd-192">Operations that have unusually short or very long timeouts may influence how long to wait, and how often to retry the operation.</span></span>

  - <span data-ttu-id="d62fd-193">使用例外狀況類型及其包含的任何資料，或使用從服務傳回的錯誤碼與訊息，來最佳化重試的間隔和次數。</span><span class="sxs-lookup"><span data-stu-id="d62fd-193">Use the type of the exception and any data it contains, or the error codes and messages returned from the service, to optimize the interval and the number of retries.</span></span> <span data-ttu-id="d62fd-194">例如，某些例外狀況或錯誤代碼 (例如 HTTP 代碼 503：無法以回應中的 Retry-After 標頭提供服務) 會指出錯誤可能持續時間的長度，或服務失敗且不會回應任何後續的嘗試。</span><span class="sxs-lookup"><span data-stu-id="d62fd-194">For example, some exceptions or error codes (such as the HTTP code 503 Service Unavailable with a Retry-After header in the response) may indicate how long the error might last, or that the service has failed and will not respond to any subsequent attempt.</span></span>

- <span data-ttu-id="d62fd-195">**避免反向模式**：</span><span class="sxs-lookup"><span data-stu-id="d62fd-195">**Avoid anti-patterns**:</span></span>

  - <span data-ttu-id="d62fd-196">在絕大多數情況下，您應該避免包含重複重試程式碼層的實作。</span><span class="sxs-lookup"><span data-stu-id="d62fd-196">In the vast majority of cases, you should avoid implementations that include duplicated layers of retry code.</span></span> <span data-ttu-id="d62fd-197">請避免包括階層式重試機制的設計，或避免在涉及要求階層之作業的每個階段實作重試，除非您有此特定的需求。</span><span class="sxs-lookup"><span data-stu-id="d62fd-197">Avoid designs that include cascading retry mechanisms, or that implement retry at every stage of an operation that involves a hierarchy of requests, unless you have specific requirements that demand this.</span></span> <span data-ttu-id="d62fd-198">在這些例外狀況下，請使用原則避免過多的重試次數和延遲期間過長，並確定您瞭解後果。</span><span class="sxs-lookup"><span data-stu-id="d62fd-198">In these exceptional circumstances, use policies that prevent excessive numbers of retries and delay periods, and make sure you understand the consequences.</span></span> <span data-ttu-id="d62fd-199">例如，如果某個元件對另一個元件提出要求，然後存取目標服務，且您要對這兩個呼叫各實作重試三次，則總共會對該服務重試九次。</span><span class="sxs-lookup"><span data-stu-id="d62fd-199">For example, if one component makes a request to another, which then accesses the target service, and you implement retry with a count of three on both calls there will be nine retry attempts in total against the service.</span></span> <span data-ttu-id="d62fd-200">許多服務和資源會實作內建的重試機制，如果您需要在較高層級實作重試，您應該調查如何停用或修改此設定。</span><span class="sxs-lookup"><span data-stu-id="d62fd-200">Many services and resources implement a built-in retry mechanism and you should investigate how you can disable or modify this if you need to implement retries at a higher level.</span></span>

  - <span data-ttu-id="d62fd-201">永遠不要實作無盡的重試機制。</span><span class="sxs-lookup"><span data-stu-id="d62fd-201">Never implement an endless retry mechanism.</span></span> <span data-ttu-id="d62fd-202">這可能會防止資源或服務從過載的情況下復原，並造成節流與遭拒絕連線持續更長的時間。</span><span class="sxs-lookup"><span data-stu-id="d62fd-202">This is likely to prevent the resource or service recovering from overload situations, and cause throttling and refused connections to continue for a longer period.</span></span> <span data-ttu-id="d62fd-203">使用有限的數目或重試次數，或使用如 [斷路器](../patterns/circuit-breaker.md) 等模式，以允許服務復原。</span><span class="sxs-lookup"><span data-stu-id="d62fd-203">Use a finite number or retries, or implement a pattern such as [Circuit Breaker](../patterns/circuit-breaker.md) to allow the service to recover.</span></span>

  - <span data-ttu-id="d62fd-204">永遠不要執行立即重試一次以上。</span><span class="sxs-lookup"><span data-stu-id="d62fd-204">Never perform an immediate retry more than once.</span></span>

  - <span data-ttu-id="d62fd-205">請避免使用固定重試間隔，尤其是當您在存取 Azure 的服務與資源時會重試非常多次時。</span><span class="sxs-lookup"><span data-stu-id="d62fd-205">Avoid using a regular retry interval, especially when you have a large number of retry attempts, when accessing services and resources in Azure.</span></span> <span data-ttu-id="d62fd-206">在此情況下的最佳方法是指數退避策略搭配斷路功能。</span><span class="sxs-lookup"><span data-stu-id="d62fd-206">The optimum approach is this scenario is an exponential back-off strategy with a circuit-breaking capability.</span></span>

  - <span data-ttu-id="d62fd-207">防止同一個用戶端有多個執行個體，或不同用戶端有多個執行個體同時傳送重試。</span><span class="sxs-lookup"><span data-stu-id="d62fd-207">Prevent multiple instances of the same client, or multiple instances of different clients, from sending retries at the same times.</span></span> <span data-ttu-id="d62fd-208">如果這可能發生，請在重試間隔導入隨機策略。</span><span class="sxs-lookup"><span data-stu-id="d62fd-208">If this is likely to occur, introduce randomization into the retry intervals.</span></span>

- <span data-ttu-id="d62fd-209">**測試重試策略與實作：**</span><span class="sxs-lookup"><span data-stu-id="d62fd-209">**Test your retry strategy and implementation:**</span></span>

  - <span data-ttu-id="d62fd-210">請確定在儘可能最多的狀況下完整測試您的重試策略，尤其是當其使用的應用程式與目標資源是在極端負載下時。</span><span class="sxs-lookup"><span data-stu-id="d62fd-210">Ensure you fully test your retry strategy implementation under as wide a set of circumstances as possible, especially when both the application and the target resources or services it uses are under extreme load.</span></span> <span data-ttu-id="d62fd-211">若要檢查測試期間的行為，您可以：</span><span class="sxs-lookup"><span data-stu-id="d62fd-211">To check behavior during testing, you can:</span></span>

    - <span data-ttu-id="d62fd-212">將暫時性與非暫時性錯誤插入服務中。</span><span class="sxs-lookup"><span data-stu-id="d62fd-212">Inject transient and non-transient faults into the service.</span></span> <span data-ttu-id="d62fd-213">例如，傳送無效要求，或新增程式碼來偵測不同錯誤類型的測試要求與回應。</span><span class="sxs-lookup"><span data-stu-id="d62fd-213">For example, send invalid requests or add code that detects test requests and responds with different types of errors.</span></span> <span data-ttu-id="d62fd-214">例如使用 TestApi，請參閱 [TestApi 的錯誤插入測試](https://msdn.microsoft.com/magazine/ff898404.aspx)與 [TestApi 簡介 – 第 5 部：受控程式碼錯誤插入 API](https://blogs.msdn.microsoft.com/ivo_manolov/2009/11/25/introduction-to-testapi-part-5-managed-code-fault-injection-apis/)。</span><span class="sxs-lookup"><span data-stu-id="d62fd-214">For an example using TestApi, see [Fault Injection Testing with TestApi](https://msdn.microsoft.com/magazine/ff898404.aspx) and [Introduction to TestApi – Part 5: Managed Code Fault Injection APIs](https://blogs.msdn.microsoft.com/ivo_manolov/2009/11/25/introduction-to-testapi-part-5-managed-code-fault-injection-apis/).</span></span>

    - <span data-ttu-id="d62fd-215">建立資源或服務模型，以傳回實際服務可能傳回的錯誤範圍。</span><span class="sxs-lookup"><span data-stu-id="d62fd-215">Create a mock of the resource or service that returns a range of errors that the real service may return.</span></span> <span data-ttu-id="d62fd-216">請確定您涵蓋了重試策略其設計要偵測的所有錯誤類型。</span><span class="sxs-lookup"><span data-stu-id="d62fd-216">Ensure you cover all the types of error that your retry strategy is designed to detect.</span></span>

    - <span data-ttu-id="d62fd-217">如果服務是您建立及部署的自訂服務，則透過暫時停用或超載該服務，來強制暫時性錯誤發生 (當然，您不應該嘗試超載 Azure 內的任何共用資源或共用服務)。</span><span class="sxs-lookup"><span data-stu-id="d62fd-217">Force transient errors to occur by temporarily disabling or overloading the service if it is a custom service that you created and deployed (you should not, of course, attempt to overload any shared resources or shared services within Azure).</span></span>

    - <span data-ttu-id="d62fd-218">對於以 HTTP 為基礎的 API，請考慮在您的自動化測試中使用 FiddlerCore 程式庫來變更 HTTP 要求的結果，方法是新增額外的往返次數或變更回應 (例如 HTTP 狀態碼、標頭、內文或其他因素)。</span><span class="sxs-lookup"><span data-stu-id="d62fd-218">For HTTP-based APIs, consider using the FiddlerCore library in your automated tests to change the outcome of HTTP requests, either by adding extra roundtrip times or by changing the response (such as the HTTP status code, headers, body, or other factors).</span></span> <span data-ttu-id="d62fd-219">這會允許決定性測試錯誤狀況的子集，無論是暫時性錯誤或其他類型的錯誤。</span><span class="sxs-lookup"><span data-stu-id="d62fd-219">This enables deterministic testing of a subset of the failure conditions, whether transient faults or other types of failure.</span></span> <span data-ttu-id="d62fd-220">如需詳細資訊，請參閱＜ [FiddlerCore](https://www.telerik.com/fiddler/fiddlercore)＞。</span><span class="sxs-lookup"><span data-stu-id="d62fd-220">For more information, see [FiddlerCore](https://www.telerik.com/fiddler/fiddlercore).</span></span> <span data-ttu-id="d62fd-221">有關如何使用程式庫的範例，尤其是 **HttpMangler** 類別，請檢查 [Azure 儲存體 SDK 的原始程式碼](https://github.com/Azure/azure-storage-net/tree/master/Test)。</span><span class="sxs-lookup"><span data-stu-id="d62fd-221">For examples of how to use the library, particularly the **HttpMangler** class, examine the [source code for the Azure Storage SDK](https://github.com/Azure/azure-storage-net/tree/master/Test).</span></span>

    - <span data-ttu-id="d62fd-222">執行高負載因數和並行測試，確保重試機制與策略在這些條件下能正確運作，且不會對用戶端作業造成不良的影響或導致要求之間交叉污染。</span><span class="sxs-lookup"><span data-stu-id="d62fd-222">Perform high load factor and concurrent tests to ensure that the retry mechanism and strategy works correctly under these conditions, and does not have an adverse effect on the operation of the client or cause cross-contamination between requests.</span></span>

- <span data-ttu-id="d62fd-223">**管理重試原則組態：**</span><span class="sxs-lookup"><span data-stu-id="d62fd-223">**Manage retry policy configurations:**</span></span>

  - <span data-ttu-id="d62fd-224">「重試原則」是所有重試策略元素的組合。</span><span class="sxs-lookup"><span data-stu-id="d62fd-224">A *retry policy* is a combination of all of the elements of your retry strategy.</span></span> <span data-ttu-id="d62fd-225">它定義了能判斷錯誤是否可能是暫時性的偵測機制、使用的間隔類型 (例如固定、指數退避法及隨機)、實際間隔值，以及重試次數。</span><span class="sxs-lookup"><span data-stu-id="d62fd-225">It defines the detection mechanism that determines whether a fault is likely to be transient, the type of interval to use (such as regular, exponential back-off, and randomization), the actual interval value(s), and the number of times to retry.</span></span>

  - <span data-ttu-id="d62fd-226">必須在應用程式內的許多位置實作重試，即使是最簡單的應用程式也需要，至於較複雜的應用程式則必須每一層都實作。</span><span class="sxs-lookup"><span data-stu-id="d62fd-226">Retries must be implemented in many places within even the simplest application, and in every layer of more complex applications.</span></span> <span data-ttu-id="d62fd-227">請考慮集中儲存所有的原則，而非將每個原則的元素硬式編碼在多個位置中。</span><span class="sxs-lookup"><span data-stu-id="d62fd-227">Rather than hard-coding the elements of each policy at multiple locations, consider using a central point for storing all the policies.</span></span> <span data-ttu-id="d62fd-228">例如，在應用程式組態檔中儲存如間隔和重試計數等值、在執行階段讀取這些值，並以程式設計方式建置重試原則。</span><span class="sxs-lookup"><span data-stu-id="d62fd-228">For example, store the values such as the interval and retry count in application configuration files, read them at runtime, and programmatically build the retry policies.</span></span> <span data-ttu-id="d62fd-229">這可讓您更容易管理設定，以及修改和微調值，以回應變更需求和案例。</span><span class="sxs-lookup"><span data-stu-id="d62fd-229">This makes it easier to manage the settings, and to modify and fine tune the values in order to respond to changing requirements and scenarios.</span></span> <span data-ttu-id="d62fd-230">不過，請設計系統以儲存值，而非每一次都要重新讀取組態檔案，並確定在無法從組態取得值時會使用合適的預設值。</span><span class="sxs-lookup"><span data-stu-id="d62fd-230">However, design the system to store the values rather than rereading a configuration file every time, and ensure suitable defaults are used if the values cannot be obtained from configuration.</span></span>

  - <span data-ttu-id="d62fd-231">請考慮在 Azure 雲端服務應用程式中儲存值，以用來在服務組態檔中建置執行階段的重試原則，讓這些值不需要重新啟動應用程式即可變更。</span><span class="sxs-lookup"><span data-stu-id="d62fd-231">In an Azure Cloud Services application, consider storing the values that are used to build the retry policies at runtime in the service configuration file so that they can be changed without needing to restart the application.</span></span>

  - <span data-ttu-id="d62fd-232">利用您所使用用戶端 API 中的內建或預設重試策略，但僅在適合您策略的狀況下利用。</span><span class="sxs-lookup"><span data-stu-id="d62fd-232">Take advantage of built-in or default retry strategies available in the client APIs you use, but only where they are appropriate for your scenario.</span></span> <span data-ttu-id="d62fd-233">這些策略通常是一般用途。</span><span class="sxs-lookup"><span data-stu-id="d62fd-233">These strategies are typically general-purpose.</span></span> <span data-ttu-id="d62fd-234">在某些狀況下，這些策略可能全為必要，但在某些狀況下，可能無法提供完整的選項範圍來滿足您特定的需求。</span><span class="sxs-lookup"><span data-stu-id="d62fd-234">In some scenarios they may be all that is required, but in other scenarios they may not offer the full range of options to suit your specific requirements.</span></span> <span data-ttu-id="d62fd-235">您必須瞭解設定如何透過測試來影響應用程式，以決定最適當的值。</span><span class="sxs-lookup"><span data-stu-id="d62fd-235">You must understand how the settings will affect your application through testing to determine the most appropriate values.</span></span>

- <span data-ttu-id="d62fd-236">**記錄與追蹤暫時性與非暫時性錯誤：**</span><span class="sxs-lookup"><span data-stu-id="d62fd-236">**Log and track transient and non-transient faults:**</span></span>

  - <span data-ttu-id="d62fd-237">在重試策略中包含例外狀況處理，以及其他會記錄嘗試重試時間的工具。</span><span class="sxs-lookup"><span data-stu-id="d62fd-237">As part of your retry strategy, include exception handling and other instrumentation that logs when retry attempts are made.</span></span> <span data-ttu-id="d62fd-238">雖然偶爾暫時性錯誤及重試是預期中的狀況，且不代表有問題，但固定與不斷增加的重試次數，通常代表可能會造成錯誤的問題，或是目前正在影響應用程式的效能與可用性。</span><span class="sxs-lookup"><span data-stu-id="d62fd-238">While an occasional transient failure and retry are to be expected, and do not indicate a problem, regular and increasing numbers of retries are often an indicator of an issue that may cause a failure, or is currently impacting application performance and availability.</span></span>

  - <span data-ttu-id="d62fd-239">請將暫時性錯誤記錄為警告項目，而非錯誤項目，讓監視系統不會將它們偵測成應用程式錯誤而觸發假警示。</span><span class="sxs-lookup"><span data-stu-id="d62fd-239">Log transient faults as Warning entries rather than Error entries so that monitoring systems do not detect them as application errors that may trigger false alerts.</span></span>

  - <span data-ttu-id="d62fd-240">請考慮將值儲存在您的記錄項目中，以指出重試是由服務中的節流所造成的，或是由其他類型的錯誤 (例如連線失敗) 造成的，讓您能夠在分析資料期間加以區分。</span><span class="sxs-lookup"><span data-stu-id="d62fd-240">Consider storing a value in your log entries that indicates if the retries were caused by throttling in the service, or by other types of faults such as connection failures, so that you can differentiate them during analysis of the data.</span></span> <span data-ttu-id="d62fd-241">節流錯誤數目的增加，這通常代表應用程式的設計有瑕疵，或是需要改用可提供專用硬體的高階服務。</span><span class="sxs-lookup"><span data-stu-id="d62fd-241">An increase in the number of throttling errors is often an indicator of a design flaw in the application or the need to switch to a premium service that offers dedicated hardware.</span></span>

  - <span data-ttu-id="d62fd-242">請考慮測量和記錄包含重試機制在內的作業所需的整體時間。</span><span class="sxs-lookup"><span data-stu-id="d62fd-242">Consider measuring and logging the overall time taken for operations that include a retry mechanism.</span></span> <span data-ttu-id="d62fd-243">這是暫時性錯誤對使用者回應時間、處理程序延遲，以及應用程式使用個案效率等整體影響的良好指標。</span><span class="sxs-lookup"><span data-stu-id="d62fd-243">This is a good indicator of the overall effect of transient faults on user response times, process latency, and the efficiency of the application use cases.</span></span> <span data-ttu-id="d62fd-244">此外也要記錄發生重試的次數，以瞭解對回應時間有貢獻的因素。</span><span class="sxs-lookup"><span data-stu-id="d62fd-244">Also log the number of retries occurred in order to understand the factors that contributed to the response time.</span></span>

  - <span data-ttu-id="d62fd-245">請考慮實作遙測和監視系統，當錯誤次數與速率、重試平均數，或作業成功所需的整體時間增加時，此系統就會引發警示。</span><span class="sxs-lookup"><span data-stu-id="d62fd-245">Consider implementing a telemetry and monitoring system that can raise alerts when the number and rate of failures, the average number of retries, or the overall times taken for operations to succeed, is increasing.</span></span>

- <span data-ttu-id="d62fd-246">**管理持續失敗的作業：**</span><span class="sxs-lookup"><span data-stu-id="d62fd-246">**Manage operations that continually fail:**</span></span>
  
  - <span data-ttu-id="d62fd-247">當每次嘗試後作業仍繼續失敗時，請務必考慮您將如何處理這種情況：</span><span class="sxs-lookup"><span data-stu-id="d62fd-247">There will be circumstances where the operation continues to fail at every attempt, and it is vital to consider how you will handle this situation:</span></span>

    - <span data-ttu-id="d62fd-248">雖然重試策略會定義作業應重試次數的上限，但它不會防止應用程式一再地重複作業，達與重試次數相同的次數。</span><span class="sxs-lookup"><span data-stu-id="d62fd-248">Although a retry strategy will define the maximum number of times that an operation should be retried, it does not prevent the application repeating the operation again, with the same number of retries.</span></span> <span data-ttu-id="d62fd-249">例如，如果處理訂單服務因為嚴重錯誤失敗，而永久無法有動作，則重試策略會偵測連線逾時，並將它視為暫時性錯誤。</span><span class="sxs-lookup"><span data-stu-id="d62fd-249">For example, if an order processing service fails with a fatal error that puts it out of action permanently, the retry strategy may detect a connection timeout and consider it to be a transient fault.</span></span> <span data-ttu-id="d62fd-250">程式碼將會重試作業達指定的次數，然後放棄。</span><span class="sxs-lookup"><span data-stu-id="d62fd-250">The code will retry the operation a specified number of times and then give up.</span></span> <span data-ttu-id="d62fd-251">不過，當另一位客戶下單時，會再次嘗試該作業，即使是確定該作業每次都會失敗。</span><span class="sxs-lookup"><span data-stu-id="d62fd-251">However, when another customer places an order, the operation will be attempted again - even though it is sure to fail every time.</span></span>

    - <span data-ttu-id="d62fd-252">為防止不斷重試持續失敗的作業，請考慮實作 [斷器模式](../patterns/circuit-breaker.md)。</span><span class="sxs-lookup"><span data-stu-id="d62fd-252">To prevent continual retries for operations that continually fail, consider implementing the [Circuit Breaker pattern](../patterns/circuit-breaker.md).</span></span> <span data-ttu-id="d62fd-253">在此模式中，如果在指定的時段內失敗次數超過臨界值，則會立即將要求傳回給呼叫者，並視為錯誤，而不會嘗試存取失敗的資源或服務。</span><span class="sxs-lookup"><span data-stu-id="d62fd-253">In this pattern, if the number of failures within a specified time window exceeds the threshold, requests are returned to the caller immediately as errors, without attempting to access the failed resource or service.</span></span>

    - <span data-ttu-id="d62fd-254">應用程式會定期測試服務，並間歇性地偵測服務何時可供使用，且要求之間的間隔非常長。</span><span class="sxs-lookup"><span data-stu-id="d62fd-254">The application can periodically test the service, on an intermittent basis and with very long intervals between requests, to detect when it becomes available.</span></span> <span data-ttu-id="d62fd-255">適當的間隔視案例而定，例如作業的重要性和服務的本質，可能是數分鐘到數個小時。</span><span class="sxs-lookup"><span data-stu-id="d62fd-255">An appropriate interval will depend on the scenario, such as the criticality of the operation and the nature of the service, and might be anything between a few minutes and several hours.</span></span> <span data-ttu-id="d62fd-256">測試成功時，應用程式會恢復正常作業，並將要求傳遞到剛復原的服務。</span><span class="sxs-lookup"><span data-stu-id="d62fd-256">At the point where the test succeeds, the application can resume normal operations and pass requests to the newly recovered service.</span></span>

    - <span data-ttu-id="d62fd-257">同時，可能會切換回服務的另一個執行個體 (或許在不同的資料中或應用程式中)、使用提供相容 (或許是更簡單) 功能的服務，或執行替代作業以期該服務能很快地恢復使用。</span><span class="sxs-lookup"><span data-stu-id="d62fd-257">In the meantime, it may be possible to fall back to another instance of the service (perhaps in a different datacenter or application), use a similar service that offers compatible (perhaps simpler) functionality, or perform some alternative operations in the hope that the service will become available soon.</span></span> <span data-ttu-id="d62fd-258">例如，可能適合將服務的要求儲存在佇列或資料存放區中，且於稍後重新執行。</span><span class="sxs-lookup"><span data-stu-id="d62fd-258">For example, it may be appropriate to store requests for the service in a queue or data store and replay them later.</span></span> <span data-ttu-id="d62fd-259">否則您可能能夠將使用者重新導向至替代的應用程式執行個體、讓應用程式效能降級，但仍然可以提供可接受的功能，或將訊息傳回給使用者，表示應用程式目前無法使用。</span><span class="sxs-lookup"><span data-stu-id="d62fd-259">Otherwise you might be able to redirect the user to an alternative instance of the application, degrade the performance of the application but still offer acceptable functionality, or just return a message to the user indicating that the application is not available at present.</span></span>

- <span data-ttu-id="d62fd-260">**其他考量**</span><span class="sxs-lookup"><span data-stu-id="d62fd-260">**Other considerations**</span></span>
  
  - <span data-ttu-id="d62fd-261">決定重試次數的值和原則的重試間隔時，請考慮服務或資源的作業是否是長時間執行或多步驟作業的一部分。</span><span class="sxs-lookup"><span data-stu-id="d62fd-261">When deciding on the values for the number of retries and the retry intervals for a policy, consider if the operation on the service or resource is part of a long-running or multi-step operation.</span></span> <span data-ttu-id="d62fd-262">當某個作業步驟失敗時，若要補償所有其他的作業步驟，可能會很困難或昂貴。</span><span class="sxs-lookup"><span data-stu-id="d62fd-262">It may be difficult or expensive to compensate all the other operational steps that have already succeeded when one fails.</span></span> <span data-ttu-id="d62fd-263">在此情況下，可接受很長的間隔及大量的重試次數，只要不會因為保留或鎖定稀少的資源，而封鎖其他的作業。</span><span class="sxs-lookup"><span data-stu-id="d62fd-263">In this case, a very long interval and a large number of retries may be acceptable as long as it does not block other operations by holding or locking scarce resources.</span></span>

  - <span data-ttu-id="d62fd-264">請思考一下重試相同的作業是否會導致資料不一致。</span><span class="sxs-lookup"><span data-stu-id="d62fd-264">Consider if retrying the same operation may cause inconsistencies in data.</span></span> <span data-ttu-id="d62fd-265">如果多步驟程序中有某些部分是重複的，且作業不具有等冪性，則可能會導致不一致的問題。</span><span class="sxs-lookup"><span data-stu-id="d62fd-265">If some parts of a multi-step process are repeated, and the operations are not idempotent, it may result in an inconsistency.</span></span> <span data-ttu-id="d62fd-266">例如，會累加值的作業如果重複，則會產生無效的結果。</span><span class="sxs-lookup"><span data-stu-id="d62fd-266">For example, an operation that increments a value, if repeated, will produce an invalid result.</span></span> <span data-ttu-id="d62fd-267">重複執行將訊息傳送至佇列的作業，如果無法偵測到重複訊息的話，則可能會在訊息取用者中造成不一致的狀況。</span><span class="sxs-lookup"><span data-stu-id="d62fd-267">Repeating an operation that sends a message to a queue may cause an inconsistency in the message consumer if it cannot detect duplicate messages.</span></span> <span data-ttu-id="d62fd-268">若要避免這個問題，請確定將每個步驟設計成等冪作業。</span><span class="sxs-lookup"><span data-stu-id="d62fd-268">To prevent this, ensure that you design each step as an idempotent operation.</span></span> <span data-ttu-id="d62fd-269">如需有關冪等性的詳細資訊，請參閱[冪等性模式][idempotency-patterns]。</span><span class="sxs-lookup"><span data-stu-id="d62fd-269">For more information about idempotency, see [Idempotency patterns][idempotency-patterns].</span></span>

  - <span data-ttu-id="d62fd-270">請思考一下作業將重試的範圍。</span><span class="sxs-lookup"><span data-stu-id="d62fd-270">Consider the scope of the operations that will be retried.</span></span> <span data-ttu-id="d62fd-271">例如，很容易在包含數個作業的層級實作重試程式碼，如果其中一個失敗，也很容易重試所有的作業。</span><span class="sxs-lookup"><span data-stu-id="d62fd-271">For example, it may be easier to implement retry code at a level that encompasses several operations, and retry them all if one fails.</span></span> <span data-ttu-id="d62fd-272">不過，這樣可能會導致等冪性問題或不必要的回復作業。</span><span class="sxs-lookup"><span data-stu-id="d62fd-272">However, doing this may result in idempotency issues or unnecessary rollback operations.</span></span>

  - <span data-ttu-id="d62fd-273">如果您選擇的重試範圍包含數個作業，當決定重試間隔時、監視花費時間時，以及因失敗而引發警示前，請考慮所有作業的延遲總和。</span><span class="sxs-lookup"><span data-stu-id="d62fd-273">If you choose a retry scope that encompasses several operations, take into account the total latency of all of them when determining the retry intervals, when monitoring the time taken, and before raising alerts for failures.</span></span>

  - <span data-ttu-id="d62fd-274">請思考一下您的重試策略如何影響共用應用程式中的芳鄰或其他租用戶，以及何時使用共用資源與服務。</span><span class="sxs-lookup"><span data-stu-id="d62fd-274">Consider how your retry strategy may affect neighbors and other tenants in a shared application, or when using shared resources and services.</span></span> <span data-ttu-id="d62fd-275">積極重試原則會導致其他的使用者，以及共用資源與服務的應用程式，發生越來越多的暫時性錯誤。</span><span class="sxs-lookup"><span data-stu-id="d62fd-275">Aggressive retry policies can cause an increasing number of transient faults to occur for these other users and for applications that share the resources and services.</span></span> <span data-ttu-id="d62fd-276">同樣的，您的應用程式可能會受到由資源與服務的其他使用者所實作的重試原則影響。</span><span class="sxs-lookup"><span data-stu-id="d62fd-276">Likewise, your application may be affected by the retry policies implemented by other users of the resources and services.</span></span> <span data-ttu-id="d62fd-277">對於關鍵任務應用程式，您可以決定使用非共用的高階服務。</span><span class="sxs-lookup"><span data-stu-id="d62fd-277">For mission-critical applications, you may decide to use premium services that are not shared.</span></span> <span data-ttu-id="d62fd-278">這可讓您更能控制這些資源與服務的負載與後續節流，進而有助於調整額外的成本。</span><span class="sxs-lookup"><span data-stu-id="d62fd-278">This provides you with much more control over the load and consequent throttling of these resources and services, which can help to justify the additional cost.</span></span>

## <a name="more-information"></a><span data-ttu-id="d62fd-279">詳細資訊</span><span class="sxs-lookup"><span data-stu-id="d62fd-279">More information</span></span>

- [<span data-ttu-id="d62fd-280">Azure 服務特定重試方針</span><span class="sxs-lookup"><span data-stu-id="d62fd-280">Azure service-specific retry guidelines</span></span>](./retry-service-specific.md)
- [<span data-ttu-id="d62fd-281">斷路器模式</span><span class="sxs-lookup"><span data-stu-id="d62fd-281">Circuit Breaker pattern</span></span>](../patterns/circuit-breaker.md)
- [<span data-ttu-id="d62fd-282">補償交易模式</span><span class="sxs-lookup"><span data-stu-id="d62fd-282">Compensating Transaction pattern</span></span>](../patterns/compensating-transaction.md)
- <span data-ttu-id="d62fd-283">[冪等性模式][idempotency-patterns]</span><span class="sxs-lookup"><span data-stu-id="d62fd-283">[Idempotency patterns][idempotency-patterns]</span></span>

<!-- links -->

[idempotency-patterns]: https://blog.jonathanoliver.com/idempotency-patterns/
