---
title: "識別微服務界限"
description: "識別微服務界限"
author: MikeWasson
ms.date: 12/08/2017
ms.openlocfilehash: e4f11da9f970724c55ad99824f808a10c4558971
ms.sourcegitcommit: 744ad1381e01bbda6a1a7eff4b25e1a337385553
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/08/2018
---
# <a name="designing-microservices-identifying-microservice-boundaries"></a><span data-ttu-id="37928-103">設計微服務：識別微服務界限</span><span class="sxs-lookup"><span data-stu-id="37928-103">Designing microservices: Identifying microservice boundaries</span></span>

<span data-ttu-id="37928-104">微服務的合適大小為何？</span><span class="sxs-lookup"><span data-stu-id="37928-104">What is the right size for a microservice?</span></span> <span data-ttu-id="37928-105">您常會聽到「不要太大也不要太小」的說法，這麼說當然沒錯，然而這樣的說法在實務上沒什麼用處。</span><span class="sxs-lookup"><span data-stu-id="37928-105">You often hear something to the effect of, "not too big and not too small" &mdash; and while that's certainly correct, it's not very helpful in practice.</span></span> <span data-ttu-id="37928-106">不過，如果您一開始就審慎設計領域模型，那麼您就可以更加容易地理解微服務。</span><span class="sxs-lookup"><span data-stu-id="37928-106">But if you start from a carefully designed domain model, it's much easier to reason about microservices.</span></span>

![](./images/bounded-contexts.png)

## <a name="from-domain-model-to-microservices"></a><span data-ttu-id="37928-107">從網域模型到微服務</span><span class="sxs-lookup"><span data-stu-id="37928-107">From domain model to microservices</span></span>

<span data-ttu-id="37928-108">在[上一章](./domain-analysis.md)中，我們已經定義一組供「無人機遞送」應用程式使用的限界內容。</span><span class="sxs-lookup"><span data-stu-id="37928-108">In the [previous chapter](./domain-analysis.md), we defined a set of bounded contexts for the Drone Delivery application.</span></span> <span data-ttu-id="37928-109">接著，我們更仔細地查看了這些限界內容的其中一個 (也就是「出貨」限界內容)，並找出該限界內容的一組實體、彙總和領域服務。</span><span class="sxs-lookup"><span data-stu-id="37928-109">Then we looked more closely at one of these bounded contexts, the Shipping bounded context, and identified a set of entities, aggregates, and domain services for that bounded context.</span></span>

<span data-ttu-id="37928-110">而現在，我們已準備好從領域模型階段進入應用程式設計階段。</span><span class="sxs-lookup"><span data-stu-id="37928-110">Now we're ready to go from domain model to application design.</span></span> <span data-ttu-id="37928-111">以下是可用來從領域模型衍生出微服務的方法。</span><span class="sxs-lookup"><span data-stu-id="37928-111">Here's an approach that you can use to derive microservices from the domain model.</span></span>

1. <span data-ttu-id="37928-112">從限界內容來開始。</span><span class="sxs-lookup"><span data-stu-id="37928-112">Start with a bounded context.</span></span> <span data-ttu-id="37928-113">一般來說，微服務中的功能應該不會跨越多個限界內容。</span><span class="sxs-lookup"><span data-stu-id="37928-113">In general, the functionality in a microservice should not span more than one bounded context.</span></span> <span data-ttu-id="37928-114">根據定義，限界內容會標示特定領域模型的界限。</span><span class="sxs-lookup"><span data-stu-id="37928-114">By definition, a bounded context marks the boundary of a particular domain model.</span></span> <span data-ttu-id="37928-115">如果您發現某個微服務與不同的領域模型混合在一起，這表示您可能需要回頭重新琢磨您的領域分析。</span><span class="sxs-lookup"><span data-stu-id="37928-115">If you find that a microservice mixes different domain models together, that's a sign that you may need to go back and refine your domain analysis.</span></span>

2. <span data-ttu-id="37928-116">接著，查看領域模型中的彙總。</span><span class="sxs-lookup"><span data-stu-id="37928-116">Next, look at the aggregates in your domain model.</span></span> <span data-ttu-id="37928-117">彙總通常很適合作為微服務。</span><span class="sxs-lookup"><span data-stu-id="37928-117">Aggregates are often good candidates for microservices.</span></span> <span data-ttu-id="37928-118">設計良好的彙總會展現出擁有良好設計之微服務的許多特性，例如：</span><span class="sxs-lookup"><span data-stu-id="37928-118">A well-designed aggregate exhibits many of the characteristics of a well-designed microservice, such as:</span></span>

    - <span data-ttu-id="37928-119">彙總是衍生自商務需求而非出於技術方面的顧慮 (例如資料存取或傳訊)。</span><span class="sxs-lookup"><span data-stu-id="37928-119">An aggregates is derived from business requirements, rather than technical concerns such as data access or messaging.</span></span>  
    - <span data-ttu-id="37928-120">彙總應該要高度銜接各項功能。</span><span class="sxs-lookup"><span data-stu-id="37928-120">An aggregate should have high functional cohesion.</span></span>
    - <span data-ttu-id="37928-121">彙總是持續性的界限。</span><span class="sxs-lookup"><span data-stu-id="37928-121">An aggregate is a boundary of persistence.</span></span>
    - <span data-ttu-id="37928-122">彙總應該要鬆散結合。</span><span class="sxs-lookup"><span data-stu-id="37928-122">Aggregates should be loosely coupled.</span></span> 
    
3. <span data-ttu-id="37928-123">領域服務也十分適合作為微服務。</span><span class="sxs-lookup"><span data-stu-id="37928-123">Domain services are also good candidates for microservices.</span></span> <span data-ttu-id="37928-124">領域服務是跨多個彙總的無狀態作業。</span><span class="sxs-lookup"><span data-stu-id="37928-124">Domain services are stateless operations across multiple aggregates.</span></span> <span data-ttu-id="37928-125">涉及數個微服務的工作流程便是典型的範例。</span><span class="sxs-lookup"><span data-stu-id="37928-125">A typical example is a workflow that involves several microservices.</span></span> <span data-ttu-id="37928-126">我們會在「無人機遞送」應用程式中看到這樣的範例。</span><span class="sxs-lookup"><span data-stu-id="37928-126">We'll see an example of this in the Drone Delivery application.</span></span>

4. <span data-ttu-id="37928-127">最後要考慮非功能性的需求。</span><span class="sxs-lookup"><span data-stu-id="37928-127">Finally, consider non-functional requirements.</span></span> <span data-ttu-id="37928-128">審視各項因素，例如小組規模、資料類型、技術、延展性需求、可用性需求和安全性需求。</span><span class="sxs-lookup"><span data-stu-id="37928-128">Look at factors such as team size, data types, technologies, scalability requirements, availability requirements, and security requirements.</span></span> <span data-ttu-id="37928-129">這些因素可能會讓您進一步將微服務分解成兩個以上較小的服務，或反過來將數個微服務合併成一個。</span><span class="sxs-lookup"><span data-stu-id="37928-129">These factors may lead you to further decompose a microservice into two or more smaller services, or do the opposite and combine several microservices into one.</span></span> 

<span data-ttu-id="37928-130">在識別應用程式中的各個微服務後，請根據下列準則驗證您的設計：</span><span class="sxs-lookup"><span data-stu-id="37928-130">After you identify the microservices in your application, validate your design against the following criteria:</span></span>

- <span data-ttu-id="37928-131">每一項服務都各肩負一項責任。</span><span class="sxs-lookup"><span data-stu-id="37928-131">Each service has a single responsibility.</span></span>
- <span data-ttu-id="37928-132">服務之間不會頻繁地通訊。</span><span class="sxs-lookup"><span data-stu-id="37928-132">There are no chatty calls between services.</span></span> <span data-ttu-id="37928-133">如果將功能分割成兩個服務會使這兩個服務頻繁通訊，便可能表示這些功能應該放在同一個服務內。</span><span class="sxs-lookup"><span data-stu-id="37928-133">If splitting functionality into two services causes them to be overly chatty, it may be a symptom that these functions belong in the same service.</span></span>
- <span data-ttu-id="37928-134">每個服務都夠小，以便可由小型小組獨立工作來加以建置。</span><span class="sxs-lookup"><span data-stu-id="37928-134">Each service is small enough that it can be built by a small team working independently.</span></span>
- <span data-ttu-id="37928-135">沒有交互相依性，因此不必將兩個以上的服務一起部署。</span><span class="sxs-lookup"><span data-stu-id="37928-135">There are no inter-dependencies that will require two or more services to be deployed in lock-step.</span></span> <span data-ttu-id="37928-136">在部署某項服務時，應該要永遠不必重新部署任何其他服務。</span><span class="sxs-lookup"><span data-stu-id="37928-136">It should always be possible to deploy a service without redeploying any other services.</span></span>
- <span data-ttu-id="37928-137">服務未緊密結合，並且可以獨立進化。</span><span class="sxs-lookup"><span data-stu-id="37928-137">Services are not tightly coupled, and can evolve independently.</span></span>
- <span data-ttu-id="37928-138">您的服務界限不會產生資料一致性或完整性的問題。</span><span class="sxs-lookup"><span data-stu-id="37928-138">Your service boundaries will not create problems with data consistency or integrity.</span></span> <span data-ttu-id="37928-139">有時候您必須透過將功能放入單一微服務中，以保持資料一致性。</span><span class="sxs-lookup"><span data-stu-id="37928-139">Sometimes it's important to maintain data consistency by putting functionality into a single microservice.</span></span> <span data-ttu-id="37928-140">話雖如此，請考慮您是否真的需要強式一致性。</span><span class="sxs-lookup"><span data-stu-id="37928-140">That said, consider whether you really need strong consistency.</span></span> <span data-ttu-id="37928-141">您可以找到策略來解決分散式系統的最終一致性問題，而且拆解服務所能帶來的好處，通常會勝過管理最終一致性所帶來的麻煩。</span><span class="sxs-lookup"><span data-stu-id="37928-141">There are strategies for addressing eventual consistency in a distributed system, and the benefits of decomposing services often outweigh the challenges of managing eventual consistency.</span></span>

<span data-ttu-id="37928-142">最重要的是，務必要務實，並請記得領域導向的設計是反覆不斷的程序。</span><span class="sxs-lookup"><span data-stu-id="37928-142">Above all, it's important to be pragmatic, and remember that domain-driven design is an iterative process.</span></span> <span data-ttu-id="37928-143">當您猶豫不定時，請從更粗略的微服務來開始著手。</span><span class="sxs-lookup"><span data-stu-id="37928-143">When in doubt, start with more coarse-grained microservices.</span></span> <span data-ttu-id="37928-144">將微服務分割成兩個較小的服務，會比重構數個現有微服務的功能來得簡單。</span><span class="sxs-lookup"><span data-stu-id="37928-144">Splitting a microservice into two smaller services is easier than refactoring functionality across several existing microservices.</span></span>
  
## <a name="drone-delivery-defining-the-microservices"></a><span data-ttu-id="37928-145">無人機遞送：定義微服務</span><span class="sxs-lookup"><span data-stu-id="37928-145">Drone Delivery: Defining the microservices</span></span>

<span data-ttu-id="37928-146">請回想一下，開發小組已經識別出四個彙總 (分別是「遞送」、「包裹」、「無人機」和「帳戶」) 以及兩個領域服務 (分別是「排程器」和「監督員」)。</span><span class="sxs-lookup"><span data-stu-id="37928-146">Recall that the development team had identified the four aggregates &mdash; Delivery, Package, Drone, and Account &mdash; and two domain services, Scheduler and Supervisor.</span></span> 

<span data-ttu-id="37928-147">遞送與包裹很明顯可作為微服務。</span><span class="sxs-lookup"><span data-stu-id="37928-147">Delivery and Package are obvious candidates for microservices.</span></span> <span data-ttu-id="37928-148">排程器和監督員會協調其他微服務所執行的活動，因此也應該將這些領域服務當做微服務來實作。</span><span class="sxs-lookup"><span data-stu-id="37928-148">The Scheduler and Supervisor coordinate the activities performed by other microservices, so it makes sense to implement these domain services as microservices.</span></span>  

<span data-ttu-id="37928-149">無人機和帳戶則很有趣，因為這兩者屬於其他限界內容。</span><span class="sxs-lookup"><span data-stu-id="37928-149">Drone and Account are interesting because they belong to other bounded contexts.</span></span> <span data-ttu-id="37928-150">其中一個選項是讓排程器直接呼叫無人機和帳戶限界內容。</span><span class="sxs-lookup"><span data-stu-id="37928-150">One option is for the Scheduler to call the Drone and Account bounded contexts directly.</span></span> <span data-ttu-id="37928-151">另一個選項則是在出貨限界內容中建立無人機和帳戶微服務。</span><span class="sxs-lookup"><span data-stu-id="37928-151">Another option is to create Drone and Account microservices inside the Shipping bounded context.</span></span> <span data-ttu-id="37928-152">這些微服務會居中協調限界內容，方法是藉由將更適合出貨內容的 API 或資料結構描述予以公開。</span><span class="sxs-lookup"><span data-stu-id="37928-152">These microservices would mediate between the bounded contexts, by exposing APIs or data schemas that are more suited to the Shipping context.</span></span>

<span data-ttu-id="37928-153">無人機和帳戶限界內容的詳細資料不再本指南的說明範圍內，因此我們在參考實作中為其建立了模擬服務。</span><span class="sxs-lookup"><span data-stu-id="37928-153">The details of the Drone and Account bounded contexts are beyond the scope of this guidance, so we created mock services for them in our reference implementation.</span></span> <span data-ttu-id="37928-154">但在此情況下，需要考量以下因素：</span><span class="sxs-lookup"><span data-stu-id="37928-154">But here are some factors to consider in this situation:</span></span>

- <span data-ttu-id="37928-155">直接呼叫到另一個限界內容會有何網路負荷？</span><span class="sxs-lookup"><span data-stu-id="37928-155">What is the network overhead of calling directly into the other bounded context?</span></span> 

- <span data-ttu-id="37928-156">其他限界內容的資料結構描述是否適用於此內容，或是為此限界內容專門打造一個結構描述會更好？</span><span class="sxs-lookup"><span data-stu-id="37928-156">Is the data schema for the other bounded context suitable for this context, or is it better to have a schema that's tailored to this bounded context?</span></span> 

- <span data-ttu-id="37928-157">其他限界內容是否為繼承系統？</span><span class="sxs-lookup"><span data-stu-id="37928-157">Is the other bounded context a legacy system?</span></span> <span data-ttu-id="37928-158">如果是，您可能要建立一項服務來作為[防損毀層](../patterns/anti-corruption-layer.md)，以在繼承系統和新型應用程式之間進行轉換。</span><span class="sxs-lookup"><span data-stu-id="37928-158">If so, you might create a service that acts as an [anti-corruption layer](../patterns/anti-corruption-layer.md) to translate between the legacy system and the modern application.</span></span> 

- <span data-ttu-id="37928-159">小組結構為何？</span><span class="sxs-lookup"><span data-stu-id="37928-159">What is the team structure?</span></span> <span data-ttu-id="37928-160">是否能輕易地與負責其他限界內容的小組進行溝通？</span><span class="sxs-lookup"><span data-stu-id="37928-160">Is it easy to communicate with the team that's responsible for the other bounded context?</span></span> <span data-ttu-id="37928-161">如果不行，則建立可居中協調兩個內容的服務會有助於減輕跨小組溝通的成本。</span><span class="sxs-lookup"><span data-stu-id="37928-161">If not, creating a service that mediates between the two contexts can help to mitigate the cost of cross-team communication.</span></span>

<span data-ttu-id="37928-162">到目前為止，我們還未考慮過任何非功能性需求。</span><span class="sxs-lookup"><span data-stu-id="37928-162">So far, we haven't considered any non-functional requirements.</span></span> <span data-ttu-id="37928-163">開發小組考慮到應用程式的輸送量需求，決定要建立個別的擷取微服務，來負責擷取用戶端要求。</span><span class="sxs-lookup"><span data-stu-id="37928-163">Thinking about the application's throughput requirements, the development team decided to create a separate Ingestion microservice that is responsible for ingesting client requests.</span></span> <span data-ttu-id="37928-164">此微服務會藉由將內送要求放入緩衝區進行處理，來實作[負載調節](../patterns/queue-based-load-leveling.md)。</span><span class="sxs-lookup"><span data-stu-id="37928-164">This microservice will implement [load leveling](../patterns/queue-based-load-leveling.md) by putting incoming requests into a buffer for processing.</span></span> <span data-ttu-id="37928-165">排程器會從緩衝區讀取要求，並執行工作流程。</span><span class="sxs-lookup"><span data-stu-id="37928-165">The Scheduler will read the requests from the buffer and execute the workflow.</span></span> 

<span data-ttu-id="37928-166">非功能性需求導致開發小組額外建立了一項服務。</span><span class="sxs-lookup"><span data-stu-id="37928-166">Non-functional requirements led the team to create one additional service.</span></span> <span data-ttu-id="37928-167">到目前為止的所有服務皆與即時排程和遞送包裹的程序有關。</span><span class="sxs-lookup"><span data-stu-id="37928-167">All of the services so far have been about the process of scheduling and delivering packages in real time.</span></span> <span data-ttu-id="37928-168">但是，系統還必須將每一次遞送的記錄儲存在長期儲存體中，以便進行資料分析。</span><span class="sxs-lookup"><span data-stu-id="37928-168">But the system also needs to store the history of every delivery in long-term storage for data analysis.</span></span> <span data-ttu-id="37928-169">開發小組考慮由遞送服務負責這項工作。</span><span class="sxs-lookup"><span data-stu-id="37928-169">The team considered making this the responsibility of the Delivery service.</span></span> <span data-ttu-id="37928-170">不過，歷史分析作業和進行中之作業的資料儲存需求大不相同 (請參閱[資料考量](./data-considerations.md))。</span><span class="sxs-lookup"><span data-stu-id="37928-170">However, the data storage requirements are quite different for historical analysis versus in-flight operations (see [Data considerations](./data-considerations.md)).</span></span> <span data-ttu-id="37928-171">因此，該小組決定另外建立一個遞送記錄服務，由其接聽遞送服務的 DeliveryTracking 事件，並將這些事件寫入長期儲存體中。</span><span class="sxs-lookup"><span data-stu-id="37928-171">Therefore, the team decided to create a separate Delivery History service, which will listen for DeliveryTracking events from the Delivery service and write the events into long-term storage.</span></span>

<span data-ttu-id="37928-172">下圖顯示到目前為止的設計：</span><span class="sxs-lookup"><span data-stu-id="37928-172">The following diagram shows the design at this point:</span></span>
 
![](./images/microservices.png)

## <a name="choosing-a-compute-option"></a><span data-ttu-id="37928-173">選擇計算選項</span><span class="sxs-lookup"><span data-stu-id="37928-173">Choosing a compute option</span></span>

<span data-ttu-id="37928-174">*計算*一詞是指您的應用程式執行所在運算資源的裝載模型。</span><span class="sxs-lookup"><span data-stu-id="37928-174">The term *compute* refers to the hosting model for the computing resources that your application runs on.</span></span> <span data-ttu-id="37928-175">應用在微服務架構方面，有兩種非常熱門的方法：</span><span class="sxs-lookup"><span data-stu-id="37928-175">For a microservices architecture, two approaches are especially popular:</span></span>

- <span data-ttu-id="37928-176">服務協調器，可管理專用節點 (VM) 上所執行的服務。</span><span class="sxs-lookup"><span data-stu-id="37928-176">A service orchestrator that manages services running on dedicated nodes (VMs).</span></span>
- <span data-ttu-id="37928-177">使用「函式即服務」(FaaS) 的無伺服器架構。</span><span class="sxs-lookup"><span data-stu-id="37928-177">A serverless architecture using functions as a service (FaaS).</span></span> 

<span data-ttu-id="37928-178">雖然這兩種方法並不是唯一的選項，卻是已獲證實可行的微服務建置方法。</span><span class="sxs-lookup"><span data-stu-id="37928-178">While these aren't the only options, they are both proven approaches to building microservices.</span></span> <span data-ttu-id="37928-179">應用程式可同時包含這兩種方法。</span><span class="sxs-lookup"><span data-stu-id="37928-179">An application might include both approaches.</span></span>

### <a name="service-orchestrators"></a><span data-ttu-id="37928-180">服務協調器</span><span class="sxs-lookup"><span data-stu-id="37928-180">Service orchestrators</span></span>

<span data-ttu-id="37928-181">協調器負責處理與一組服務的部署及管理有關的工作。</span><span class="sxs-lookup"><span data-stu-id="37928-181">An orchestrator handles tasks related to deploying and managing a set of services.</span></span> <span data-ttu-id="37928-182">這些工作包括在節點上放置服務、監視服務的健康情況、重新啟動狀況不良的服務、在服務執行個體間負載平衡網路流量、服務探索、調整服務執行個體數目，以及套用組態更新。</span><span class="sxs-lookup"><span data-stu-id="37928-182">These tasks include placing services on nodes, monitoring the health of services, restarting unhealthy services, load balancing network traffic across service instances, service discovery, scaling the number of instances of a service, and applying configuration updates.</span></span> <span data-ttu-id="37928-183">熱門協調器包括 Kubernetes、DC/OS、Docker Swarm 和 Service Fabric。</span><span class="sxs-lookup"><span data-stu-id="37928-183">Popular orchestrators include Kubernetes, DC/OS, Docker Swarm, and Service Fabric.</span></span> 

- <span data-ttu-id="37928-184">[Azure Container Service](/azure/container-service/) (ACS) 這個 Azure 服務可讓您部署立即可以從事生產的 Kubernetes、DC/OS 或 Docker Swarm 叢集。</span><span class="sxs-lookup"><span data-stu-id="37928-184">[Azure Container Service](/azure/container-service/) (ACS) is an Azure service that lets you deploy a production-ready Kubernetes, DC/OS, or Docker Swarm cluster.</span></span>

- <span data-ttu-id="37928-185">[AKS (Azure Container Service)](/azure/aks/) 是受控的 Kubernetes 服務。</span><span class="sxs-lookup"><span data-stu-id="37928-185">[AKS (Azure Container Service)](/azure/aks/) is a managed Kubernetes service.</span></span> <span data-ttu-id="37928-186">AKS 會佈建 Kubernetes 並公開 Kubernetes API 端點，但會裝載和管理 Kubernetes 控制平面，以便執行自動升級、自動修補、自動調整和其他管理工作。</span><span class="sxs-lookup"><span data-stu-id="37928-186">AKS provisions Kubernetes and exposes the Kubernetes API endpoints, but hosts and manages the Kubernetes control plane, performing automated upgrades, automated patching, autoscaling, and other management tasks.</span></span> <span data-ttu-id="37928-187">您可以將 AKS 視為「Kubernetes API 即服務」。</span><span class="sxs-lookup"><span data-stu-id="37928-187">You can think of AKS as being "Kubernetes APIs as a service."</span></span> <span data-ttu-id="37928-188">在本文撰寫當下，AKS 仍屬預覽版。</span><span class="sxs-lookup"><span data-stu-id="37928-188">At the time of writing, AKS is still in preview.</span></span> <span data-ttu-id="37928-189">然而，我們預期 AKS 將會成為在 Azure 中執行 Kubernetes 的慣用方法。</span><span class="sxs-lookup"><span data-stu-id="37928-189">However, it's expected that AKS will become the preferred way to run Kubernetes in Azure.</span></span> 

- <span data-ttu-id="37928-190">[Service Fabric](/azure/service-fabric/) 是一個分散式系統平台，可讓您封裝、部署及管理微服務。</span><span class="sxs-lookup"><span data-stu-id="37928-190">[Service Fabric](/azure/service-fabric/) is a distributed systems platform for packaging, deploying, and managing microservices.</span></span> <span data-ttu-id="37928-191">您可以將微服務部署至 Service Fabric，以作為容器、二進位可執行檔或作為 [Reliable Services](/azure/service-fabric/service-fabric-reliable-services-introduction)。</span><span class="sxs-lookup"><span data-stu-id="37928-191">Microservices can be deployed to Service Fabric as containers, as binary executables, or as [Reliable Services](/azure/service-fabric/service-fabric-reliable-services-introduction).</span></span> <span data-ttu-id="37928-192">使用 Reliable Services 程式設計模型，服務便可直接使用 Service Fabric 程式設計 API 來查詢系統、回報健康情況、接收有關組態和程式碼變更的通知，並探索其他服務。</span><span class="sxs-lookup"><span data-stu-id="37928-192">Using the Reliable Services programming model, services can directly use Service Fabric programming APIs to query the system, report health, receive notifications about configuration and code changes, and discover other services.</span></span> <span data-ttu-id="37928-193">與 Service Fabric 的主要差異在於，其非常著重在使用 [Reliable Collections](/azure/service-fabric/service-fabric-reliable-services-reliable-collections) 來建置具狀態服務。</span><span class="sxs-lookup"><span data-stu-id="37928-193">A key differentiation with Service Fabric is its strong focus on building stateful services using [Reliable Collections](/azure/service-fabric/service-fabric-reliable-services-reliable-collections).</span></span>

### <a name="containers"></a><span data-ttu-id="37928-194">容器</span><span class="sxs-lookup"><span data-stu-id="37928-194">Containers</span></span>

<span data-ttu-id="37928-195">有時候人們會將容器和微服務看作是一樣的東西。</span><span class="sxs-lookup"><span data-stu-id="37928-195">Sometimes people talk about containers and microservices as if they were the same thing.</span></span> <span data-ttu-id="37928-196">雖然事實並非如此 (不需要容器就能建置微服務)，但容器的確具有和微服務極其相關的一些優點，例如：</span><span class="sxs-lookup"><span data-stu-id="37928-196">While that's not true &mdash; you don't need containers to build microservices &mdash; containers do have some benefits that are particularly relevant to microservices, such as:</span></span>

- <span data-ttu-id="37928-197">**可攜性**。</span><span class="sxs-lookup"><span data-stu-id="37928-197">**Portability**.</span></span> <span data-ttu-id="37928-198">容器映像是不需要安裝程式庫或其他相依性就能執行的獨立套件。</span><span class="sxs-lookup"><span data-stu-id="37928-198">A container image is a standalone package that runs without needing to install libraries or other dependencies.</span></span> <span data-ttu-id="37928-199">這項特性使其部署作業變得簡單。</span><span class="sxs-lookup"><span data-stu-id="37928-199">That makes them easy to deploy.</span></span> <span data-ttu-id="37928-200">容器可以快速加以啟動和停止，因此您可以啟動新的執行個體，以處理更多負載或是從節點失敗中復原。</span><span class="sxs-lookup"><span data-stu-id="37928-200">Containers can be started and stopped quickly, so you can spin up new instances to handle more load or to recover from node failures.</span></span> 

- <span data-ttu-id="37928-201">**密度**.</span><span class="sxs-lookup"><span data-stu-id="37928-201">**Density**.</span></span> <span data-ttu-id="37928-202">相較於執行虛擬機器，容器因為會共用作業系統資源，因此所需資源不多。</span><span class="sxs-lookup"><span data-stu-id="37928-202">Containers are lightweight compared with running a virtual machine, because they share OS resources.</span></span> <span data-ttu-id="37928-203">這項特性讓我們可以將多個容器封裝至單一節點，而這個能力在應用程式包含許多小型服務時會特別有用。</span><span class="sxs-lookup"><span data-stu-id="37928-203">That makes it possible to pack multiple containers onto a single node, which is especially useful when the application consists of many small services.</span></span>

- <span data-ttu-id="37928-204">**資源隔離**.</span><span class="sxs-lookup"><span data-stu-id="37928-204">**Resource isolation**.</span></span> <span data-ttu-id="37928-205">您可以限制容器可以使用的記憶體和 CPU 數量，這可協助確保失控程序不會耗盡主機資源。</span><span class="sxs-lookup"><span data-stu-id="37928-205">You can limit the amount of memory and CPU that is available to a container, which can help to ensure that a runaway process doesn't exhaust the host resources.</span></span> <span data-ttu-id="37928-206">如需詳細資訊，請參閱[隔艙模式](../patterns/bulkhead.md)。</span><span class="sxs-lookup"><span data-stu-id="37928-206">See the [Bulkhead Pattern](../patterns/bulkhead.md) for more information.</span></span>

### <a name="serverless-functions-as-a-service"></a><span data-ttu-id="37928-207">無伺服器 (函式即服務)</span><span class="sxs-lookup"><span data-stu-id="37928-207">Serverless (Functions as a Service)</span></span>

<span data-ttu-id="37928-208">使用無伺服器架構時，您就不會管理 VM 或虛擬網路基礎結構。</span><span class="sxs-lookup"><span data-stu-id="37928-208">With a serverless architecture, you don't manage the VMs or the virtual network infrastructure.</span></span> <span data-ttu-id="37928-209">相反地，您會部署程式碼，而主機服務則負責將該程式碼放到 VM 並加以執行。</span><span class="sxs-lookup"><span data-stu-id="37928-209">Instead, you deploy code and the hosting service handles putting that code onto a VM and executing it.</span></span> <span data-ttu-id="37928-210">這種方法往往會偏好使用以事件型觸發程序來進行協調的小型函式。</span><span class="sxs-lookup"><span data-stu-id="37928-210">This approach tends to favor small granular functions that are coordinated using event-based triggers.</span></span> <span data-ttu-id="37928-211">例如，放到佇列的訊息可能會觸發函式，以讀取佇列並處理訊息。</span><span class="sxs-lookup"><span data-stu-id="37928-211">For example, a message being placed onto a queue might trigger a function that reads from the queue and processes the message.</span></span>

<span data-ttu-id="37928-212">[Azure Functions][functions] 是無伺服器的計算服務，可支援各種函式觸發程序，包括 HTTP 要求、服務匯流排佇列和事件中樞事件。</span><span class="sxs-lookup"><span data-stu-id="37928-212">[Azure Functions][functions] is a serverless compute service that supports various function triggers, including HTTP requests, Service Bus queues, and Event Hubs events.</span></span> <span data-ttu-id="37928-213">如需完整清單，請參閱 [Azure Functions 觸發程序和繫結概念][functions-triggers]。</span><span class="sxs-lookup"><span data-stu-id="37928-213">For a complete list, see [Azure Functions triggers and bindings concepts][functions-triggers].</span></span> <span data-ttu-id="37928-214">也請考慮 [Azure Event Grid][event-grid]，這是 Azure 中的受控事件路由服務。</span><span class="sxs-lookup"><span data-stu-id="37928-214">Also consider [Azure Event Grid][event-grid], which is a managed event routing service in Azure.</span></span>

### <a name="orchestrator-or-serverless"></a><span data-ttu-id="37928-215">該選擇協調器還是無伺服器？</span><span class="sxs-lookup"><span data-stu-id="37928-215">Orchestrator or serverless?</span></span>

<span data-ttu-id="37928-216">以下是在協調器方法與無伺服器方法之間做選擇時所要考慮的部分因素。</span><span class="sxs-lookup"><span data-stu-id="37928-216">Here are some factors to consider when choosing between an orchestrator approach and a serverless approach.</span></span>

<span data-ttu-id="37928-217">**管理性**。無伺服器應用程式管理容易，因為該平台會為您管理所有的計算資源。</span><span class="sxs-lookup"><span data-stu-id="37928-217">**Manageability** A serverless application is easy to manage, because the platform manages all the of compute resources for you.</span></span> <span data-ttu-id="37928-218">雖然協調器會抽走某些叢集管理和設定工作，但它不會完全掩蓋掉基礎 VM。</span><span class="sxs-lookup"><span data-stu-id="37928-218">While an orchestrator abstracts some aspects of managing and configuring a cluster, it does not completely hide the underlying VMs.</span></span> <span data-ttu-id="37928-219">使用協調器時，您必須考慮到負載平衡、CPU、記憶體使用量和網路等問題。</span><span class="sxs-lookup"><span data-stu-id="37928-219">With an orchestrator, you will need to think about issues such as load balancing, CPU and memory usage, and networking.</span></span>

<span data-ttu-id="37928-220">**彈性和控制**。</span><span class="sxs-lookup"><span data-stu-id="37928-220">**Flexibility and control**.</span></span> <span data-ttu-id="37928-221">協調器可讓您極大程度地控制服務和叢集的設定及管理功能。</span><span class="sxs-lookup"><span data-stu-id="37928-221">An orchestrator gives you a great deal of control over configuring and managing your services and the cluster.</span></span> <span data-ttu-id="37928-222">代價是複雜性會提高。</span><span class="sxs-lookup"><span data-stu-id="37928-222">The tradeoff is additional complexity.</span></span> <span data-ttu-id="37928-223">若使用無伺服器架構，您則要放棄某種程度的控制能力，因為這些詳細資料會被抽離。</span><span class="sxs-lookup"><span data-stu-id="37928-223">With a serverless architecture, you give up some degree of control because these details are abstracted.</span></span>

<span data-ttu-id="37928-224">**可攜性**。</span><span class="sxs-lookup"><span data-stu-id="37928-224">**Portability**.</span></span> <span data-ttu-id="37928-225">此處所列的所有協調器 (Kubernetes、DC/OS、Docker Swarm 和 Service Fabric) 可在內部部署環境執行，也可以在多個公用雲端中執行。</span><span class="sxs-lookup"><span data-stu-id="37928-225">All of the orchestrators listed here (Kubernetes, DC/OS, Docker Swarm, and Service Fabric) can run on-premises or in multiple public clouds.</span></span> 

<span data-ttu-id="37928-226">**應用程式整合**.</span><span class="sxs-lookup"><span data-stu-id="37928-226">**Application integration**.</span></span> <span data-ttu-id="37928-227">使用無伺服器架構來建置複雜的應用程式並不是件容易的事。</span><span class="sxs-lookup"><span data-stu-id="37928-227">It can be challenging to build a complex application using a serverless architecture.</span></span> <span data-ttu-id="37928-228">在 Azure 中進行此作業的其中一個方法是使用 [Azure Logic Apps](/azure/logic-apps/) 來協調一組 Azure Functions。</span><span class="sxs-lookup"><span data-stu-id="37928-228">One option in Azure is to use [Azure Logic Apps](/azure/logic-apps/) to coordinate a set of Azure Functions.</span></span> <span data-ttu-id="37928-229">如需此方法的範例，請參閱[建立與 Azure Logic Apps 整合的函式](/azure/azure-functions/functions-twitter-email)。</span><span class="sxs-lookup"><span data-stu-id="37928-229">For an example of this approach, see [Create a function that integrates with Azure Logic Apps](/azure/azure-functions/functions-twitter-email).</span></span>

<span data-ttu-id="37928-230">**成本**。</span><span class="sxs-lookup"><span data-stu-id="37928-230">**Cost**.</span></span> <span data-ttu-id="37928-231">使用協調器時，您需要為叢集中正在執行的 VM 支付費用。</span><span class="sxs-lookup"><span data-stu-id="37928-231">With an orchestrator, you pay for the VMs that are running in the cluster.</span></span> <span data-ttu-id="37928-232">使用無伺服器應用程式時，則只需為實際耗用的計算資源支付費用。</span><span class="sxs-lookup"><span data-stu-id="37928-232">With a serverless application, you pay only for the actual compute resources consumed.</span></span> <span data-ttu-id="37928-233">在這兩種情況中，您都需要考量任何其他服務 (例如，儲存體、資料庫和傳訊服務) 的成本。</span><span class="sxs-lookup"><span data-stu-id="37928-233">In both cases, you need to factor in the cost of any additional services, such as storage, databases, and messaging services.</span></span>

<span data-ttu-id="37928-234">**延展性**。</span><span class="sxs-lookup"><span data-stu-id="37928-234">**Scalability**.</span></span> <span data-ttu-id="37928-235">Azure Functions 會根據內送事件數量自動進行調整，以符合需求。</span><span class="sxs-lookup"><span data-stu-id="37928-235">Azure Functions scales automatically to meet demand, based on the number of incoming events.</span></span> <span data-ttu-id="37928-236">使用協調器時，您可以透過增加叢集中執行的服務執行個體數目，來進行相應放大。</span><span class="sxs-lookup"><span data-stu-id="37928-236">With an orchestrator, you can scale out by increasing the number of service instances running in the cluster.</span></span> <span data-ttu-id="37928-237">您也可以透過對叢集新增額外的 VM 來進行調整。</span><span class="sxs-lookup"><span data-stu-id="37928-237">You can also scale by adding additional VMs to the cluster.</span></span>

<span data-ttu-id="37928-238">我們的參考實作主要是使用 Kubernetes，但我們也的確有對某項服務 (也就是遞送記錄服務) 使用 Azure Functions。</span><span class="sxs-lookup"><span data-stu-id="37928-238">Our reference implementation primarily uses Kubernetes, but we did use Azure Functions for one service, namely the Delivery History service.</span></span> <span data-ttu-id="37928-239">Azure Functions 非常適合用於此特定服務，因為它是事件驅動的工作負載。</span><span class="sxs-lookup"><span data-stu-id="37928-239">Azure Functions was a good fit for this particular service, because it's is an event-driven workload.</span></span> <span data-ttu-id="37928-240">藉由使用事件中樞觸發程序來叫用函式，服務所需的程式碼數量已降至最低。</span><span class="sxs-lookup"><span data-stu-id="37928-240">By using an Event Hubs trigger to invoke the function, the service needed a minimal amount of code.</span></span> <span data-ttu-id="37928-241">此外，遞送記錄服務並非主要工作流程的一部分，因此在 Kubernetes 叢集之外執行此服務並不會影響使用者所起始之作業的端對端延遲。</span><span class="sxs-lookup"><span data-stu-id="37928-241">Also, the Delivery History service is not part of the main workflow, so running it outside of the Kubernetes cluster doesn't affect the end-to-end latency of user-initiated operations.</span></span> 

> [!div class="nextstepaction"]
> [<span data-ttu-id="37928-242">資料考量</span><span class="sxs-lookup"><span data-stu-id="37928-242">Data considerations</span></span>](./data-considerations.md)

<!-- links -->

[acs-engine]: https://github.com/Azure/acs-engine
[acs-faq]: /azure/container-service/dcos-swarm/container-service-faq
[event-grid]: /azure/event-grid/
[functions]: /azure/azure-functions/functions-overview
[functions-triggers]: /azure/azure-functions/functions-triggers-bindings
