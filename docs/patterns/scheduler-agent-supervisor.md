---
title: 排程器代理程式監督員模式
titleSuffix: Cloud Design Patterns
description: 在一組分散式服務和其他遠端資源中協調一組動作。
keywords: 設計模式
author: dragon119
ms.date: 06/23/2017
ms.topic: design-pattern
ms.service: architecture-center
ms.subservice: cloud-fundamentals
ms.custom: seodec18
ms.openlocfilehash: bf432444587216d7f635b0a5f26fed9223e85c44
ms.sourcegitcommit: 1b50810208354577b00e89e5c031b774b02736e2
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/23/2019
ms.locfileid: "54482046"
---
# <a name="scheduler-agent-supervisor-pattern"></a><span data-ttu-id="46cbb-104">排程器代理程式監督員模式</span><span class="sxs-lookup"><span data-stu-id="46cbb-104">Scheduler Agent Supervisor pattern</span></span>

[!INCLUDE [header](../_includes/header.md)]

<span data-ttu-id="46cbb-105">協調一組分散式動作來作為單一作業。</span><span class="sxs-lookup"><span data-stu-id="46cbb-105">Coordinate a set of distributed actions as a single operation.</span></span> <span data-ttu-id="46cbb-106">如果任何一項動作失敗，可嘗試以透明的方式處理失敗，或也可以復原已執行的工作，這樣整個作業就會整體成功或失敗。</span><span class="sxs-lookup"><span data-stu-id="46cbb-106">If any of the actions fail, try to handle the failures transparently, or else undo the work that was performed, so the entire operation succeeds or fails as a whole.</span></span> <span data-ttu-id="46cbb-107">這可將復原加入分散式系統，方法是讓它復原及重試因暫時性例外狀況、持久性錯誤及程序失敗而失敗的動作。</span><span class="sxs-lookup"><span data-stu-id="46cbb-107">This can add resiliency to a distributed system, by enabling it to recover and retry actions that fail due to transient exceptions, long-lasting faults, and process failures.</span></span>

## <a name="context-and-problem"></a><span data-ttu-id="46cbb-108">內容和問題</span><span class="sxs-lookup"><span data-stu-id="46cbb-108">Context and problem</span></span>

<span data-ttu-id="46cbb-109">應用程式會執行包含數個步驟 (其中有些可能會叫用遠端服務或存取遠端資源) 的工作。</span><span class="sxs-lookup"><span data-stu-id="46cbb-109">An application performs tasks that include a number of steps, some of which might invoke remote services or access remote resources.</span></span> <span data-ttu-id="46cbb-110">個別的步驟可能會彼此獨立，但是它們會由實作工作的應用程式邏輯進行協調。</span><span class="sxs-lookup"><span data-stu-id="46cbb-110">The individual steps might be independent of each other, but they are orchestrated by the application logic that implements the task.</span></span>

<span data-ttu-id="46cbb-111">可能的話，應用程式應該確定工作會執行到完成，並解決存取遠端服務或資源時可能會發生的任何失敗。</span><span class="sxs-lookup"><span data-stu-id="46cbb-111">Whenever possible, the application should ensure that the task runs to completion and resolve any failures that might occur when accessing remote services or resources.</span></span> <span data-ttu-id="46cbb-112">失敗可能會因許多原因發生。</span><span class="sxs-lookup"><span data-stu-id="46cbb-112">Failures can occur for many reasons.</span></span> <span data-ttu-id="46cbb-113">例如，網路可能會關閉、通訊可能會中斷、遠端服務可能沒有回應或處於不穩定的狀態，或是遠端資源可能會暫時無法存取，可能是由於資源條件約束。</span><span class="sxs-lookup"><span data-stu-id="46cbb-113">For example, the network might be down, communications could be interrupted, a remote service might be unresponsive or in an unstable state, or a remote resource might be temporarily inaccessible, perhaps due to resource constraints.</span></span> <span data-ttu-id="46cbb-114">在許多情況下，失敗會是暫時性的，並且可以使用[重試模式](./retry.md)來處理。</span><span class="sxs-lookup"><span data-stu-id="46cbb-114">In many cases the failures will be transient and can be handled by using the [Retry pattern](./retry.md).</span></span>

<span data-ttu-id="46cbb-115">如果應用程式偵測到它無法輕鬆地復原的更永久性錯誤，就必須能夠將系統還原到一致的狀態，並確定整個作業的完整性。</span><span class="sxs-lookup"><span data-stu-id="46cbb-115">If the application detects a more permanent fault it can't easily recover from, it must be able to restore the system to a consistent state and ensure integrity of the entire operation.</span></span>

## <a name="solution"></a><span data-ttu-id="46cbb-116">解決方法</span><span class="sxs-lookup"><span data-stu-id="46cbb-116">Solution</span></span>

<span data-ttu-id="46cbb-117">排程器代理程式監督員模式會定義下列執行者。</span><span class="sxs-lookup"><span data-stu-id="46cbb-117">The Scheduler Agent Supervisor pattern defines the following actors.</span></span> <span data-ttu-id="46cbb-118">這些執行者會將步驟協調為以整體工作的一部分來執行。</span><span class="sxs-lookup"><span data-stu-id="46cbb-118">These actors orchestrate the steps to be performed as part of the overall task.</span></span>

- <span data-ttu-id="46cbb-119">**排程器**會針對組成要執行的工作步驟進行排列，並會協調其作業。</span><span class="sxs-lookup"><span data-stu-id="46cbb-119">The **Scheduler** arranges for the steps that make up the task to be executed and orchestrates their operation.</span></span> <span data-ttu-id="46cbb-120">這些步驟可以結合成管線或工作流程。</span><span class="sxs-lookup"><span data-stu-id="46cbb-120">These steps can be combined into a pipeline or workflow.</span></span> <span data-ttu-id="46cbb-121">排程器會負責確保此工作流程中的步驟是以正確的順序執行。</span><span class="sxs-lookup"><span data-stu-id="46cbb-121">The Scheduler is responsible for ensuring that the steps in this workflow are performed in the right order.</span></span> <span data-ttu-id="46cbb-122">執行每個步驟時，排程器會記錄工作流程的狀態，例如「步驟尚未開始」、「步驟執行中」或「逐步完成」。</span><span class="sxs-lookup"><span data-stu-id="46cbb-122">As each step is performed, the Scheduler records the state of the workflow, such as "step not yet started," "step running," or "step completed."</span></span> <span data-ttu-id="46cbb-123">狀態資訊也應包含步驟完成所允許的時間上限，稱為完成期限時間。</span><span class="sxs-lookup"><span data-stu-id="46cbb-123">The state information should also include an upper limit of the time allowed for the step to finish, called the complete-by time.</span></span> <span data-ttu-id="46cbb-124">如果步驟需要存取遠端服務或資源，排程器會叫用適當的代理程式，並將需執行工作的詳細資料傳遞給它。</span><span class="sxs-lookup"><span data-stu-id="46cbb-124">If a step requires access to a remote service or resource, the Scheduler invokes the appropriate Agent, passing it the details of the work to be performed.</span></span> <span data-ttu-id="46cbb-125">排程器通常會使用非同步要求/回應傳訊來與代理程式通訊。</span><span class="sxs-lookup"><span data-stu-id="46cbb-125">The Scheduler typically communicates with an Agent using asynchronous request/response messaging.</span></span> <span data-ttu-id="46cbb-126">這可以使用佇列進行實作，雖然也可以改為使用其他分散式傳訊技術。</span><span class="sxs-lookup"><span data-stu-id="46cbb-126">This can be implemented using queues, although other distributed messaging technologies could be used instead.</span></span>

    > <span data-ttu-id="46cbb-127">排程器會在[程序管理員模式](https://www.enterpriseintegrationpatterns.com/patterns/messaging/ProcessManager.html)中，對程序管理員執行類似的函式。</span><span class="sxs-lookup"><span data-stu-id="46cbb-127">The Scheduler performs a similar function to the Process Manager in the [Process Manager pattern](https://www.enterpriseintegrationpatterns.com/patterns/messaging/ProcessManager.html).</span></span> <span data-ttu-id="46cbb-128">實際工作流程通常是由排程器控制的工作流程引擎所定義及實作。</span><span class="sxs-lookup"><span data-stu-id="46cbb-128">The actual workflow is typically defined and implemented by a workflow engine that's controlled by the Scheduler.</span></span> <span data-ttu-id="46cbb-129">這種方法，會從排程器減少工作流程中的商務邏輯。</span><span class="sxs-lookup"><span data-stu-id="46cbb-129">This approach decouples the business logic in the workflow from the Scheduler.</span></span>

- <span data-ttu-id="46cbb-130">**代理程式**包含的邏輯會封裝呼叫遠端服務，或存取工作中步驟所參考的遠端資源。</span><span class="sxs-lookup"><span data-stu-id="46cbb-130">The **Agent** contains logic that encapsulates a call to a remote service, or access to a remote resource referenced by a step in a task.</span></span> <span data-ttu-id="46cbb-131">每個代理程式通常會包裝對單一服務或資源的呼叫，從而實作適當的錯誤處理和重試邏輯 (受限於稍後所述的逾時條件約束)。</span><span class="sxs-lookup"><span data-stu-id="46cbb-131">Each Agent typically wraps calls to a single service or resource, implementing the appropriate error handling and retry logic (subject to a timeout constraint, described later).</span></span> <span data-ttu-id="46cbb-132">如果排程器所執行之工作流程中的步驟跨不同步驟使用數個服務和資源，，每個步驟可能會參考不同的代理程式 (這是模式的實作詳細資料)。</span><span class="sxs-lookup"><span data-stu-id="46cbb-132">If the steps in the workflow being run by the Scheduler use several services and resources across different steps, each step might reference a different Agent (this is an implementation detail of the pattern).</span></span>

- <span data-ttu-id="46cbb-133">**監督員**會監視排程器正在執行之工作中的步驟狀態。</span><span class="sxs-lookup"><span data-stu-id="46cbb-133">The **Supervisor** monitors the status of the steps in the task being performed by the Scheduler.</span></span> <span data-ttu-id="46cbb-134">它會定期執行 (頻率為系統特定)，並檢查排程器所維護之步驟的狀態。</span><span class="sxs-lookup"><span data-stu-id="46cbb-134">It runs periodically (the frequency will be system specific), and examines the status of steps maintained by the Scheduler.</span></span> <span data-ttu-id="46cbb-135">如果它偵測到任何已逾時或失敗，會針對適當的代理程式排列，以復原步驟或執行適當的補救措施 (這可能需要修改步驟的狀態)。</span><span class="sxs-lookup"><span data-stu-id="46cbb-135">If it detects any that have timed out or failed, it arranges for the appropriate Agent to recover the step or execute the appropriate remedial action (this might involve modifying the status of a step).</span></span> <span data-ttu-id="46cbb-136">請注意，復原或修復動作會由排程器和代理程式實作。</span><span class="sxs-lookup"><span data-stu-id="46cbb-136">Note that the recovery or remedial actions are implemented by the Scheduler and Agents.</span></span> <span data-ttu-id="46cbb-137">監督員應該只要求執行這些動作。</span><span class="sxs-lookup"><span data-stu-id="46cbb-137">The Supervisor should simply request that these actions be performed.</span></span>

<span data-ttu-id="46cbb-138">排程器、代理程式和監督員是邏輯元件，它們的實體實作取決於所使用的技術。</span><span class="sxs-lookup"><span data-stu-id="46cbb-138">The Scheduler, Agent, and Supervisor are logical components and their physical implementation depends on the technology being used.</span></span> <span data-ttu-id="46cbb-139">例如，數個邏輯代理程式可能會實作為單一 Web 服務的一部分。</span><span class="sxs-lookup"><span data-stu-id="46cbb-139">For example, several logical agents might be implemented as part of a single web service.</span></span>

<span data-ttu-id="46cbb-140">排程器會維護長期資料存放區中的工作進度和每個步驟的狀態 (稱為狀態存放區) 的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="46cbb-140">The Scheduler maintains information about the progress of the task and the state of each step in a durable data store, called the state store.</span></span> <span data-ttu-id="46cbb-141">主管人員可以使用這項資訊來協助判斷步驟是否失敗。</span><span class="sxs-lookup"><span data-stu-id="46cbb-141">The Supervisor can use this information to help determine whether a step has failed.</span></span> <span data-ttu-id="46cbb-142">此圖說明排程器、代理程式、主管和狀態存放區之間的關聯性。</span><span class="sxs-lookup"><span data-stu-id="46cbb-142">The figure illustrates the relationship between the Scheduler, the Agents, the Supervisor, and the state store.</span></span>

![圖 1 - 排程器代理程式監督員模式中的執行者](./_images/scheduler-agent-supervisor-pattern.png)

> [!NOTE]
> <span data-ttu-id="46cbb-144">這個圖表會顯示簡化版的模式。</span><span class="sxs-lookup"><span data-stu-id="46cbb-144">This diagram shows a simplified version of the pattern.</span></span> <span data-ttu-id="46cbb-145">在實際的實作中，可能會有許多排程器的執行個體同時執行，每個都是工作的子集。</span><span class="sxs-lookup"><span data-stu-id="46cbb-145">In a real implementation, there might be many instances of the Scheduler running concurrently, each a subset of tasks.</span></span> <span data-ttu-id="46cbb-146">同樣地，系統可執行每個代理程式的多個執行個體，或甚至多監督員。</span><span class="sxs-lookup"><span data-stu-id="46cbb-146">Similarly, the system could run multiple instances of each Agent, or even multiple Supervisors.</span></span> <span data-ttu-id="46cbb-147">在此情況下，監督員必須謹慎與彼此協調工作，以確保它們不會競爭復原相同的失敗步驟或工作。</span><span class="sxs-lookup"><span data-stu-id="46cbb-147">In this case, Supervisors must coordinate their work with each other carefully to ensure that they don’t compete to recover the same failed steps and tasks.</span></span> <span data-ttu-id="46cbb-148">[選出領導者模式](./leader-election.md)會對此問題提供一個可行的解決方案。</span><span class="sxs-lookup"><span data-stu-id="46cbb-148">The [Leader Election pattern](./leader-election.md) provides one possible solution to this problem.</span></span>

<span data-ttu-id="46cbb-149">應用程式準備好要執行工作時，它會提交要求至排程器。</span><span class="sxs-lookup"><span data-stu-id="46cbb-149">When the application is ready to run a task, it submits a request to the Scheduler.</span></span> <span data-ttu-id="46cbb-150">排程器會在狀態存放區中記錄關於工作和其步驟的初始狀態資訊 (例如，尚未開始的步驟)，然後開始執行工作流程所定義的作業。</span><span class="sxs-lookup"><span data-stu-id="46cbb-150">The Scheduler records initial state information about the task and its steps (for example, step not yet started) in the state store and then starts performing the operations defined by the workflow.</span></span> <span data-ttu-id="46cbb-151">當排程器啟動每個步驟時，會在狀態存放區中更新該步驟狀態的相關資訊 (例如，步驟執行中)。</span><span class="sxs-lookup"><span data-stu-id="46cbb-151">As the Scheduler starts each step, it updates the information about the state of that step in the state store (for example, step running).</span></span>

<span data-ttu-id="46cbb-152">如果步驟參考遠端服務或資源，排程器就會將訊息傳送至適當的代理程式。</span><span class="sxs-lookup"><span data-stu-id="46cbb-152">If a step references a remote service or resource, the Scheduler sends a message to the appropriate Agent.</span></span> <span data-ttu-id="46cbb-153">除了作業的完成期限時間之外，此訊息包含代理程式傳遞至服務或存取資源時所需的資訊。</span><span class="sxs-lookup"><span data-stu-id="46cbb-153">The message contains the information that the Agent needs to pass to the service or access the resource, in addition to the complete-by time for the operation.</span></span> <span data-ttu-id="46cbb-154">如果代理程式已成功完成其作業，就會傳回回應至排程器。</span><span class="sxs-lookup"><span data-stu-id="46cbb-154">If the Agent completes its operation successfully, it returns a response to the Scheduler.</span></span> <span data-ttu-id="46cbb-155">接著，排程器可以更新狀態存放區中的狀態資訊 (例如，步驟已完成) 並執行下一個步驟。</span><span class="sxs-lookup"><span data-stu-id="46cbb-155">The Scheduler can then update the state information in the state store (for example, step completed) and perform the next step.</span></span> <span data-ttu-id="46cbb-156">此程序會繼續，直到整個工作完成為止。</span><span class="sxs-lookup"><span data-stu-id="46cbb-156">This process continues until the entire task is complete.</span></span>

<span data-ttu-id="46cbb-157">代理程式可以實作執行其工作所需的任何重試邏輯。</span><span class="sxs-lookup"><span data-stu-id="46cbb-157">An Agent can implement any retry logic that's necessary to perform its work.</span></span> <span data-ttu-id="46cbb-158">不過，如果代理程式未在完成期限期間結束之前完成其工作，排程器就會假設作業失敗。</span><span class="sxs-lookup"><span data-stu-id="46cbb-158">However, if the Agent doesn't complete its work before the complete-by period expires, the Scheduler will assume that the operation has failed.</span></span> <span data-ttu-id="46cbb-159">在此案例中，代理程式應該停止其工作，且不嘗試將任何項目傳回排程器 (即使是錯誤訊息)，或嘗試任何形式的復原。</span><span class="sxs-lookup"><span data-stu-id="46cbb-159">In this case, the Agent should stop its work and not try to return anything to the Scheduler (not even an error message), or try any form of recovery.</span></span> <span data-ttu-id="46cbb-160">這項限制的原因是，在步驟已逾時或失敗之後，可能會排定代理程式的另一個執行個體來執行失敗的步驟 (此程序於稍後說明)。</span><span class="sxs-lookup"><span data-stu-id="46cbb-160">The reason for this restriction is that, after a step has timed out or failed, another instance of the Agent might be scheduled to run the failing step (this process is described later).</span></span>

<span data-ttu-id="46cbb-161">如果代理程式失敗，排程器就不會收到回應。</span><span class="sxs-lookup"><span data-stu-id="46cbb-161">If the Agent fails, the Scheduler won't receive a response.</span></span> <span data-ttu-id="46cbb-162">模式無法區分已逾時的步驟和真正失敗的步驟。</span><span class="sxs-lookup"><span data-stu-id="46cbb-162">The pattern doesn't make a distinction between a step that has timed out and one that has genuinely failed.</span></span>

<span data-ttu-id="46cbb-163">如果步驟逾時或失敗，狀態存放區就會包含一筆記錄，表示步驟正在執行，但將已過完成期限時間。</span><span class="sxs-lookup"><span data-stu-id="46cbb-163">If a step times out or fails, the state store will contain a record that indicates that the step is running, but the complete-by time will have passed.</span></span> <span data-ttu-id="46cbb-164">監督員會尋找像這樣的步驟，並嘗試加以復原。</span><span class="sxs-lookup"><span data-stu-id="46cbb-164">The Supervisor looks for steps like this and tries to recover them.</span></span> <span data-ttu-id="46cbb-165">可行的策略之一，是監督員更新完成期限的值來延長完成步驟的可用時間，然後將訊息傳送至排程器，來識別已逾時的步驟。然後，排程器可以嘗試重複此步驟。</span><span class="sxs-lookup"><span data-stu-id="46cbb-165">One possible strategy is for the Supervisor to update the complete-by value to extend the time available to complete the step, and then send a message to the Scheduler identifying the step that has timed out. The Scheduler can then try to repeat this step.</span></span> <span data-ttu-id="46cbb-166">不過，這項設計會要求工作必須為等冪。</span><span class="sxs-lookup"><span data-stu-id="46cbb-166">However, this design requires the tasks to be idempotent.</span></span>

<span data-ttu-id="46cbb-167">如果持續失敗或逾時，監督員可能需要避免重試相同的步驟。若要這樣做，監督員可以維持狀態存放區中每個步驟的重試計數以及狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="46cbb-167">The Supervisor might need to prevent the same step from being retried if it continually fails or times out. To do this, the Supervisor could maintain a retry count for each step, along with the state information, in the state store.</span></span> <span data-ttu-id="46cbb-168">如果這個計數超過預先定義的臨界值，監督員可以採取策略，在通知排程器之前長時間等待，預期錯誤會在這段期間予以解決。</span><span class="sxs-lookup"><span data-stu-id="46cbb-168">If this count exceeds a predefined threshold the Supervisor can adopt a strategy of waiting for an extended period before notifying the Scheduler that it should retry the step, in the expectation that the fault will be resolved during this period.</span></span> <span data-ttu-id="46cbb-169">或者，監督員可以將訊息傳送至排程器，要求透過實作[補償交易模式](./compensating-transaction.md)來復原整個工作。</span><span class="sxs-lookup"><span data-stu-id="46cbb-169">Alternatively, the Supervisor can send a message to the Scheduler to request the entire task be undone by implementing a [Compensating Transaction pattern](./compensating-transaction.md).</span></span> <span data-ttu-id="46cbb-170">這種方法會取決於提供實作每個已順利完成之步驟的補償作業所需資訊的排程器和代理程式。</span><span class="sxs-lookup"><span data-stu-id="46cbb-170">This approach will depend on the Scheduler and Agents providing the information necessary to implement the compensating operations for each step that completed successfully.</span></span>

> <span data-ttu-id="46cbb-171">監督員的目的並不是監視排程器和代理程式，並在它他們失敗時重新啟動。</span><span class="sxs-lookup"><span data-stu-id="46cbb-171">It isn't the purpose of the Supervisor to monitor the Scheduler and Agents, and restart them if they fail.</span></span> <span data-ttu-id="46cbb-172">系統的這個部分應該由這些元件在當中執行中的基礎結構來處理。</span><span class="sxs-lookup"><span data-stu-id="46cbb-172">This aspect of the system should be handled by the infrastructure these components are running in.</span></span> <span data-ttu-id="46cbb-173">同樣地，監督員不應該知道排程器所執行之工作正在執行的實際商務作業 (包括如何補償這些工作應該會失敗)。</span><span class="sxs-lookup"><span data-stu-id="46cbb-173">Similarly, the Supervisor shouldn't have knowledge of the actual business operations that the tasks being performed by the Scheduler are running (including how to compensate should these tasks fail).</span></span> <span data-ttu-id="46cbb-174">這是排程器所實作之工作流程邏輯的目的。</span><span class="sxs-lookup"><span data-stu-id="46cbb-174">This is the purpose of the workflow logic implemented by the Scheduler.</span></span> <span data-ttu-id="46cbb-175">監督員的唯一責任是判斷步驟是否失敗，並進行排列以便其重複，或使包含失敗步驟的整個工作加以復原。</span><span class="sxs-lookup"><span data-stu-id="46cbb-175">The sole responsibility of the Supervisor is to determine whether a step has failed and arrange either for it to be repeated or for the entire task containing the failed step to be undone.</span></span>

<span data-ttu-id="46cbb-176">如果在失敗之後重新啟動排程器，或是排程器執行的工作流程意外終止，排程器應該能夠決定傳遞在失敗時能處理的任何工作狀態，並準備好從該點繼續這項工作。</span><span class="sxs-lookup"><span data-stu-id="46cbb-176">If the Scheduler is restarted after a failure, or the workflow being performed by the Scheduler terminates unexpectedly, the Scheduler should be able to determine the status of any inflight task that it was handling when it failed, and be prepared to resume this task from that point.</span></span> <span data-ttu-id="46cbb-177">此程序的實作詳細資料很可能是特定的系統。</span><span class="sxs-lookup"><span data-stu-id="46cbb-177">The implementation details of this process are likely to be system specific.</span></span> <span data-ttu-id="46cbb-178">如果無法復原工作，可能需要復原工作已執行的工作。</span><span class="sxs-lookup"><span data-stu-id="46cbb-178">If the task can't be recovered, it might be necessary to undo the work already performed by the task.</span></span> <span data-ttu-id="46cbb-179">這也可能需要實作[補償交易](./compensating-transaction.md)。</span><span class="sxs-lookup"><span data-stu-id="46cbb-179">This might also require implementing a [compensating transaction](./compensating-transaction.md).</span></span>

<span data-ttu-id="46cbb-180">此模式的主要優點，是在發生未預期的暫時或永久失敗時，系統會具有恢復功能。</span><span class="sxs-lookup"><span data-stu-id="46cbb-180">The key advantage of this pattern is that the system is resilient in the event of unexpected temporary or unrecoverable failures.</span></span> <span data-ttu-id="46cbb-181">可以建構系統以自動修復。</span><span class="sxs-lookup"><span data-stu-id="46cbb-181">The system can be constructed to be self healing.</span></span> <span data-ttu-id="46cbb-182">例如，如果代理程式或排程器失敗，可以啟動一個新的，且監督員可以排列要繼續進行的工作。</span><span class="sxs-lookup"><span data-stu-id="46cbb-182">For example, if an Agent or the Scheduler fails, a new one can be started and the Supervisor can arrange for a task to be resumed.</span></span> <span data-ttu-id="46cbb-183">如果監督員失敗，可以啟動另一個執行個體，並可以從失敗發生的位置接手。</span><span class="sxs-lookup"><span data-stu-id="46cbb-183">If the Supervisor fails, another instance can be started and can take over from where the failure occurred.</span></span> <span data-ttu-id="46cbb-184">如果監督員排程為定期執行，就可以在預先定義的間隔之後，自動啟動新的執行個體。</span><span class="sxs-lookup"><span data-stu-id="46cbb-184">If the Supervisor is scheduled to run periodically, a new instance can be automatically started after a predefined interval.</span></span> <span data-ttu-id="46cbb-185">可以複寫狀態存放區來觸達更高程度的復原能力。</span><span class="sxs-lookup"><span data-stu-id="46cbb-185">The state store can be replicated to reach an even greater degree of resiliency.</span></span>

## <a name="issues-and-considerations"></a><span data-ttu-id="46cbb-186">問題和考量</span><span class="sxs-lookup"><span data-stu-id="46cbb-186">Issues and considerations</span></span>

<span data-ttu-id="46cbb-187">當您在決定如何實作此模式時，應考慮下列幾點：</span><span class="sxs-lookup"><span data-stu-id="46cbb-187">You should consider the following points when deciding how to implement this pattern:</span></span>

- <span data-ttu-id="46cbb-188">此模式可能會難以實作，且需要完整測試系統每個可能的失敗模式。</span><span class="sxs-lookup"><span data-stu-id="46cbb-188">This pattern can be difficult to implement and requires thorough testing of each possible failure mode of the system.</span></span>

- <span data-ttu-id="46cbb-189">排程器所實作的復原/重試邏輯十分複雜，且取決於狀態存放區中保留的狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="46cbb-189">The recovery/retry logic implemented by the Scheduler is complex and dependent on state information held in the state store.</span></span> <span data-ttu-id="46cbb-190">可能也必須記錄在持久性資料存放區中實作補償交易所需的資訊。</span><span class="sxs-lookup"><span data-stu-id="46cbb-190">It might also be necessary to record the information required to implement a compensating transaction in a durable data store.</span></span>

- <span data-ttu-id="46cbb-191">監督員的執行頻率將會相當重要。</span><span class="sxs-lookup"><span data-stu-id="46cbb-191">How often the Supervisor runs will be important.</span></span> <span data-ttu-id="46cbb-192">必須執行經常來防止任何失敗的步驟長時間封鎖應用程式，但不應該太常執行以至於它變成負荷。</span><span class="sxs-lookup"><span data-stu-id="46cbb-192">It should run often enough to prevent any failed steps from blocking an application for an extended period, but it shouldn't run so often that it becomes an overhead.</span></span>

- <span data-ttu-id="46cbb-193">代理程式所執行的步驟可以執行一次以上。</span><span class="sxs-lookup"><span data-stu-id="46cbb-193">The steps performed by an Agent could be run more than once.</span></span> <span data-ttu-id="46cbb-194">實作這些步驟的邏輯應該具有等冪性。</span><span class="sxs-lookup"><span data-stu-id="46cbb-194">The logic that implements these steps should be idempotent.</span></span>

## <a name="when-to-use-this-pattern"></a><span data-ttu-id="46cbb-195">使用此模式的時機</span><span class="sxs-lookup"><span data-stu-id="46cbb-195">When to use this pattern</span></span>

<span data-ttu-id="46cbb-196">當分散式環境中執行的程序 (例如雲端) 必須對於通訊失敗及/或操作失敗具有彈性時，請使用此模式。</span><span class="sxs-lookup"><span data-stu-id="46cbb-196">Use this pattern when a process that runs in a distributed environment, such as the cloud, must be resilient to communications failure and/or operational failure.</span></span>

<span data-ttu-id="46cbb-197">此模式可能不適用於不會叫用遠端服務或存取遠端資源的工作。</span><span class="sxs-lookup"><span data-stu-id="46cbb-197">This pattern might not be suitable for tasks that don't invoke remote services or access remote resources.</span></span>

## <a name="example"></a><span data-ttu-id="46cbb-198">範例</span><span class="sxs-lookup"><span data-stu-id="46cbb-198">Example</span></span>

<span data-ttu-id="46cbb-199">實作電子商務系統的 web 應用程式已部署在 Microsoft Azure 上。</span><span class="sxs-lookup"><span data-stu-id="46cbb-199">A web application that implements an ecommerce system has been deployed on Microsoft Azure.</span></span> <span data-ttu-id="46cbb-200">使用者可以執行此應用程式來瀏覽可用的產品以及下訂單。</span><span class="sxs-lookup"><span data-stu-id="46cbb-200">Users can run this application to browse the available products and to place orders.</span></span> <span data-ttu-id="46cbb-201">使用者介面會以 web 角色執行，且應用程式的訂單處理元素會以一組背景工作角色來實作。</span><span class="sxs-lookup"><span data-stu-id="46cbb-201">The user interface runs as a web role, and the order processing elements of the application are implemented as a set of worker roles.</span></span> <span data-ttu-id="46cbb-202">訂單處理邏輯有一部分牽涉到存取遠端服務，且系統的這方面可能容易發生暫時性或更多持續性的錯誤。</span><span class="sxs-lookup"><span data-stu-id="46cbb-202">Part of the order processing logic involves accessing a remote service, and this aspect of the system could be prone to transient or more long-lasting faults.</span></span> <span data-ttu-id="46cbb-203">基於這個理由，設計工具使用了排程器代理程式監督員模式來實作系統的訂單處理元素。</span><span class="sxs-lookup"><span data-stu-id="46cbb-203">For this reason, the designers used the Scheduler Agent Supervisor pattern to implement the order processing elements of the system.</span></span>

<span data-ttu-id="46cbb-204">當客戶下訂單時，應用程式會建構訊息來說明訂單，並將此訊息張貼至佇列。</span><span class="sxs-lookup"><span data-stu-id="46cbb-204">When a customer places an order, the application constructs a message that describes the order and posts this message to a queue.</span></span> <span data-ttu-id="46cbb-205">在背景工作角色中執行的個別提交程序會擷取訊息、將訂單詳細資料插入訂單資料庫，並在狀態存放區中建立訂單處理的記錄。</span><span class="sxs-lookup"><span data-stu-id="46cbb-205">A separate submission process, running in a worker role, retrieves the message, inserts the order details into the orders database, and creates a record for the order process in the state store.</span></span> <span data-ttu-id="46cbb-206">請注意，插入訂單資料庫和狀態存放區會以相同作業的一部分執行。</span><span class="sxs-lookup"><span data-stu-id="46cbb-206">Note that the inserts into the orders database and the state store are performed as part of the same operation.</span></span> <span data-ttu-id="46cbb-207">提交程序旨在確保兩個插入一起完成。</span><span class="sxs-lookup"><span data-stu-id="46cbb-207">The submission process is designed to ensure that both inserts complete together.</span></span>

<span data-ttu-id="46cbb-208">提交處理針對訂單建立的狀態資訊包括：</span><span class="sxs-lookup"><span data-stu-id="46cbb-208">The state information that the submission process creates for the order includes:</span></span>

- <span data-ttu-id="46cbb-209">**OrderID**。</span><span class="sxs-lookup"><span data-stu-id="46cbb-209">**OrderID**.</span></span> <span data-ttu-id="46cbb-210">訂單資料庫中的訂單識別碼。</span><span class="sxs-lookup"><span data-stu-id="46cbb-210">The ID of the order in the orders database.</span></span>

- <span data-ttu-id="46cbb-211">**LockedBy**。</span><span class="sxs-lookup"><span data-stu-id="46cbb-211">**LockedBy**.</span></span> <span data-ttu-id="46cbb-212">處理訂單的背景工作角色執行個體識別碼。</span><span class="sxs-lookup"><span data-stu-id="46cbb-212">The instance ID of the worker role handling the order.</span></span> <span data-ttu-id="46cbb-213">可能有多個背景工作角色的目前執行個體在執行排程器，但每筆訂單只應該由單一執行個體來處理。</span><span class="sxs-lookup"><span data-stu-id="46cbb-213">There might be multiple current instances of the worker role running the Scheduler, but each order should only be handled by a single instance.</span></span>

- <span data-ttu-id="46cbb-214">**CompleteBy**。</span><span class="sxs-lookup"><span data-stu-id="46cbb-214">**CompleteBy**.</span></span> <span data-ttu-id="46cbb-215">訂單應該處理的時間。</span><span class="sxs-lookup"><span data-stu-id="46cbb-215">The time the order should be processed by.</span></span>

- <span data-ttu-id="46cbb-216">**ProcessState**。</span><span class="sxs-lookup"><span data-stu-id="46cbb-216">**ProcessState**.</span></span> <span data-ttu-id="46cbb-217">處理訂單的工作目前狀態。</span><span class="sxs-lookup"><span data-stu-id="46cbb-217">The current state of the task handling the order.</span></span> <span data-ttu-id="46cbb-218">可能的狀態為：</span><span class="sxs-lookup"><span data-stu-id="46cbb-218">The possible states are:</span></span>

  - <span data-ttu-id="46cbb-219">**擱置中**。</span><span class="sxs-lookup"><span data-stu-id="46cbb-219">**Pending**.</span></span> <span data-ttu-id="46cbb-220">已建立訂單，但尚未開始處理。</span><span class="sxs-lookup"><span data-stu-id="46cbb-220">The order has been created but processing hasn't yet been started.</span></span>
  - <span data-ttu-id="46cbb-221">**處理中**。</span><span class="sxs-lookup"><span data-stu-id="46cbb-221">**Processing**.</span></span> <span data-ttu-id="46cbb-222">目前正在處理此訂單。</span><span class="sxs-lookup"><span data-stu-id="46cbb-222">The order is currently being processed.</span></span>
  - <span data-ttu-id="46cbb-223">**已處理**。</span><span class="sxs-lookup"><span data-stu-id="46cbb-223">**Processed**.</span></span> <span data-ttu-id="46cbb-224">已成功處理訂單。</span><span class="sxs-lookup"><span data-stu-id="46cbb-224">The order has been processed successfully.</span></span>
  - <span data-ttu-id="46cbb-225">**Error**。</span><span class="sxs-lookup"><span data-stu-id="46cbb-225">**Error**.</span></span> <span data-ttu-id="46cbb-226">訂單處理失敗。</span><span class="sxs-lookup"><span data-stu-id="46cbb-226">The order processing has failed.</span></span>

- <span data-ttu-id="46cbb-227">**FailureCount**。</span><span class="sxs-lookup"><span data-stu-id="46cbb-227">**FailureCount**.</span></span> <span data-ttu-id="46cbb-228">已嘗試處理訂單的次數。</span><span class="sxs-lookup"><span data-stu-id="46cbb-228">The number of times that processing has been tried for the order.</span></span>

<span data-ttu-id="46cbb-229">在這個狀態資訊，`OrderID`欄位會從新的訂單的訂單識別碼複製。</span><span class="sxs-lookup"><span data-stu-id="46cbb-229">In this state information, the `OrderID` field is copied from the order ID of the new order.</span></span> <span data-ttu-id="46cbb-230">`LockedBy` 和 `CompleteBy` 欄位會設定為 `null`、`ProcessState` 欄位設定為 `Pending`，而 `FailureCount` 欄位設為 0。</span><span class="sxs-lookup"><span data-stu-id="46cbb-230">The `LockedBy` and `CompleteBy` fields are set to `null`, the `ProcessState` field is set to `Pending`, and the `FailureCount` field is set to 0.</span></span>

> [!NOTE]
> <span data-ttu-id="46cbb-231">在此範例中，訂單處理邏輯相當簡單，且只有叫用遠端服務的單一步驟。</span><span class="sxs-lookup"><span data-stu-id="46cbb-231">In this example, the order handling logic is relatively simple and only has a single step that invokes a remote service.</span></span> <span data-ttu-id="46cbb-232">在更複雜的多步驟情節中，提交程序可能需要幾個步驟，也因此會在狀態存放區中建立數個記錄；每個記錄都會描述個別步驟的狀態。</span><span class="sxs-lookup"><span data-stu-id="46cbb-232">In a more complex multistep scenario, the submission process would likely involve several steps, and so several records would be created in the state store—each one describing the state of an individual step.</span></span>

<span data-ttu-id="46cbb-233">排程器也會以背景工作角色的一部分執行，並且實作處理訂單的商務邏輯。</span><span class="sxs-lookup"><span data-stu-id="46cbb-233">The Scheduler also runs as part of a worker role and implements the business logic that handles the order.</span></span> <span data-ttu-id="46cbb-234">輪詢新訂單的排程器執行個體會檢查記錄的狀態存放區，當中的 `LockedBy` 欄位為 null 且 `ProcessState` 欄位為擱置中。</span><span class="sxs-lookup"><span data-stu-id="46cbb-234">An instance of the Scheduler polling for new orders examines the state store for records where the `LockedBy` field is null and the `ProcessState` field is pending.</span></span> <span data-ttu-id="46cbb-235">當排程器找到新的訂單時，會立即將其本身的執行個體識別碼填入 `LockedBy` 欄位、將 `CompleteBy` 欄位設定為適當的時間，並將 `ProcessState` 欄位設定為處理中。</span><span class="sxs-lookup"><span data-stu-id="46cbb-235">When the Scheduler finds a new order, it immediately populates the `LockedBy` field with its own instance ID, sets the `CompleteBy` field to an appropriate time, and sets the `ProcessState` field to processing.</span></span> <span data-ttu-id="46cbb-236">程式碼是設計為專有且不可部分完成，以確保排程器的兩個並行執行個體無法嘗試同時處理相同的訂單。</span><span class="sxs-lookup"><span data-stu-id="46cbb-236">The code is designed to be exclusive and atomic to ensure that two concurrent instances of the Scheduler can't try to handle the same order simultaneously.</span></span>

<span data-ttu-id="46cbb-237">然後，排程器會執行商務工作流程，以非同步方式處理訂單，從狀態存放區中，將 `OrderID` 欄位中的值傳遞給它。</span><span class="sxs-lookup"><span data-stu-id="46cbb-237">The Scheduler then runs the business workflow to process the order asynchronously, passing it the value in the `OrderID` field from the state store.</span></span> <span data-ttu-id="46cbb-238">處理訂單的工作流程會從訂單資料庫中擷取訂單的詳細資訊，並執行其工作。</span><span class="sxs-lookup"><span data-stu-id="46cbb-238">The workflow handling the order retrieves the details of the order from the orders database and performs its work.</span></span> <span data-ttu-id="46cbb-239">當訂單處理工作流程中的步驟需要叫用遠端服務時，會使用代理程式。</span><span class="sxs-lookup"><span data-stu-id="46cbb-239">When a step in the order processing workflow needs to invoke the remote service, it uses an Agent.</span></span> <span data-ttu-id="46cbb-240">工作流程步驟會使用一組 Azure 服務匯流排訊息佇列作為要求/回應通道來與代理程式通訊。</span><span class="sxs-lookup"><span data-stu-id="46cbb-240">The workflow step communicates with the Agent using a pair of Azure Service Bus message queues acting as a request/response channel.</span></span> <span data-ttu-id="46cbb-241">此圖會顯示解決方案的高層級檢視。</span><span class="sxs-lookup"><span data-stu-id="46cbb-241">The figure shows a high level view of the solution.</span></span>

![圖 2 - 使用排程器代理程式監督員模式來處理 Azure 解決方案中的訂單](./_images/scheduler-agent-supervisor-solution.png)

<span data-ttu-id="46cbb-243">從工作流程步驟傳送至代理程式的訊息會說明訂單，並包括完成期限時間。</span><span class="sxs-lookup"><span data-stu-id="46cbb-243">The message sent to the Agent from a workflow step describes the order and includes the complete-by time.</span></span> <span data-ttu-id="46cbb-244">如果代理程式在完成期限時間過期之前收到來自遠端服務的回應，它會在工作流程所接聽的服務匯流排佇列上張貼回覆訊息。</span><span class="sxs-lookup"><span data-stu-id="46cbb-244">If the Agent receives a response from the remote service before the complete-by time expires, it posts a reply message on the Service Bus queue on which the workflow is listening.</span></span> <span data-ttu-id="46cbb-245">當工作流程步驟收到有效的回覆訊息時，會完成其處理，且排程器會將訂單狀態的 \`ProcessState 欄位設定為已處理。</span><span class="sxs-lookup"><span data-stu-id="46cbb-245">When the workflow step receives the valid reply message, it completes its processing and the Scheduler sets the \`ProcessState field of the order state to processed.</span></span> <span data-ttu-id="46cbb-246">此時，訂單處理已順利完成。</span><span class="sxs-lookup"><span data-stu-id="46cbb-246">At this point, the order processing has completed successfully.</span></span>

<span data-ttu-id="46cbb-247">如果完成期限時間在代理程式從遠端服務收到回應之前就過期，代理程式只會中止其處理，並終止處理訂單。</span><span class="sxs-lookup"><span data-stu-id="46cbb-247">If the complete-by time expires before the Agent receives a response from the remote service, the Agent simply halts its processing and terminates handling the order.</span></span> <span data-ttu-id="46cbb-248">同樣地，如果處理訂單的工作流程超過完成期限時間，它也會終止。</span><span class="sxs-lookup"><span data-stu-id="46cbb-248">Similarly, if the workflow handling the order exceeds the complete-by time, it also terminates.</span></span> <span data-ttu-id="46cbb-249">在這兩種情況下，狀態存放區中的訂單狀態會維持設定為處理中，但是完成期限時間會表示處理訂單所經過的時間，且程序會被視為已失敗。</span><span class="sxs-lookup"><span data-stu-id="46cbb-249">In both cases, the state of the order in the state store remains set to processing, but the complete-by time indicates that the time for processing the order has passed and the process is deemed to have failed.</span></span> <span data-ttu-id="46cbb-250">請注意，如果正在存取遠端服務的代理程式或正在處理訂單 (或兩者) 的工作流程非預期地終止，狀態存放區中的資訊就會再次保持設定為處理中，而且最終會出現過期的完成期限值。</span><span class="sxs-lookup"><span data-stu-id="46cbb-250">Note that if the Agent that's accessing the remote service, or the workflow that's handling the order (or both) terminate unexpectedly, the information in the state store will again remain set to processing and eventually will have an expired complete-by value.</span></span>

<span data-ttu-id="46cbb-251">如果代理程式在嘗試連絡遠端服務時偵測到無法復原、非暫時性的錯誤，可以將錯誤回應傳送回工作流程。</span><span class="sxs-lookup"><span data-stu-id="46cbb-251">If the Agent detects an unrecoverable, nontransient fault while it's trying to contact the remote service, it can send an error response back to the workflow.</span></span> <span data-ttu-id="46cbb-252">排程器可以將訂單狀態設定為錯誤，並引發警示操作員的事件。</span><span class="sxs-lookup"><span data-stu-id="46cbb-252">The Scheduler can set the status of the order to error and raise an event that alerts an operator.</span></span> <span data-ttu-id="46cbb-253">接著，作業員可以嘗試以手動方式解決失敗的原因，然後再重新送出失敗的處理步驟。</span><span class="sxs-lookup"><span data-stu-id="46cbb-253">The operator can then try to resolve the reason for the failure manually and resubmit the failed processing step.</span></span>

<span data-ttu-id="46cbb-254">監督員會定期檢查狀態存放區，尋找完成期限值過期的訂單。</span><span class="sxs-lookup"><span data-stu-id="46cbb-254">The Supervisor periodically examines the state store looking for orders with an expired complete-by value.</span></span> <span data-ttu-id="46cbb-255">如果監督員找到記錄，就會自動遞增 `FailureCount` 欄位。</span><span class="sxs-lookup"><span data-stu-id="46cbb-255">If the Supervisor finds a record, it increments the `FailureCount` field.</span></span> <span data-ttu-id="46cbb-256">如果失敗計數值低於指定的臨界值，監督員會將 `LockedBy` 欄位重設為 null、使用新的到期時間更新 `CompleteBy` 設定，並將 `ProcessState` 欄位設為擱置中。</span><span class="sxs-lookup"><span data-stu-id="46cbb-256">If the failure count value is below a specified threshold value, the Supervisor resets the `LockedBy` field to null, updates the `CompleteBy` field with a new expiration time, and sets the `ProcessState` field to pending.</span></span> <span data-ttu-id="46cbb-257">排程器的執行個體可挑出此訂單，並照舊執行其處理。</span><span class="sxs-lookup"><span data-stu-id="46cbb-257">An instance of the Scheduler can pick up this order and perform its processing as before.</span></span> <span data-ttu-id="46cbb-258">如果失敗計數值超過指定的臨界值，就會假設失敗的原因是非暫時性的。</span><span class="sxs-lookup"><span data-stu-id="46cbb-258">If the failure count value exceeds a specified threshold, the reason for the failure is assumed to be nontransient.</span></span> <span data-ttu-id="46cbb-259">監督員會將訂單狀態設定為錯誤，並引發警示操作員的事件。</span><span class="sxs-lookup"><span data-stu-id="46cbb-259">The Supervisor sets the status of the order to error and raises an event that alerts an operator.</span></span>

> <span data-ttu-id="46cbb-260">在此範例中，會以個別的背景工作角色來實作監督員。</span><span class="sxs-lookup"><span data-stu-id="46cbb-260">In this example, the Supervisor is implemented in a separate worker role.</span></span> <span data-ttu-id="46cbb-261">您可以使用各種不同的策略來排列要執行的監督員工作，包括使用 Azure 排程器服務 (不會與此模式中的排程器元件混淆)。</span><span class="sxs-lookup"><span data-stu-id="46cbb-261">You can use a variety of strategies to arrange for the Supervisor task to be run, including using the Azure Scheduler service (not to be confused with the Scheduler component in this pattern).</span></span> <span data-ttu-id="46cbb-262">如需有關 Azure 排程器服務的詳細資訊，請瀏覽[排程器](https://azure.microsoft.com/services/scheduler/)頁面。</span><span class="sxs-lookup"><span data-stu-id="46cbb-262">For more information about the Azure Scheduler service, visit the [Scheduler](https://azure.microsoft.com/services/scheduler/) page.</span></span>

<span data-ttu-id="46cbb-263">雖然此範例中未顯示，但排程器可能需要保留提交通知訂單進度和狀態之訂單的應用程式。</span><span class="sxs-lookup"><span data-stu-id="46cbb-263">Although it isn't shown in this example, the Scheduler might need to keep the application that submitted the order informed about the progress and status of the order.</span></span> <span data-ttu-id="46cbb-264">應用程式和排程器會互相隔離，來排除它們之間的任何相依性。</span><span class="sxs-lookup"><span data-stu-id="46cbb-264">The application and the Scheduler are isolated from each other to eliminate any dependencies between them.</span></span> <span data-ttu-id="46cbb-265">應用程式不了解排程器的哪個執行個體正在處理訂單，而排程器不知道哪一個特定的應用程式執行個體會張貼訂單。</span><span class="sxs-lookup"><span data-stu-id="46cbb-265">The application has no knowledge of which instance of the Scheduler is handling the order, and the Scheduler is unaware of which specific application instance posted the order.</span></span>

<span data-ttu-id="46cbb-266">若要允許報告訂單狀態，應用程式可以使用自己的私人回應佇列。</span><span class="sxs-lookup"><span data-stu-id="46cbb-266">To allow the order status to be reported, the application could use its own private response queue.</span></span> <span data-ttu-id="46cbb-267">會包含此回應佇列的詳細資料作為傳送至提交程序之要求的一部分，從而在狀態存放區中包含這項資訊。</span><span class="sxs-lookup"><span data-stu-id="46cbb-267">The details of this response queue would be included as part of the request sent to the submission process, which would include this information in the state store.</span></span> <span data-ttu-id="46cbb-268">然後，排程器會將訊息張貼到此佇列，指出訂單的狀態 (已接收要求、已完成訂單、訂單失敗等等)。</span><span class="sxs-lookup"><span data-stu-id="46cbb-268">The Scheduler would then post messages to this queue indicating the status of the order (request received, order completed, order failed, and so on).</span></span> <span data-ttu-id="46cbb-269">它應該包含這些訊息中的訂單識別碼，讓它們可以與應用程式的原始要求相互關聯。</span><span class="sxs-lookup"><span data-stu-id="46cbb-269">It should include the order ID in these messages so they can be correlated with the original request by the application.</span></span>

## <a name="related-patterns-and-guidance"></a><span data-ttu-id="46cbb-270">相關的模式和指導方針</span><span class="sxs-lookup"><span data-stu-id="46cbb-270">Related patterns and guidance</span></span>

<span data-ttu-id="46cbb-271">實作此模式時，下列模式和指導方針可能也相關：</span><span class="sxs-lookup"><span data-stu-id="46cbb-271">The following patterns and guidance might also be relevant when implementing this pattern:</span></span>

- <span data-ttu-id="46cbb-272">[重試模式](./retry.md)。</span><span class="sxs-lookup"><span data-stu-id="46cbb-272">[Retry pattern](./retry.md).</span></span> <span data-ttu-id="46cbb-273">代理程式可以使用此模式明確地重試作業，存取先前已失敗的遠端服務或資源。</span><span class="sxs-lookup"><span data-stu-id="46cbb-273">An Agent can use this pattern to transparently retry an operation that accesses a remote service or resource that has previously failed.</span></span> <span data-ttu-id="46cbb-274">當您預期失敗的原因是暫時性且可以更正時，就請使用。</span><span class="sxs-lookup"><span data-stu-id="46cbb-274">Use when the expectation is that the cause of the failure is transient and can be corrected.</span></span>
- <span data-ttu-id="46cbb-275">[斷路器模式](./circuit-breaker.md)。</span><span class="sxs-lookup"><span data-stu-id="46cbb-275">[Circuit Breaker pattern](./circuit-breaker.md).</span></span> <span data-ttu-id="46cbb-276">在連線到遠端服務或資源時，代理程式可以使用此模式來處理需要不同時間進行修正的錯誤。</span><span class="sxs-lookup"><span data-stu-id="46cbb-276">An Agent can use this pattern to handle faults that take a variable amount of time to correct when connecting to a remote service or resource.</span></span>
- <span data-ttu-id="46cbb-277">[補償交易模式](./compensating-transaction.md)。</span><span class="sxs-lookup"><span data-stu-id="46cbb-277">[Compensating Transaction pattern](./compensating-transaction.md).</span></span> <span data-ttu-id="46cbb-278">如果排程器正在執行的工作流程無法順利完成，可能必須復原先前執行的任何工作。</span><span class="sxs-lookup"><span data-stu-id="46cbb-278">If the workflow being performed by a Scheduler can't be completed successfully, it might be necessary to undo any work it's previously performed.</span></span> <span data-ttu-id="46cbb-279">補償交易模式會說明遵循最終一致性模型的作業如何達成這項工作。</span><span class="sxs-lookup"><span data-stu-id="46cbb-279">The Compensating Transaction pattern describes how this can be achieved for operations that follow the eventual consistency model.</span></span> <span data-ttu-id="46cbb-280">這些作業的類型通常是由執行複雜商務程序和工作流程的排程器進行實作。</span><span class="sxs-lookup"><span data-stu-id="46cbb-280">These types of operations are commonly implemented by a Scheduler that performs complex business processes and workflows.</span></span>
- <span data-ttu-id="46cbb-281">[非同步傳訊入門](https://msdn.microsoft.com/library/dn589781.aspx)。</span><span class="sxs-lookup"><span data-stu-id="46cbb-281">[Asynchronous Messaging Primer](https://msdn.microsoft.com/library/dn589781.aspx).</span></span> <span data-ttu-id="46cbb-282">排程器代理程式監督員模式中的元件通常會以互相減少的方式執行，並以非同步方式進行通訊。</span><span class="sxs-lookup"><span data-stu-id="46cbb-282">The components in the Scheduler Agent Supervisor pattern typically run decoupled from each other and communicate asynchronously.</span></span> <span data-ttu-id="46cbb-283">描述一些可用來實作以訊息佇列作為基礎的非同步通訊方法。</span><span class="sxs-lookup"><span data-stu-id="46cbb-283">Describes some of the approaches that can be used to implement asynchronous communication based on message queues.</span></span>
- <span data-ttu-id="46cbb-284">[選出領導者模式](./leader-election.md)。</span><span class="sxs-lookup"><span data-stu-id="46cbb-284">[Leader Election pattern](./leader-election.md).</span></span> <span data-ttu-id="46cbb-285">可能必須協調監督員多個執行個體的動作，防止它們嘗試復原相同的失敗程序。</span><span class="sxs-lookup"><span data-stu-id="46cbb-285">It might be necessary to coordinate the actions of multiple instances of a Supervisor to prevent them from attempting to recover the same failed process.</span></span> <span data-ttu-id="46cbb-286">選出領導者模式描述如何執行這項操作。</span><span class="sxs-lookup"><span data-stu-id="46cbb-286">The Leader Election pattern describes how to do this.</span></span>
- <span data-ttu-id="46cbb-287">[雲端架構：排程器代理程式監督員模式](https://blogs.msdn.microsoft.com/clemensv/2010/09/27/cloud-architecture-the-scheduler-agent-supervisor-pattern/)</span><span class="sxs-lookup"><span data-stu-id="46cbb-287">[Cloud Architecture: The Scheduler-Agent-Supervisor Pattern](https://blogs.msdn.microsoft.com/clemensv/2010/09/27/cloud-architecture-the-scheduler-agent-supervisor-pattern/) on Clemens Vasters' blog</span></span>
- [<span data-ttu-id="46cbb-288">程序管理員模式</span><span class="sxs-lookup"><span data-stu-id="46cbb-288">Process Manager pattern</span></span>](https://www.enterpriseintegrationpatterns.com/patterns/messaging/ProcessManager.html)
- <span data-ttu-id="46cbb-289">[參考 6：Sagas 的冒險故事](https://msdn.microsoft.com/library/jj591569.aspx)。</span><span class="sxs-lookup"><span data-stu-id="46cbb-289">[Reference 6: A Saga on Sagas](https://msdn.microsoft.com/library/jj591569.aspx).</span></span> <span data-ttu-id="46cbb-290">顯示 CQRS 模式如何使用程序管理員 (CQRS Journey 指南的一部分) 的範例。</span><span class="sxs-lookup"><span data-stu-id="46cbb-290">An example showing how the CQRS pattern uses a process manager (part of the CQRS Journey guidance).</span></span>
- [<span data-ttu-id="46cbb-291">Microsoft Azure 排程器</span><span class="sxs-lookup"><span data-stu-id="46cbb-291">Microsoft Azure Scheduler</span></span>](https://azure.microsoft.com/services/scheduler/)
